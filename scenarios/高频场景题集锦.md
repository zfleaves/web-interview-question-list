# 高频场景题集锦

## 1. 如何实现一个防抖的搜索框？

**答案：**

```javascript
// 封装防抖函数
function debounce(func, delay) {
  let timer = null;
  
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// 使用
class SearchBox extends React.Component {
  state = {
    keyword: '',
    results: []
  };
  
  handleSearch = debounce((keyword) => {
    // 模拟 API 请求
    fetch(`/api/search?keyword=${keyword}`)
      .then(res => res.json())
      .then(data => {
        this.setState({ results: data });
      });
  }, 300);
  
  handleChange = (e) => {
    const keyword = e.target.value;
    this.setState({ keyword });
    this.handleSearch(keyword);
  };
  
  render() {
    return (
      <div>
        <input
          type="text"
          value={this.state.keyword}
          onChange={this.handleChange}
          placeholder="搜索..."
        />
        <ul>
          {this.state.results.map(item => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      </div>
    );
  }
}
```

---

## 2. 如何实现一个虚拟滚动列表？

**答案：**

```javascript
class VirtualList extends React.Component {
  state = {
    visibleStart: 0,
    visibleEnd: 10
  };
  
  containerRef = React.createRef();
  
  componentDidMount() {
    this.containerRef.current.addEventListener('scroll', this.handleScroll);
  }
  
  componentWillUnmount() {
    this.containerRef.current.removeEventListener('scroll', this.handleScroll);
  }
  
  handleScroll = () => {
    const container = this.containerRef.current;
    const scrollTop = container.scrollTop;
    const itemHeight = 50;
    const visibleCount = Math.ceil(container.clientHeight / itemHeight);
    
    const start = Math.floor(scrollTop / itemHeight);
    const end = start + visibleCount;
    
    this.setState({
      visibleStart: start,
      visibleEnd: end
    });
  };
  
  render() {
    const { items, itemHeight = 50 } = this.props;
    const { visibleStart, visibleEnd } = this.state;
    
    const visibleItems = items.slice(visibleStart, visibleEnd);
    const totalHeight = items.length * itemHeight;
    const offsetY = visibleStart * itemHeight;
    
    return (
      <div
        ref={this.containerRef}
        style={{
          height: '500px',
          overflow: 'auto'
        }}
      >
        <div style={{ height: totalHeight, position: 'relative' }}>
          <div
            style={{
              transform: `translateY(${offsetY}px)`,
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0
            }}
          >
            {visibleItems.map((item, index) => (
              <div
                key={index}
                style={{
                  height: itemHeight,
                  boxSizing: 'border-box',
                  padding: '10px',
                  borderBottom: '1px solid #eee'
                }}
              >
                {item}
              </div>
            ))}
          </div>
        </div>
      </div>
    );
  }
}

// 使用
const items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);
<VirtualList items={items} itemHeight={50} />
```

---

## 3. 如何实现一个无限滚动加载？

**答案：**

```javascript
class InfiniteScroll extends React.Component {
  state = {
    items: [],
    page: 1,
    loading: false,
    hasMore: true
  };
  
  componentDidMount() {
    this.loadItems();
    window.addEventListener('scroll', this.handleScroll);
  }
  
  componentWillUnmount() {
    window.removeEventListener('scroll', this.handleScroll);
  }
  
  loadItems = async () => {
    if (this.state.loading || !this.state.hasMore) return;
    
    this.setState({ loading: true });
    
    try {
      const { page } = this.state;
      const newItems = await this.fetchItems(page);
      
      this.setState(prevState => ({
        items: [...prevState.items, ...newItems],
        page: page + 1,
        loading: false,
        hasMore: newItems.length >= 10
      }));
    } catch (error) {
      console.error(error);
      this.setState({ loading: false });
    }
  };
  
  fetchItems = async (page) => {
    const response = await fetch(`/api/items?page=${page}`);
    const data = await response.json();
    return data;
  };
  
  handleScroll = () => {
    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
    
    // 距离底部 100px 时加载更多
    if (scrollTop + clientHeight >= scrollHeight - 100) {
      this.loadItems();
    }
  };
  
  render() {
    const { items, loading } = this.state;
    
    return (
      <div>
        <ul>
          {items.map((item, index) => (
            <li key={index}>{item.name}</li>
          ))}
        </ul>
        {loading && <div>加载中...</div>}
      </div>
    );
  }
}
```

---

## 4. 如何实现一个拖拽上传组件？

**答案：**

```javascript
class DragUpload extends React.Component {
  state = {
    isDragging: false,
    files: []
  };
  
  handleDragEnter = (e) => {
    e.preventDefault();
    e.stopPropagation();
    this.setState({ isDragging: true });
  };
  
  handleDragLeave = (e) => {
    e.preventDefault();
    e.stopPropagation();
    this.setState({ isDragging: false });
  };
  
  handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  
  handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    this.setState({ isDragging: false });
    
    const files = Array.from(e.dataTransfer.files);
    this.handleFiles(files);
  };
  
  handleFiles = (files) => {
    this.setState(prevState => ({
      files: [...prevState.files, ...files]
    }));
    
    // 上传文件
    files.forEach(file => this.uploadFile(file));
  };
  
  uploadFile = async (file) => {
    const formData = new FormData();
    formData.append('file', file);
    
    try {
      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData
      });
      const data = await response.json();
      console.log('上传成功:', data);
    } catch (error) {
      console.error('上传失败:', error);
    }
  };
  
  render() {
    const { isDragging, files } = this.state;
    
    return (
      <div>
        <div
          onDragEnter={this.handleDragEnter}
          onDragLeave={this.handleDragLeave}
          onDragOver={this.handleDragOver}
          onDrop={this.handleDrop}
          style={{
            border: `2px dashed ${isDragging ? '#1890ff' : '#d9d9d9'}`,
            padding: '40px',
            textAlign: 'center',
            backgroundColor: isDragging ? '#f0f9ff' : '#fafafa'
          }}
        >
          {isDragging ? '释放文件以上传' : '拖拽文件到此处'}
        </div>
        
        <ul>
          {files.map((file, index) => (
            <li key={index}>{file.name}</li>
          ))}
        </ul>
      </div>
    );
  }
}
```

---

## 5. 如何实现一个图片懒加载？

**答案：**

```javascript
class LazyImage extends React.Component {
  state = {
    loaded: false
  };
  
  imgRef = React.createRef();
  
  componentDidMount() {
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            this.setState({ loaded: true });
            this.observer.unobserve(entry.target);
          }
        });
      },
      {
        rootMargin: '100px' // 提前 100px 加载
      }
    );
    
    if (this.imgRef.current) {
      this.observer.observe(this.imgRef.current);
    }
  }
  
  componentWillUnmount() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
  
  render() {
    const { src, alt, placeholder } = this.props;
    const { loaded } = this.state;
    
    return (
      <img
        ref={this.imgRef}
        src={loaded ? src : placeholder}
        alt={alt}
        loading="lazy"
        style={{
          opacity: loaded ? 1 : 0.5,
          transition: 'opacity 0.3s'
        }}
      />
    );
  }
}

// 使用
<LazyImage
  src="https://example.com/image.jpg"
  alt="图片"
  placeholder="https://example.com/placeholder.jpg"
/>
```

---

## 6. 如何实现一个表单验证？

**答案：**

```javascript
class FormValidation extends React.Component {
  state = {
    formData: {
      username: '',
      email: '',
      password: ''
    },
    errors: {}
  };
  
  validators = {
    username: [
      { required: true, message: '用户名不能为空' },
      { minLength: 3, message: '用户名至少 3 个字符' }
    ],
    email: [
      { required: true, message: '邮箱不能为空' },
      { pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/, message: '邮箱格式不正确' }
    ],
    password: [
      { required: true, message: '密码不能为空' },
      { minLength: 6, message: '密码至少 6 个字符' }
    ]
  };
  
  validateField = (name, value) => {
    const rules = this.validators[name];
    const errors = [];
    
    for (const rule of rules) {
      if (rule.required && !value) {
        errors.push(rule.message);
      }
      
      if (rule.minLength && value.length < rule.minLength) {
        errors.push(rule.message);
      }
      
      if (rule.pattern && !rule.pattern.test(value)) {
        errors.push(rule.message);
      }
    }
    
    return errors;
  };
  
  handleChange = (e) => {
    const { name, value } = e.target;
    
    this.setState(prevState => ({
      formData: {
        ...prevState.formData,
        [name]: value
      },
      errors: {
        ...prevState.errors,
        [name]: this.validateField(name, value)
      }
    }));
  };
  
  handleSubmit = (e) => {
    e.preventDefault();
    
    const { formData } = this.state;
    const errors = {};
    
    // 验证所有字段
    Object.keys(formData).forEach(name => {
      const fieldErrors = this.validateField(name, formData[name]);
      if (fieldErrors.length > 0) {
        errors[name] = fieldErrors;
      }
    });
    
    this.setState({ errors });
    
    // 如果没有错误，提交表单
    if (Object.keys(errors).length === 0) {
      this.submitForm(formData);
    }
  };
  
  submitForm = async (formData) => {
    try {
      const response = await fetch('/api/submit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(formData)
      });
      const data = await response.json();
      console.log('提交成功:', data);
    } catch (error) {
      console.error('提交失败:', error);
    }
  };
  
  render() {
    const { formData, errors } = this.state;
    
    return (
      <form onSubmit={this.handleSubmit}>
        <div>
          <label>用户名：</label>
          <input
            type="text"
            name="username"
            value={formData.username}
            onChange={this.handleChange}
          />
          {errors.username && (
            <div style={{ color: 'red' }}>
              {errors.username.join(', ')}
            </div>
          )}
        </div>
        
        <div>
          <label>邮箱：</label>
          <input
            type="email"
            name="email"
            value={formData.email}
            onChange={this.handleChange}
          />
          {errors.email && (
            <div style={{ color: 'red' }}>
              {errors.email.join(', ')}
            </div>
          )}
        </div>
        
        <div>
          <label>密码：</label>
          <input
            type="password"
            name="password"
            value={formData.password}
            onChange={this.handleChange}
          />
          {errors.password && (
            <div style={{ color: 'red' }}>
              {errors.password.join(', ')}
            </div>
          )}
        </div>
        
        <button type="submit">提交</button>
      </form>
    );
  }
}
```

---

## 7. 如何实现一个权限控制组件？

**答案：**

```javascript
// 权限上下文
const PermissionContext = React.createContext();

function PermissionProvider({ permissions, children }) {
  return (
    <PermissionContext.Provider value={permissions}>
      {children}
    </PermissionContext.Provider>
  );
}

// 权限检查组件
function Permission({ permission, fallback = null, children }) {
  const permissions = React.useContext(PermissionContext);
  
  const hasPermission = permissions.includes(permission);
  
  if (!hasPermission) {
    return fallback;
  }
  
  return children;
}

// 使用
function App() {
  const userPermissions = ['read', 'write', 'delete'];
  
  return (
    <PermissionProvider permissions={userPermissions}>
      <Dashboard />
    </PermissionProvider>
  );
}

function Dashboard() {
  return (
    <div>
      <Permission permission="read">
        <ReadData />
      </Permission>
      
      <Permission permission="write" fallback={<div>没有写入权限</div>}>
        <WriteData />
      </Permission>
      
      <Permission permission="delete" fallback={<div>没有删除权限</div>}>
        <DeleteData />
      </Permission>
    </div>
  );
}
```

---

## 8. 如何实现一个主题切换功能？

**答案：**

```javascript
// 主题上下文
const ThemeContext = React.createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = React.useState('light');
  
  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// 使用主题的组件
function ThemedComponent() {
  const { theme, toggleTheme } = React.useContext(ThemeContext);
  
  const themeStyles = {
    light: {
      backgroundColor: '#ffffff',
      color: '#000000'
    },
    dark: {
      backgroundColor: '#000000',
      color: '#ffffff'
    }
  };
  
  return (
    <div style={themeStyles[theme]}>
      <button onClick={toggleTheme}>
        切换主题（当前：{theme}）
      </button>
    </div>
  );
}

// 使用
function App() {
  return (
    <ThemeProvider>
      <ThemedComponent />
    </ThemeProvider>
  );
}
```

---

## 9. 如何实现一个国际化（i18n）方案？

**答案：**

```javascript
// 语言包
const messages = {
  zh: {
    welcome: '欢迎',
    goodbye: '再见',
    login: '登录',
    logout: '退出'
  },
  en: {
    welcome: 'Welcome',
    goodbye: 'Goodbye',
    login: 'Login',
    logout: 'Logout'
  }
};

// 国际化上下文
const I18nContext = React.createContext();

function I18nProvider({ children }) {
  const [language, setLanguage] = React.useState('zh');
  
  const t = (key) => {
    return messages[language][key] || key;
  };
  
  const changeLanguage = (lang) => {
    setLanguage(lang);
  };
  
  return (
    <I18nContext.Provider value={{ language, t, changeLanguage }}>
      {children}
    </I18nContext.Provider>
  );
}

// 使用国际化的组件
function LocalizedComponent() {
  const { language, t, changeLanguage } = React.useContext(I18nContext);
  
  return (
    <div>
      <h1>{t('welcome')}</h1>
      <button onClick={() => changeLanguage('zh')}>中文</button>
      <button onClick={() => changeLanguage('en')}>English</button>
    </div>
  );
}

// 使用
function App() {
  return (
    <I18nProvider>
      <LocalizedComponent />
    </I18nProvider>
  );
}
```

---

## 10. 如何实现一个错误边界（Error Boundary）？

**答案：**

```javascript
class ErrorBoundary extends React.Component {
  state = {
    hasError: false,
    error: null,
    errorInfo: null
  };
  
  static getDerivedStateFromError(error) {
    return {
      hasError: true
    };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    
    this.setState({
      error,
      errorInfo
    });
    
    // 上报错误
    this.logErrorToService(error, errorInfo);
  }
  
  logErrorToService = (error, errorInfo) => {
    // 发送错误到日志服务
    fetch('/api/log-error', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        error: error.toString(),
        stack: error.stack,
        componentStack: errorInfo.componentStack
      })
    });
  };
  
  handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h2>出错了</h2>
          <details>
            <summary>错误详情</summary>
            <pre>{this.state.error && this.state.error.toString()}</pre>
            <pre>{this.state.errorInfo.componentStack}</pre>
          </details>
          <button onClick={this.handleReset}>重试</button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// 使用
function App() {
  return (
    <ErrorBoundary>
      <MyComponent />
    </ErrorBoundary>
  );
}

// 可能出错的组件
function MyComponent() {
  const [data, setData] = React.useState(null);
  
  React.useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(data => setData(data))
      .catch(error => {
        throw new Error('Failed to load data');
      });
  }, []);
  
  if (!data) {
    return <div>Loading...</div>;
  }
  
  return <div>{data.name}</div>;
}
```

---

## 总结

高频场景题重点掌握：

1. **防抖节流**：优化性能，减少不必要的操作
2. **虚拟滚动**：处理大量数据，提高性能
3. **无限滚动**：实现分页加载
4. **拖拽上传**：提升用户体验
5. **图片懒加载**：优化页面加载
6. **表单验证**：确保数据正确性
7. **权限控制**：保护敏感功能
8. **主题切换**：提供个性化体验
9. **国际化**：支持多语言
10. **错误边界**：优雅处理错误