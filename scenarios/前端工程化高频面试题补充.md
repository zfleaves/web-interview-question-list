# 前端工程化高频面试题补充

## 1. 如何初始化前端项目？

**答案：**

```bash
# 使用 pnpm（推荐）
pnpm create vite my-app --template vue-ts

# 使用 npm
npm create vite@latest my-app -- --template vue-ts

# 使用 yarn
yarn create vite my-app --template vue-ts
```

---

## 2. 如何设计项目目录结构？

**答案：**

```
my-app/
├── public/              # 静态资源
├── src/
│   ├── api/            # API 接口
│   ├── assets/         # 资源文件
│   ├── components/     # 公共组件
│   ├── composables/    # 组合式函数
│   ├── config/         # 配置文件
│   ├── hooks/          # 自定义 Hooks
│   ├── layouts/        # 布局组件
│   ├── router/         # 路由配置
│   ├── stores/         # 状态管理
│   ├── styles/         # 全局样式
│   ├── types/          # TypeScript 类型
│   ├── utils/          # 工具函数
│   ├── views/          # 页面组件
│   ├── App.vue
│   └── main.ts
├── .env.development
├── .env.production
├── .eslintrc.cjs
├── .prettierrc
├── .gitignore
├── index.html
├── package.json
├── pnpm-lock.yaml
├── tsconfig.json
├── tsconfig.node.json
├── vite.config.ts
└── README.md
```

---

## 3. 如何配置项目文件？

**答案：**

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { resolve } from 'path';

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true
      }
    }
  }
});
```

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

---

## 4. 如何配置代码规范？

**答案：**

```javascript
// .eslintrc.cjs
module.exports = {
  root: true,
  env: {
    browser: true,
    es2021: true,
    node: true
  },
  extends: [
    'plugin:vue/vue3-recommended',
    'eslint:recommended',
    '@vue/typescript/recommended',
    '@vue/prettier'
  ],
  parserOptions: {
    ecmaVersion: 'latest',
    parser: '@typescript-eslint/parser'
  },
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'vue/multi-word-component-names': 'off'
  }
};
```

```javascript
// .prettierrc
module.exports = {
  semi: false,
  singleQuote: true,
  printWidth: 100,
  trailingComma: 'none',
  arrowParens: 'avoid'
};
```

---

## 5. 如何配置 Git 规范？

**答案：**

```bash
# .gitignore
node_modules
dist
.DS_Store
*.log
.env.local
.env.*.local
```

```bash
# 安装 husky 和 lint-staged
pnpm add -D husky lint-staged

# 初始化 husky
pnpm exec husky install

# 添加 pre-commit 钩子
pnpm exec husky add .husky/pre-commit "pnpm exec lint-staged"
```

```json
// package.json
{
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix",
    "format": "prettier --write src/"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx,vue}": ["eslint --fix", "prettier --write"],
    "*.{json,css,scss,md}": ["prettier --write"]
  }
}
```

---

## 6. 如何设计组件库的项目结构？

**答案：**

```
my-component-library/
├── packages/
│   ├── components/      # 组件包
│   ├── theme/           # 主题包
│   ├── utils/           # 工具包
│   └── icons/           # 图标包
├── docs/                # 文档
├── scripts/             # 构建脚本
├── package.json
├── pnpm-workspace.yaml
└── tsconfig.json
```

---

## 7. 如何开发组件库的组件？

**答案：**

```vue
<!-- Button.vue -->
<template>
  <button :class="classes" @click="handleClick">
    <slot />
  </button>
</template>

<script setup lang="ts">
import { computed } from 'vue';

interface Props {
  type?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  type: 'primary',
  size: 'medium',
  disabled: false
});

const emit = defineEmits<{
  click: [event: MouseEvent];
}>();

const classes = computed(() => [
  'btn',
  `btn-${props.type}`,
  `btn-${props.size}`,
  { 'btn-disabled': props.disabled }
]);

const handleClick = (event: MouseEvent) => {
  if (!props.disabled) {
    emit('click', event);
  }
};
</script>

<style scoped>
.btn {
  /* 样式 */
}
</style>
```

---

## 8. 如何导出组件库的组件？

**答案：**

```typescript
// components/index.ts
import Button from './Button/Button.vue';
import Input from './Input/Input.vue';

export { Button, Input };

export default {
  Button,
  Input
};
```

---

## 9. 如何实现组件库的主题系统？

**答案：**

```typescript
// theme/index.ts
export const theme = {
  colors: {
    primary: '#1890ff',
    success: '#52c41a',
    warning: '#faad14',
    danger: '#ff4d4f'
  },
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px'
  },
  borderRadius: {
    sm: '2px',
    md: '4px',
    lg: '8px'
  }
};
```

---

## 10. 如何生成组件库的文档？

**答案：**

```typescript
// 使用 VitePress
// docs/.vitepress/config.ts
import { defineConfig } from 'vitepress';

export default defineConfig({
  title: 'My Component Library',
  description: 'A Vue 3 component library',
  themeConfig: {
    nav: [
      { text: 'Guide', link: '/guide/' },
      { text: 'Components', link: '/components/button' }
    ],
    sidebar: [
      {
        text: 'Guide',
        items: [
          { text: 'Getting Started', link: '/guide/' },
          { text: 'Installation', link: '/guide/installation' }
        ]
      },
      {
        text: 'Components',
        items: [
          { text: 'Button', link: '/components/button' },
          { text: 'Input', link: '/components/input' }
        ]
      }
    ]
  }
});
```

---

## 11. 如何实现单元测试？

**答案：**

```bash
# 安装 Vitest
pnpm add -D vitest @vue/test-utils

# 配置
pnpm add -D jsdom @vitest/ui
```

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import vue from '@vitejs/plugin-vue';
import { resolve } from 'path';

export default defineConfig({
  plugins: [vue()],
  test: {
    globals: true,
    environment: 'jsdom',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html']
    }
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  }
});
```

```typescript
// Button.test.ts
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import Button from '@/components/Button/Button.vue';

describe('Button', () => {
  it('renders properly', () => {
    const wrapper = mount(Button, {
      slots: {
        default: 'Click me'
      }
    });
    expect(wrapper.text()).toContain('Click me');
  });

  it('emits click event', async () => {
    const wrapper = mount(Button);
    await wrapper.trigger('click');
    expect(wrapper.emitted('click')).toBeTruthy();
  });

  it('does not emit click when disabled', async () => {
    const wrapper = mount(Button, {
      props: { disabled: true }
    });
    await wrapper.trigger('click');
    expect(wrapper.emitted('click')).toBeFalsy();
  });
});
```

---

## 12. 如何实现组件测试？

**答案：**

```typescript
// Form.test.ts
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import Form from '@/components/Form/Form.vue';

describe('Form', () => {
  it('validates required fields', async () => {
    const wrapper = mount(Form);
    const submitButton = wrapper.find('button[type="submit"]');

    await submitButton.trigger('click');
    expect(wrapper.find('.error').exists()).toBe(true);
  });

  it('submits valid form', async () => {
    const wrapper = mount(Form);
    await wrapper.find('input[name="username"]').setValue('test');
    await wrapper.find('button[type="submit"]').trigger('click');

    expect(wrapper.emitted('submit')).toBeTruthy();
  });
});
```

---

## 13. 如何实现 E2E 测试？

**答案：**

```bash
# 安装 Playwright
pnpm add -D @playwright/test
```

```typescript
// e2e/example.spec.ts
import { test, expect } from '@playwright/test';

test('has title', async ({ page }) => {
  await page.goto('http://localhost:3000');
  await expect(page).toHaveTitle(/My App/);
});

test('button click', async ({ page }) => {
  await page.goto('http://localhost:3000');
  await page.click('button');
  await expect(page.locator('.result')).toHaveText('Success');
});
```

---

## 14. 如何使用 GitHub Actions 实现 CI/CD？

**答案：**

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Lint
        run: pnpm run lint

      - name: Type check
        run: pnpm run type-check

      - name: Test
        run: pnpm run test

      - name: Build
        run: pnpm run build

      - name: Upload coverage
        uses: codecov/codecov-action@v3
```

---

## 15. 如何使用 Docker 部署？

**答案：**

```dockerfile
# Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm && pnpm install --frozen-lockfile

COPY . .
RUN pnpm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

```nginx
# nginx.conf
server {
  listen 80;
  server_name localhost;

  root /usr/share/nginx/html;
  index index.html;

  location / {
    try_files $uri $uri/ /index.html;
  }

  location /api {
    proxy_pass http://backend:8080;
  }
}
```

---

## 16. 如何使用 Kubernetes 部署？

**答案：**

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
        - name: frontend
          image: my-frontend:latest
          ports:
            - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: frontend
spec:
  selector:
    app: frontend
  ports:
    - port: 80
      targetPort: 80
  type: LoadBalancer
```

---

## 17. 如何使用 ESLint 进行代码质量监控？

**答案：**

```javascript
// .eslintrc.cjs
module.exports = {
  extends: [
    'plugin:vue/vue3-recommended',
    'eslint:recommended',
    '@vue/typescript/recommended'
  ],
  rules: {
    'no-console': 'warn',
    'no-debugger': 'warn',
    'vue/multi-word-component-names': 'off',
    '@typescript-eslint/no-explicit-any': 'warn'
  }
};
```

---

## 18. 如何使用 Prettier 进行代码格式化？

**答案：**

```javascript
// .prettierrc
module.exports = {
  semi: false,
  singleQuote: true,
  printWidth: 100,
  trailingComma: 'none',
  arrowParens: 'avoid'
};
```

---

## 19. 如何使用 SonarQube 进行代码质量分析？

**答案：**

```yaml
# .github/workflows/sonarqube.yml
name: SonarQube Scan

on:
  push:
    branches: [main]

jobs:
  sonarqube:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
```

---

## 20. 如何使用 Codecov 进行代码覆盖率分析？

**答案：**

```yaml
# .github/workflows/codecov.yml
name: Codecov

on:
  push:
    branches: [main]

jobs:
  codecov:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup pnpm
        uses: pnpm/action-setup@v2

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Test with coverage
        run: pnpm run test:coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
```

---

## 21. 如何使用 pnpm workspace 管理 monorepo？

**答案：**

```yaml
# pnpm-workspace.yaml
packages:
  - 'packages/*'
```

```json
// package.json
{
  "name": "my-monorepo",
  "private": true,
  "scripts": {
    "dev": "pnpm --filter './packages/*' dev",
    "build": "pnpm --filter './packages/*' build",
    "test": "pnpm --filter './packages/*' test"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
```

---

## 22. 如何使用 Turborepo 管理 monorepo？

**答案：**

```bash
# 安装 Turborepo
pnpm add -D turbo

# 初始化
npx turbo init
```

```json
// turbo.json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**"]
    },
    "test": {
      "dependsOn": ["build"]
    },
    "lint": {}
  }
}
```

---

## 23. 如何使用 Changesets 管理 monorepo 版本？

**答案：**

```bash
# 安装 Changesets
pnpm add -D @changesets/cli

# 初始化
pnpm changeset init
```

```json
// .changeset/config.json
{
  "$schema": "https://unpkg.com/@changesets/config@2.0.0/schema.json",
  "changelog": "@changesets/cli/changelog",
  "commit": false,
  "linked": [],
  "access": "restricted",
  "baseBranch": "main",
  "updateInternalDependencies": "patch",
  "ignore": []
}
```

---

## 24. 如何使用 qiankun 实现微前端架构？

**答案：**

```javascript
// 主应用
import { registerMicroApps, start } from 'qiankun';

registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:3001',
    container: '#subapp-viewport',
    activeRule: '/app1'
  },
  {
    name: 'app2',
    entry: '//localhost:3002',
    container: '#subapp-viewport',
    activeRule: '/app2'
  }
]);

start();
```

---

## 25. 如何使用 Module Federation 实现微前端架构？

**答案：**

```javascript
// 主应用 webpack.config.js
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      remotes: {
        app1: 'app1@http://localhost:3001/remoteEntry.js'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true }
      }
    })
  ]
};
```

---

## 26. 如何使用 single-spa 实现微前端架构？

**答案：**

```javascript
// 主应用
import { registerApplication, start } from 'single-spa';

registerApplication({
  name: 'app1',
  app: () => System.import('app1'),
  activeWhen: '/app1'
});

start();
```

---

## 27. 如何使用 VitePress 实现文档自动化？

**答案：**

```bash
# 安装 VitePress
pnpm add -D vitepress

# 初始化
pnpm vitepress init
```

```typescript
// docs/.vitepress/config.ts
import { defineConfig } from 'vitepress';

export default defineConfig({
  title: 'My Docs',
  description: 'Documentation',
  themeConfig: {
    nav: [
      { text: 'Guide', link: '/guide/' },
      { text: 'API', link: '/api/' }
    ],
    sidebar: [
      {
        text: 'Guide',
        items: [
          { text: 'Getting Started', link: '/guide/' }
        ]
      }
    ]
  }
});
```

---

## 28. 如何使用 Storybook 实现文档自动化？

**答案：**

```bash
# 安装 Storybook
npx storybook@latest init
```

```typescript
// .storybook/main.ts
import type { StorybookConfig } from '@storybook/vue3-vite';

const config: StorybookConfig = {
  stories: ['../src/**/*.mdx', '../src/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
    '@storybook/addon-interactions'
  ],
  framework: {
    name: '@storybook/vue3-vite',
    options: {}
  },
  docs: {
    autodocs: 'tag'
  }
};

export default config;
```

```typescript
// Button.stories.ts
import type { Meta, StoryObj } from '@storybook/vue3';
import Button from './Button.vue';

const meta: Meta<typeof Button> = {
  title: 'Example/Button',
  component: Button,
  tags: ['autodocs']
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Primary: Story = {
  args: {
    type: 'primary',
    label: 'Button'
  }
};
```

---

## 29. 如何使用 Sentry 实现监控和日志？

**答案：**

```javascript
// main.ts
import * as Sentry from '@sentry/vue';

Sentry.init({
  app,
  dsn: 'your-dsn',
  integrations: [
    new Sentry.BrowserTracing(),
    new Sentry.Replay()
  ],
  tracesSampleRate: 1.0,
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0
});
```

---

## 30. 如何使用 Google Analytics 实现监控？

**答案：**

```javascript
// main.ts
import VueGtag from 'vue-gtag';

app.use(VueGtag, {
  config: { id: 'GA_MEASUREMENT_ID' }
});
```

---

## 31. 如何实现自定义日志系统？

**答案：**

```typescript
// logger.ts
class Logger {
  private isDevelopment = import.meta.env.DEV;

  info(message: string, data?: any) {
    if (this.isDevelopment) {
      console.log(`[INFO] ${message}`, data);
    }
    // 发送到日志服务
    this.sendLog('info', message, data);
  }

  error(message: string, error?: any) {
    console.error(`[ERROR] ${message}`, error);
    this.sendLog('error', message, error);
  }

  private sendLog(level: string, message: string, data?: any) {
    // 发送到后端日志服务
    fetch('/api/logs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ level, message, data, timestamp: Date.now() })
    });
  }
}

export const logger = new Logger();
```

---

## 32. 如何使用 Web Vitals 实现性能监控？

**答案：**

```javascript
// main.ts
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

getCLS(console.log);
getFID(console.log);
getFCP(console.log);
getLCP(console.log);
getTTFB(console.log);
```

---

## 33. 如何使用 Performance API 实现性能监控？

**答案：**

```javascript
// performance.ts
export function getPerformanceMetrics() {
  const perfData = performance.getEntriesByType('navigation')[0];

  return {
    dns: perfData.domainLookupEnd - perfData.domainLookupStart,
    tcp: perfData.connectEnd - perfData.connectStart,
    ttfb: perfData.responseStart - perfData.requestStart,
    download: perfData.responseEnd - perfData.responseStart,
    domLoad: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
    windowLoad: perfData.loadEventEnd - perfData.loadEventStart
  };
}
```

---

## 34. 如何使用 Lighthouse CI 实现性能监控？

**答案：**

```yaml
# .github/workflows/lighthouse.yml
name: Lighthouse CI

on:
  push:
    branches: [main]

jobs:
  lighthouse:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Run Lighthouse CI
        uses: treosh/lighthouse-ci-action@v9
        with:
          urls: |
            http://localhost:3000
          uploadArtifacts: true
          temporaryPublicStorage: true
```

---

## 总结

以上补充了前端工程化的高频面试题，涵盖了：

1. **项目初始化** - 使用 Vite 创建项目
2. **目录结构设计** - 企业级项目结构
3. **项目配置** - Vite 和 TypeScript 配置
4. **代码规范** - ESLint 和 Prettier 配置
5. **Git 规范** - Husky 和 lint-staged 配置
6. **组件库结构** - Monorepo 组件库设计
7. **组件开发** - Vue 3 组件开发
8. **组件导出** - 组件导出方式
9. **主题系统** - 组件库主题配置
10. **文档生成** - VitePress 文档配置
11. **单元测试** - Vitest 单元测试
12. **组件测试** - Vue 组件测试
13. **E2E 测试** - Playwright 端到端测试
14. **GitHub Actions** - CI/CD 配置
15. **Docker 部署** - 容器化部署
16. **Kubernetes 部署** - K8s 部署配置
17. **ESLint** - 代码质量检查
18. **Prettier** - 代码格式化
19. **SonarQube** - 代码质量分析
20. **Codecov** - 代码覆盖率分析
21. **pnpm workspace** - Monorepo 管理
22. **Turborepo** - Monorepo 构建优化
23. **Changesets** - Monorepo 版本管理
24. **qiankun** - 微前端实现
25. **Module Federation** - 微前端实现
26. **single-spa** - 微前端实现
27. **VitePress** - 文档自动化
28. **Storybook** - 组件文档
29. **Sentry** - 错误监控
30. **Google Analytics** - 用户行为分析
31. **自定义日志** - 日志系统实现
32. **Web Vitals** - 性能指标监控
33. **Performance API** - 性能数据采集
34. **Lighthouse CI** - 性能测试自动化

这些题目补充了前端工程化的高级实践，能够更全面地考察候选人的工程化能力。