# 前端性能优化高频面试题补充

## 1. 如何实现代码分割优化首屏加载？

**答案：**

代码分割是将代码拆分成多个小块，按需加载，从而减少初始加载体积。

```javascript
// 路由懒加载
const routes = [
  {
    path: '/home',
    component: () => import('@/views/Home.vue')
  },
  {
    path: '/about',
    component: () => import('@/views/About.vue')
  }
];

// Webpack 动态导入
const module = await import('./module.js');
```

---

## 2. 如何使用资源预加载和预取优化性能？

**答案：**

预加载提前加载关键资源，预取提前加载可能需要的资源。

```html
<!-- 预加载关键资源 -->
<link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/styles/main.css" as="style">
<link rel="preload" href="/scripts/main.js" as="script">

<!-- 预取可能需要的资源 -->
<link rel="prefetch" href="/scripts/about.js">

<!-- 预连接到可能需要的域名 -->
<link rel="preconnect" href="https://api.example.com">
<link rel="dns-prefetch" href="https://api.example.com">
```

---

## 3. 如何实现关键 CSS 内联优化？

**答案：**

将关键 CSS 内联到 HTML 中，减少阻塞渲染的时间，非关键 CSS 异步加载。

```html
<!-- 内联关键 CSS -->
<style>
  body { margin: 0; }
  .header { height: 60px; }
</style>

<!-- 异步加载非关键 CSS -->
<link rel="preload" href="/styles/main.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="/styles/main.css"></noscript>
```

---

## 4. 如何优化图片加载性能？

**答案：**

使用现代图片格式、响应式图片和懒加载技术优化图片加载。

```html
<!-- 使用 WebP 格式 -->
<picture>
  <source srcset="image.webp" type="image/webp">
  <source srcset="image.jpg" type="image/jpeg">
  <img src="image.jpg" alt="Image" loading="lazy">
</picture>

<!-- 响应式图片 -->
<img
  src="image-small.jpg"
  srcset="image-small.jpg 480w, image-medium.jpg 768w, image-large.jpg 1024w"
  sizes="(max-width: 480px) 480px, (max-width: 768px) 768px, 1024px"
  alt="Responsive Image"
>
```

---

## 5. 如何减少阻塞渲染的资源？

**答案：**

使用异步加载和延迟加载技术，减少阻塞渲染的资源。

```html
<!-- 异步加载 JavaScript -->
<script src="script.js" async></script>
<script src="script.js" defer></script>

<!-- 延迟加载非关键 JavaScript -->
<script>
  window.addEventListener('load', function() {
    var script = document.createElement('script');
    script.src = 'non-critical.js';
    document.body.appendChild(script);
  });
</script>
```

---

## 6. 如何避免阻塞主线程？

**答案：**

使用 Web Worker 和 requestIdleCallback 将耗时任务移出主线程。

```javascript
// 使用 Web Worker
const worker = new Worker('worker.js');
worker.postMessage({ data: largeData });
worker.onmessage = (e) => {
  console.log('Result:', e.data);
};

// 使用 requestIdleCallback
function heavyTask() {
  requestIdleCallback(() => {
    performComputation();
  });
}
```

---

## 7. 如何优化 DOM 操作性能？

**答案：**

减少 DOM 操作次数，使用文档片段和批量更新。

```javascript
// ❌ 频繁操作 DOM
for (let i = 0; i < 1000; i++) {
  document.body.appendChild(createElement(i));
}

// ✅ 使用文档片段
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  fragment.appendChild(createElement(i));
}
document.body.appendChild(fragment);
```

---

## 8. 如何使用虚拟滚动优化长列表？

**答案：**

虚拟滚动只渲染可视区域的元素，大幅减少 DOM 节点数量。

```javascript
// 使用 react-window 或 vue-virtual-scroller
import { FixedSizeList } from 'react-window';

const Row = ({ index, style }) => (
  <div style={style}>Row {index}</div>
);

const VirtualList = () => (
  <FixedSizeList
    height={600}
    itemCount={10000}
    itemSize={35}
    width="100%"
  >
    {Row}
  </FixedSizeList>
);
```

---

## 9. 如何避免内存泄漏？

**答案：**

及时清理定时器、事件监听器，使用 WeakMap/WeakSet。

```javascript
// ✅ 正确清理
function Component() {
  const timer = setInterval(() => {
    console.log('tick');
  }, 1000);

  return () => {
    clearInterval(timer);
  };
}

// ✅ 使用 WeakMap/WeakSet
const cache = new WeakMap();
cache.set(element, data);
// 当 element 被回收时，cache 中的数据也会被回收
```

---

## 10. 如何优化 CSS 选择器和动画？

**答案：**

减少选择器复杂度，使用 transform 和 opacity 实现动画。

```css
/* ❌ 复杂的选择器 */
body div.container ul li a span.text { color: red; }

/* ✅ 简单的选择器 */
.text { color: red; }

/* ✅ 使用 transform 和 opacity 实现动画 */
.element {
  transform: translateX(100px);
  opacity: 0;
  transition: all 0.3s;
}
```

---

## 11. 如何使用 Service Worker 和缓存优化？

**答案：**

Service Worker 可以缓存静态资源，实现离线访问。

```javascript
// 注册 Service Worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js');
}

// sw.js
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('v1').then((cache) => {
      return cache.addAll(['/', '/styles/main.css', '/scripts/main.js']);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});
```

---

## 12. 如何优化移动端性能？

**答案：**

优化视口配置、触摸事件，使用 passive 事件监听器。

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
```

```css
/* 优化触摸目标 */
.button {
  min-width: 48px;
  min-height: 48px;
  -webkit-tap-highlight-color: transparent;
}

/* 优化滚动 */
.container {
  -webkit-overflow-scrolling: touch;
}
```

```javascript
// passive: true 提示浏览器不会调用 preventDefault()
window.addEventListener('touchstart', handleTouch, { passive: true });
window.addEventListener('touchmove', handleTouch, { passive: true });
```

---

## 13. 如何使用 SSR 和 SEO 优化？

**答案：**

SSR（服务器端渲染）可以让搜索引擎更好地抓取页面内容，配合语义化 HTML 和 Meta 标签。

```html
<!-- 语义化 HTML -->
<header><nav><ul><li><a href="/">Home</a></li></ul></nav></header>
<main><article><h1>Title</h1><p>Content</p></article></main>

<!-- Meta 标签 -->
<meta name="description" content="Page description">
<meta property="og:title" content="Page Title">
<meta property="og:image" content="image.jpg">

<!-- 结构化数据 -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Article Title",
  "datePublished": "2025-01-08"
}
</script>
```

---

## 14. 如何使用 Web Vitals 监控性能？

**答案：**

Web Vitals 提供了关键的性能指标（LCP、FID、CLS）。

```javascript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

getCLS(console.log);  // 累积布局偏移
getFID(console.log);  // 首次输入延迟
getFCP(console.log);  // 首次内容绘制
getLCP(console.log);  // 最大内容绘制
getTTFB(console.log); // 首字节时间
```

---

## 15. 前端性能优化有哪些核心策略？

**答案：**

前端性能优化核心策略包括：

1. **网络层优化**：CDN、HTTP/2、资源压缩（Gzip/Brotli）、缓存策略
2. **资源加载优化**：代码分割、懒加载、预加载/预取、关键资源内联
3. **渲染优化**：减少 DOM 操作、虚拟滚动、CSS 动画优化、避免布局抖动
4. **JavaScript 优化**：防抖节流、Web Worker、避免内存泄漏
5. **构建优化**：Tree Shaking、代码压缩、图片优化、字体子集化
6. **监控分析**：Lighthouse、Performance API、Web Vitals