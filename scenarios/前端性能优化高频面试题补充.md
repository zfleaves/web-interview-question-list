# 前端性能优化高频面试题补充

## 1. 如何实现代码分割优化首屏加载？

**答案：**

代码分割是将代码拆分成多个小块，按需加载，从而减少初始加载体积。

```javascript
// 路由懒加载
const routes = [
  {
    path: '/home',
    component: () => import('@/views/Home.vue')
  },
  {
    path: '/about',
    component: () => import('@/views/About.vue')
  }
];

// 组件懒加载
const AsyncComponent = defineAsyncComponent(() => import('./AsyncComponent.vue'));

// Webpack 动态导入
const module = await import('./module.js');
```

---

## 2. 如何使用资源预加载优化性能？

**答案：**

预加载可以提前加载关键资源，减少等待时间。

```html
<!-- 预加载关键资源 -->
<link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/styles/main.css" as="style">
<link rel="preload" href="/scripts/main.js" as="script">

<!-- 预取可能需要的资源 -->
<link rel="prefetch" href="/scripts/about.js">

<!-- 预连接到可能需要的域名 -->
<link rel="preconnect" href="https://api.example.com">
<link rel="dns-prefetch" href="https://api.example.com">
```

---

## 3. 如何实现关键 CSS 内联优化？

**答案：**

将关键 CSS 内联到 HTML 中，可以减少阻塞渲染的时间。

```html
<!-- 内联关键 CSS -->
<style>
  /* 关键路径 CSS */
  body { margin: 0; }
  .header { height: 60px; }
  /* ... */
</style>

<!-- 异步加载非关键 CSS -->
<link rel="preload" href="/styles/main.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="/styles/main.css"></noscript>
```

---

## 4. 如何优化图片加载性能？

**答案：**

使用现代图片格式、响应式图片和懒加载技术优化图片加载。

```html
<!-- 使用 WebP 格式 -->
<picture>
  <source srcset="image.webp" type="image/webp">
  <source srcset="image.jpg" type="image/jpeg">
  <img src="image.jpg" alt="Image">
</picture>

<!-- 响应式图片 -->
<img
  src="image-small.jpg"
  srcset="image-small.jpg 480w, image-medium.jpg 768w, image-large.jpg 1024w"
  sizes="(max-width: 480px) 480px, (max-width: 768px) 768px, 1024px"
  alt="Responsive Image"
>

<!-- 懒加载 -->
<img src="placeholder.jpg" data-src="image.jpg" loading="lazy" alt="Lazy Image">
```

---

## 5. 如何减少阻塞渲染的资源？

**答案：**

使用异步加载和延迟加载技术，减少阻塞渲染的资源。

```html
<!-- 异步加载 JavaScript -->
<script src="script.js" async></script>
<script src="script.js" defer></script>

<!-- 延迟加载非关键 JavaScript -->
<script>
  window.addEventListener('load', function() {
    var script = document.createElement('script');
    script.src = 'non-critical.js';
    document.body.appendChild(script);
  });
</script>
```

---

## 6. 如何使用 CDN 优化性能？

**答案：**

使用 CDN 可以加速静态资源的加载，减少服务器压力。

```javascript
// 使用 CDN 加速静态资源
const config = {
  cdnUrl: 'https://cdn.example.com',
  assets: {
    js: `${config.cdnUrl}/js/`,
    css: `${config.cdnUrl}/css/`,
    images: `${config.cdnUrl}/images/`
  }
};
```

---

## 7. 如何启用 Gzip 压缩优化？

**答案：**

启用 Gzip 压缩可以大幅减少传输数据量。

```javascript
// Nginx 配置
gzip on;
gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

// Express 配置
const compression = require('compression');
app.use(compression());
```

---

## 8. 如何避免阻塞主线程？

**答案：**

使用 Web Worker 和 requestIdleCallback 将耗时任务移出主线程。

```javascript
// ❌ 阻塞主线程
function heavyComputation() {
  for (let i = 0; i < 10000000; i++) {
    // 耗时计算
  }
}

// ✅ 使用 Web Worker
const worker = new Worker('worker.js');
worker.postMessage({ data: largeData });
worker.onmessage = (e) => {
  console.log('Result:', e.data);
};

// ✅ 使用 requestIdleCallback
function heavyTask() {
  requestIdleCallback(() => {
    // 在浏览器空闲时执行
    performComputation();
  });
}
```

---

## 9. 如何使用防抖和节流优化性能？

**答案：**

防抖和节流可以减少频繁触发的操作，提高性能。

```javascript
// 防抖
function debounce(func, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => func.apply(this, args), delay);
  };
}

// 节流
function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// 使用
window.addEventListener('scroll', debounce(handleScroll, 300));
window.addEventListener('resize', throttle(handleResize, 200));
```

---

## 10. 如何优化循环性能？

**答案：**

优化循环可以减少不必要的计算，提高执行效率。

```javascript
// ❌ 低效的循环
for (let i = 0; i < array.length; i++) {
  // 每次都计算 array.length
}

// ✅ 优化后的循环
const length = array.length;
for (let i = 0; i < length; i++) {
  // 只计算一次 length
}

// ✅ 使用 for...of（适用于需要遍历值的情况）
for (const item of array) {
  // 更简洁
}

// ✅ 使用 forEach（适用于简单遍历）
array.forEach(item => {
  // 更简洁
});
```

---

## 11. 如何优化 DOM 操作性能？

**答案：**

减少 DOM 操作次数，使用文档片段和批量更新。

```javascript
// ❌ 频繁操作 DOM
for (let i = 0; i < 1000; i++) {
  document.body.appendChild(createElement(i));
}

// ✅ 使用文档片段
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  fragment.appendChild(createElement(i));
}
document.body.appendChild(fragment);

// ✅ 批量更新
const updates = [];
for (let i = 0; i < 1000; i++) {
  updates.push(createElement(i));
}
requestAnimationFrame(() => {
  updates.forEach(el => document.body.appendChild(el));
});
```

---

## 12. 如何使用虚拟滚动优化长列表？

**答案：**

虚拟滚动只渲染可视区域的元素，大幅减少 DOM 节点数量。

```javascript
// 使用 react-window 或 vue-virtual-scroller
import { FixedSizeList } from 'react-window';

const Row = ({ index, style }) => (
  <div style={style}>Row {index}</div>
);

const VirtualList = () => (
  <FixedSizeList
    height={600}
    itemCount={10000}
    itemSize={35}
    width="100%"
  >
    {Row}
  </FixedSizeList>
);
```

---

## 13. 如何避免内存泄漏？

**答案：**

及时清理定时器、事件监听器，使用 WeakMap/WeakSet。

```javascript
// ❌ 内存泄漏
function Component() {
  const timer = setInterval(() => {
    console.log('tick');
  }, 1000);
  // 没有清理定时器
}

// ✅ 正确清理
function Component() {
  const timer = setInterval(() => {
    console.log('tick');
  }, 1000);

  return () => {
    clearInterval(timer);
  };
}

// ✅ 使用 WeakMap/WeakSet
const cache = new WeakMap();
cache.set(element, data);
// 当 element 被回收时，cache 中的数据也会被回收
```

---

## 14. 如何使用性能优化 API？

**答案：**

使用 Performance API 和 console.time 监控性能。

```javascript
// 使用 Performance API
performance.mark('start');

// 执行代码
heavyTask();

performance.mark('end');
performance.measure('heavyTask', 'start', 'end');
const measure = performance.getEntriesByName('heavyTask')[0];
console.log(`Execution time: ${measure.duration}ms`);

// 使用 console.time
console.time('heavyTask');
heavyTask();
console.timeEnd('heavyTask');
```

---

## 15. 如何优化 CSS 选择器？

**答案：**

减少选择器复杂度，使用简单的类选择器。

```css
/* ❌ 复杂的选择器 */
body div.container ul li a span.text {
  color: red;
}

/* ✅ 简单的选择器 */
.text {
  color: red;
}

/* ✅ 使用类选择器 */
.button-primary {
  background: blue;
}
```

---

## 16. 如何避免使用 @import？

**答案：**

使用 link 标签代替 @import，避免阻塞渲染。

```css
/* ❌ 使用 @import 会阻塞渲染 */
@import url('styles.css');

/* ✅ 使用 link 标签 */
<link rel="stylesheet" href="styles.css">
```

---

## 17. 如何使用 CSS 变量？

**答案：**

CSS 变量可以提高代码复用性，便于维护。

```css
/* 定义变量 */
:root {
  --primary-color: #1890ff;
  --font-size-base: 14px;
}

/* 使用变量 */
.button {
  background: var(--primary-color);
  font-size: var(--font-size-base);
}
```

---

## 18. 如何使用 will-change 优化？

**答案：**

will-change 提示浏览器元素会变化，提前做好优化准备。

```css
/* 提示浏览器元素会变化 */
.element {
  will-change: transform;
}

/* 动画结束后移除 */
.element.animating {
  will-change: transform;
  animation: slide 1s;
}
```

---

## 19. 如何使用 contain 优化？

**答案：**

contain 可以隔离元素的重绘和重排，提高性能。

```css
/* 隔离元素的重绘和重排 */
.element {
  contain: layout paint;
}

/* 更严格的隔离 */
.element {
  contain: strict;
}
```

---

## 20. 如何优化 CSS 动画？

**答案：**

使用 transform 和 opacity 实现动画，避免使用 left/top。

```css
/* 使用 transform 和 opacity */
.element {
  transform: translateX(100px);
  opacity: 0;
  transition: all 0.3s;
}

/* ✅ 使用 transform */
.element {
  transform: translateX(100px);
}

/* ❌ 避免使用 left/top */
.element {
  left: 100px;
}
```

---

## 21. 如何使用 HTTP/2 优化？

**答案：**

HTTP/2 支持多路复用、头部压缩，可以提升加载性能。

```nginx
# Nginx 配置
listen 443 ssl http2;
```

---

## 22. 如何使用 Service Worker 缓存？

**答案：**

Service Worker 可以缓存静态资源，实现离线访问。

```javascript
// 注册 Service Worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js');
}

// sw.js
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('v1').then((cache) => {
      return cache.addAll([
        '/',
        '/styles/main.css',
        '/scripts/main.js'
      ]);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});
```

---

## 23. 如何使用 IndexedDB？

**答案：**

IndexedDB 是浏览器提供的本地数据库，可以存储大量数据。

```javascript
// 打开数据库
const request = indexedDB.open('myDatabase', 1);

request.onupgradeneeded = (event) => {
  const db = event.target.result;
  const objectStore = db.createObjectStore('users', { keyPath: 'id' });
};

request.onsuccess = (event) => {
  const db = event.target.result;

  // 添加数据
  const transaction = db.transaction(['users'], 'readwrite');
  const objectStore = transaction.objectStore('users');
  objectStore.add({ id: 1, name: 'John' });
};
```

---

## 24. 如何合并网络请求？

**答案：**

合并多个请求为一个，减少网络开销。

```javascript
// ❌ 多次请求
fetch('/api/user/1');
fetch('/api/user/2');
fetch('/api/user/3');

// ✅ 合并请求
fetch('/api/users?ids=1,2,3');
```

---

## 25. 如何使用 GraphQL？

**答案：**

GraphQL 可以精确请求需要的数据，减少传输量。

```javascript
// 只请求需要的数据
const query = `
  query {
    user(id: 1) {
      name
      email
    }
  }
`;

fetch('/graphql', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ query })
});
```

---

## 26. 如何使用 WebSocket？

**答案：**

WebSocket 可以实现双向通信，减少轮询开销。

```javascript
// 建立 WebSocket 连接
const socket = new WebSocket('ws://localhost:8080');

socket.onopen = () => {
  console.log('Connected');
};

socket.onmessage = (event) => {
  console.log('Message:', event.data);
};

socket.send('Hello Server');
```

---

## 27. 如何使用 font-display？

**答案：**

font-display 可以控制字体的加载策略，提升用户体验。

```css
@font-face {
  font-family: 'MyFont';
  src: url('myfont.woff2') format('woff2');
  font-display: swap;  /* 立即显示后备字体 */
}
```

---

## 28. 如何预加载字体？

**答案：**

预加载字体可以减少字体加载延迟。

```html
<link rel="preload" href="/fonts/myfont.woff2" as="font" type="font/woff2" crossorigin>
```

---

## 29. 如何使用字体子集化？

**答案：**

字体子集化可以只包含需要的字符，减少文件大小。

```javascript
// 使用 fontmin
const fontmin = require('fontmin');

fontmin.src('fonts/myfont.ttf')
  .use(fontmin.glyph({
    text: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  }))
  .dest('dist/fonts')
  .run();
```

---

## 30. 如何优化移动端视口？

**答案：**

优化视口配置可以提升移动端用户体验。

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
```

---

## 31. 如何优化移动端触摸？

**答案：**

优化触摸目标大小和触摸事件，提升移动端体验。

```css
/* 优化触摸目标 */
.button {
  min-width: 48px;
  min-height: 48px;
  padding: 12px;
}

/* 禁用点击高亮 */
.button {
  -webkit-tap-highlight-color: transparent;
}

/* 优化滚动 */
.container {
  -webkit-overflow-scrolling: touch;
}
```

---

## 32. 如何减少移动端重绘和重排？

**答案：**

使用 transform 和 opacity 代替 top/left，减少重绘和重排。

```javascript
// 使用 transform 代替 top/left
element.style.transform = 'translateX(100px)';

// 使用 opacity 代替 visibility
element.style.opacity = '0';
```

---

## 33. 如何使用 passive 事件监听器？

**答案：**

passive: true 可以提示浏览器不会调用 preventDefault()，提升滚动性能。

```javascript
// passive: true 提示浏览器不会调用 preventDefault()
window.addEventListener('touchstart', handleTouch, { passive: true });
window.addEventListener('touchmove', handleTouch, { passive: true });
```

---

## 34. 如何使用语义化 HTML 优化 SEO？

**答案：**

语义化 HTML 可以帮助搜索引擎更好地理解页面内容。

```html
<header>
  <nav>
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/about">About</a></li>
    </ul>
  </nav>
</header>

<main>
  <article>
    <h1>Article Title</h1>
    <p>Article content...</p>
  </article>
</main>

<footer>
  <p>&copy; 2025 My Website</p>
</footer>
```

---

## 35. 如何使用 Meta 标签优化 SEO？

**答案：**

Meta 标签可以提供页面的元信息，帮助搜索引擎索引。

```html
<meta name="description" content="Page description">
<meta name="keywords" content="keyword1, keyword2, keyword3">

<!-- Open Graph -->
<meta property="og:title" content="Page Title">
<meta property="og:description" content="Page description">
<meta property="og:image" content="image.jpg">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Page Title">
<meta name="twitter:description" content="Page description">
```

---

## 36. 如何使用结构化数据优化 SEO？

**答案：**

结构化数据可以帮助搜索引擎更好地理解页面内容。

```html
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Article Title",
  "author": {
    "@type": "Person",
    "name": "Author Name"
  },
  "datePublished": "2025-01-08"
}
</script>
```

---

## 37. 如何使用 SSR 优化 SEO？

**答案：**

SSR（服务器端渲染）可以让搜索引擎更好地抓取页面内容。

```javascript
// 使用 Next.js
export async function getServerSideProps() {
  const data = await fetchData();
  return {
    props: { data }
  };
}

// 使用 Nuxt.js
export default {
  async asyncData() {
    const data = await fetchData();
    return { data };
  }
};
```

---

## 38. 如何使用 Performance API 监控性能？

**答案：**

Performance API 可以获取详细的性能指标。

```javascript
// 获取性能指标
const perfData = performance.getEntriesByType('navigation')[0];

const metrics = {
  dns: perfData.domainLookupEnd - perfData.domainLookupStart,
  tcp: perfData.connectEnd - perfData.connectStart,
  ttfb: perfData.responseStart - perfData.requestStart,
  download: perfData.responseEnd - perfData.responseStart,
  domLoad: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
  windowLoad: perfData.loadEventEnd - perfData.loadEventStart
};

console.log(metrics);
```

---

## 39. 如何使用 Web Vitals 监控性能？

**答案：**

Web Vitals 提供了关键的性能指标。

```javascript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

getCLS(console.log);
getFID(console.log);
getFCP(console.log);
getLCP(console.log);
getTTFB(console.log);
```

---

## 40. 如何使用 WeakMap/WeakSet 优化内存？

**答案：**

WeakMap/WeakSet 可以避免内存泄漏，当键被回收时，值也会被回收。

```javascript
// 使用 WeakMap 避免内存泄漏
const cache = new WeakMap();

function getData(element) {
  if (cache.has(element)) {
    return cache.get(element);
  }
  const data = fetchData();
  cache.set(element, data);
  return data;
}
```

---

## 总结

以上补充了前端性能优化的高频面试题，涵盖了：

1. **首屏加载优化** - 代码分割、资源预加载、关键 CSS 内联
2. **JavaScript 执行优化** - 避免阻塞、防抖节流、优化循环
3. **CSS 性能优化** - 选择器优化、CSS 变量、动画优化
4. **网络请求优化** - HTTP/2、Service Worker、请求合并
5. **图片加载优化** - 现代格式、响应式图片、懒加载
6. **字体加载优化** - font-display、预加载、子集化
7. **移动端性能优化** - 视口优化、触摸优化、减少重绘
8. **SEO 优化** - 语义化 HTML、Meta 标签、结构化数据
9. **性能监控** - Performance API、Web Vitals、Lighthouse
10. **内存使用优化** - 避免泄漏、WeakMap、对象池

这些题目补充了前端性能优化的高级技巧，能够更全面地考察候选人的性能优化能力。