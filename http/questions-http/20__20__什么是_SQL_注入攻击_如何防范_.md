## 20. 什么是 SQL 注入攻击？如何防范？

**答案：**

### SQL 注入攻击简介

SQL 注入（SQL Injection）是一种代码注入技术，攻击者通过在应用程序的输入字段中插入恶意 SQL 代码，从而操纵数据库查询。

### SQL 注入攻击原理

```javascript
// 不安全的代码（拼接 SQL）
const username = req.body.username;
const password = req.body.password;
const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`;

// 攻击者输入
username: "admin' --"
password: "anything"

// 实际执行的 SQL
SELECT * FROM users WHERE username='admin' --' AND password='anything'
// 注释掉后面的条件，直接登录 admin 账户
```

### SQL 注入攻击类型

#### 1. 经典 SQL 注入

```javascript
// 登录绕过
username: "admin' OR '1'='1"
password: "anything"

// 实际执行的 SQL
SELECT * FROM users WHERE username='admin' OR '1'='1' AND password='anything'
// '1'='1' 永远为真，绕过密码验证
```

#### 2. 盲注（Blind SQL Injection）

```javascript
// 布尔盲注
username: "admin' AND 1=1 --"  // 返回正常
username: "admin' AND 1=2 --"  // 返回错误

// 时间盲注
username: "admin' AND SLEEP(5) --"  // 延迟 5 秒
```

#### 3. Union 查询注入

```javascript
// 获取其他表的数据
username: "admin' UNION SELECT username, password FROM users --"

// 实际执行的 SQL
SELECT * FROM products WHERE name='admin' UNION SELECT username, password FROM users --'
```

#### 4. 堆叠查询注入

```javascript
// 执行多个 SQL 语句
username: "admin'; DROP TABLE users; --"

// 实际执行的 SQL
SELECT * FROM users WHERE username='admin'; DROP TABLE users; --'
```

### SQL 注入攻击危害

1. **数据泄露**：获取敏感数据（用户信息、密码等）
2. **数据篡改**：修改、删除数据库中的数据
3. **权限提升**：获取管理员权限
4. **绕过认证**：绕过登录验证
5. **拒绝服务**：删除表、导致数据库不可用

### SQL 注入防范措施

#### 1. 使用参数化查询（Prepared Statements）- 最有效

```javascript
// Node.js MySQL
const mysql = require('mysql');
const connection = mysql.createConnection({ ... });

// 不安全的拼接
const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`;

// 安全的参数化查询
const query = 'SELECT * FROM users WHERE username = ? AND password = ?';
connection.query(query, [username, password], (error, results) => {
  if (error) throw error;
  // 处理结果
});

// 使用命名参数
const query = 'SELECT * FROM users WHERE username = :username AND password = :password';
connection.query(query, { username, password }, (error, results) => {
  if (error) throw error;
});
```

```javascript
// Node.js PostgreSQL
const { Pool } = require('pg');
const pool = new Pool({ ... });

// 安全的参数化查询
const query = 'SELECT * FROM users WHERE username = $1 AND password = $2';
const result = await pool.query(query, [username, password]);
```

```javascript
// Node.js MongoDB
const { MongoClient } = require('mongodb');
const client = new MongoClient('mongodb://localhost:27017');

// 安全的查询
const result = await client.db('test').collection('users').findOne({
  username: username,
  password: password
});
```

#### 2. 使用 ORM（对象关系映射）

```javascript
// Sequelize
const { User } = require('./models');

// 安全的查询
const user = await User.findOne({
  where: {
    username: username,
    password: password
  }
});

// TypeORM
const user = await repository.findOne({
  where: {
    username: username,
    password: password
  }
});
```

#### 3. 输入验证和过滤

```javascript
// 白名单验证
function validateUsername(username) {
  // 只允许字母、数字、下划线
  const regex = /^[a-zA-Z0-9_]{3,20}$/;
  return regex.test(username);
}

// 黑名单过滤（不推荐，容易绕过）
function sanitizeInput(input) {
  return input
    .replace(/'/g, "''")
    .replace(/"/g, '""')
    .replace(/;/g, '')
    .replace(/--/g, '')
    .replace(/\/\*/g, '')
    .replace(/\*\//g, '');
}

// 使用验证库
const { body, validationResult } = require('express-validator');

app.post('/login', [
  body('username').isLength({ min: 3, max: 20 }).matches(/^[a-zA-Z0-9_]+$/),
  body('password').isLength({ min: 6 })
], (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  // 处理登录
});
```

#### 4. 最小权限原则

```javascript
// 不要使用 root 用户连接数据库
// 创建专用数据库用户，只授予必要的权限

// 创建用户
CREATE USER 'app_user'@'localhost' IDENTIFIED BY 'password';

// 只授予必要的权限
GRANT SELECT, INSERT, UPDATE ON app_db.users TO 'app_user'@'localhost';

// 不要授予 DROP、ALTER 等危险权限
```

#### 5. 错误处理

```javascript
// 不要将数据库错误直接返回给用户
app.use((err, req, res, next) => {
  console.error(err);  // 记录到日志

  // 不安全的做法
  // res.status(500).send(err.message);  // 可能泄露数据库结构

  // 安全的做法
  res.status(500).send('服务器错误，请稍后重试');
});
```

#### 6. 使用 Web 应用防火墙（WAF）

```nginx
# ModSecurity 规则
SecRule ARGS "@detectSQLi" \
  "id:1001,phase:2,deny,status:403,msg:'SQL Injection Attack Detected'"
```

### SQL 注入检测工具

1. **SQLMap**：自动化的 SQL 注入检测工具
2. **OWASP ZAP**：Web 应用安全扫描器
3. **Burp Suite**：Web 安全测试工具

### 最佳实践

1. **始终使用参数化查询**：这是最有效的防范措施
2. **使用 ORM**：ORM 自动处理参数化查询
3. **输入验证**：验证所有用户输入
4. **最小权限原则**：数据库用户只授予必要的权限
5. **错误处理**：不要将数据库错误直接返回给用户
6. **定期更新**：保持数据库和应用程序更新

---