## 19. 什么是 CSRF 攻击？如何防范？

**答案：**

### CSRF 攻击简介

CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种攻击方式，攻击者诱导用户在已认证的网站上执行非预期的操作。

### CSRF 攻击原理

```
1. 用户登录银行网站（银行网站认证成功，保存 Cookie）
   |
   v
2. 用户访问恶意网站（恶意网站不持有 Cookie）
   |
   v
3. 恶意网站向银行网站发送请求（浏览器自动携带 Cookie）
   |
   v
4. 银行网站认为请求来自用户，执行操作
```

### CSRF 攻击示例

#### 1. GET 请求攻击

```html
<!-- 恶意网站 HTML -->
<img src="http://bank.com/transfer?to=attacker&amount=1000">
```

#### 2. POST 请求攻击

```html
<!-- 恶意网站 HTML -->
<form action="http://bank.com/transfer" method="POST">
  <input type="hidden" name="to" value="attacker">
  <input type="hidden" name="amount" value="1000">
</form>
<script>document.forms[0].submit();</script>
```

#### 3. AJAX 请求攻击

```javascript
// 恶意网站 JavaScript
fetch('http://bank.com/transfer', {
  method: 'POST',
  credentials: 'include',  // 携带 Cookie
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    to: 'attacker',
    amount: 1000
  })
});
```

### CSRF 攻击条件

1. **用户已登录目标网站**：浏览器持有有效的 Cookie
2. **目标网站没有验证请求来源**：没有使用 CSRF Token 等防护措施
3. **用户访问恶意网站**：在未退出登录的情况下访问恶意网站

### CSRF 防范措施

#### 1. CSRF Token（推荐）

**原理：** 在表单中添加随机 Token，服务器验证 Token 是否正确。

```javascript
// 生成 Token
const crypto = require('crypto');
function generateCsrfToken() {
  return crypto.randomBytes(32).toString('hex');
}

// 存储 Token
app.use((req, res, next) => {
  const token = generateCsrfToken();
  req.session.csrfToken = token;
  res.locals.csrfToken = token;
  next();
});

// 渲染表单
app.get('/transfer', (req, res) => {
  res.send(`
    <form action="/transfer" method="POST">
      <input type="hidden" name="csrf_token" value="${req.session.csrfToken}">
      <input type="text" name="to">
      <input type="number" name="amount">
      <button type="submit">转账</button>
    </form>
  `);
});

// 验证 Token
app.post('/transfer', (req, res) => {
  const { csrf_token, to, amount } = req.body;

  if (csrf_token !== req.session.csrfToken) {
    return res.status(403).send('CSRF Token 验证失败');
  }

  // 执行转账操作
  res.send('转账成功');
});
```

#### 2. SameSite Cookie 属性

**原理：** 限制 Cookie 在跨站请求中发送。

```javascript
// 设置 SameSite Cookie
res.cookie('sessionId', sessionId, {
  sameSite: 'strict'  // 严格模式：不允许跨站请求携带 Cookie
});

// 或者
res.cookie('sessionId', sessionId, {
  sameSite: 'lax'  // 宽松模式：允许部分安全的跨站请求（如 GET 请求）
});
```

**SameSite 属性值：**

| 值 | 说明 |
|----|------|
| `Strict` | 完全禁止跨站请求携带 Cookie |
| `Lax` | 允许部分安全的跨站请求（GET 请求、顶级导航） |
| `None` | 允许所有跨站请求携带 Cookie（需要设置 Secure） |

#### 3. 验证 Referer 和 Origin

```javascript
// 验证 Referer
app.use((req, res, next) => {
  const referer = req.headers.referer;
  const origin = req.headers.origin;

  // 验证 Referer 是否来自本站
  if (referer && !referer.startsWith('https://yourdomain.com')) {
    return res.status(403).send('非法请求来源');
  }

  // 验证 Origin
  if (origin && origin !== 'https://yourdomain.com') {
    return res.status(403).send('非法请求来源');
  }

  next();
});
```

#### 4. 自定义 Header

```javascript
// 前端：在请求中添加自定义 Header
fetch('/api/transfer', {
  method: 'POST',
  headers: {
    'X-Requested-With': 'XMLHttpRequest',
    'Content-Type': 'application/json'
  },
  credentials: 'include',
  body: JSON.stringify({ to: 'attacker', amount: 1000 })
});

// 后端：验证自定义 Header
app.use((req, res, next) => {
  if (req.method === 'POST' && req.headers['x-requested-with'] !== 'XMLHttpRequest') {
    return res.status(403).send('非法请求');
  }
  next();
});
```

#### 5. 双重 Cookie 验证

```javascript
// 生成 Token 并存储在 Cookie 中
app.use((req, res, next) => {
  const token = generateCsrfToken();
  res.cookie('csrf_token', token, { httpOnly: false });
  req.session.csrfToken = token;
  next();
});

// 前端：从 Cookie 中读取 Token 并添加到请求中
const csrfToken = getCookie('csrf_token');
fetch('/api/transfer', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': csrfToken
  },
  body: JSON.stringify({ to: 'attacker', amount: 1000 })
});

// 后端：验证 Token
app.post('/api/transfer', (req, res) => {
  const csrfToken = req.headers['x-csrf-token'];
  if (csrfToken !== req.session.csrfToken) {
    return res.status(403).send('CSRF Token 验证失败');
  }
  // 执行操作
});
```

### CSRF vs XSS

| 特性 | CSRF | XSS |
|------|------|-----|
| 攻击方式 | 伪造用户请求 | 注入恶意脚本 |
| 执行位置 | 服务器 | 用户浏览器 |
| 需要 Cookie | 是 | 否 |
| 防护重点 | 验证请求来源 | 输入验证和输出编码 |

### 最佳实践

1. **使用 CSRF Token**：对于所有状态改变的请求
2. **设置 SameSite Cookie**：限制跨站请求携带 Cookie
3. **使用 HTTPS**：防止中间人攻击
4. **验证 Referer/Origin**：验证请求来源
5. **使用短生命周期的 Token**：定期更新 Token

---