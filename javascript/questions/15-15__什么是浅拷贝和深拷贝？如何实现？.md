# 15. 什么是浅拷贝和深拷贝？如何实现？

**答案：**

**浅拷贝：**

```javascript
// 1. Object.assign()
const obj = { a: 1, b: { c: 2 } };
const shallow = Object.assign({}, obj);
shallow.b.c = 3;
console.log(obj.b.c); // 3 (受影响)

// 2. 展开运算符
const shallow2 = { ...obj };
shallow2.b.c = 4;
console.log(obj.b.c); // 4 (受影响)

// 3. Array.slice()
const arr = [{ a: 1 }, { b: 2 }];
const shallowArr = arr.slice();
shallowArr[0].a = 10;
console.log(arr[0].a); // 10 (受影响)
```

**深拷贝：**

```javascript
// 1. JSON.parse(JSON.stringify())
const obj = { a: 1, b: { c: 2 } };
const deep = JSON.parse(JSON.stringify(obj));
deep.b.c = 3;
console.log(obj.b.c); // 2 (不受影响)

// 限制：
// - 无法拷贝函数
// - 无法拷贝 undefined
// - 无法拷贝 Symbol
// - 会丢失原型链

// 2. 手动实现（支持循环引用）
function deepClone(obj, map = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  if (map.has(obj)) {
    return map.get(obj);
  }
  
  const cloned = Array.isArray(obj) ? [] : {};
  map.set(obj, cloned);
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone(obj[key], map);
    }
  }
  
  return cloned;
}

// 3. 使用 structuredClone (ES2022)
const obj = { a: 1, b: { c: 2 } };
const deep = structuredClone(obj);

// 4. 使用第三方库 (lodash)
const _ = require('lodash');
const deep = _.cloneDeep(obj);
```

**场景题：**

```javascript
// 场景 1：不可变状态管理
const state = {
  user: { name: 'Alice', age: 25 },
  posts: [{ title: 'Post 1' }]
};

// 浅拷贝（推荐用于更新嵌套对象）
const newState = {
  ...state,
  user: {
    ...state.user,
    age: 26
  }
};

// 场景 2：撤销/重做
const history = [];
let currentState = { count: 0 };

function saveState() {
  history.push(deepClone(currentState));
}

function undo() {
  currentState = history.pop();
}

// 场景 3：表单重置
const formData = {
  name: '',
  email: '',
  address: {
    city: '',
    country: ''
  }
};

const initialData = deepClone(formData);

function resetForm() {
  Object.assign(formData, deepClone(initialData));
}
```

---