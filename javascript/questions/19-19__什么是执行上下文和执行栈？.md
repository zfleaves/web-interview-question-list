# 19. 什么是执行上下文和执行栈？

**答案：**

**执行上下文类型：**

```javascript
// 1. 全局执行上下文
var globalVar = 'global';

function fn() {
  console.log(globalVar);
}

fn(); // "global"

// 2. 函数执行上下文
function outer() {
  var outerVar = 'outer';
  
  function inner() {
    var innerVar = 'inner';
    console.log(outerVar, innerVar);
  }
  
  inner();
}

outer(); // "outer" "inner"

// 3. eval 执行上下文（不推荐）
eval('var x = 10;');
console.log(x); // 10
```

**执行上下文创建阶段：**

```javascript
// 创建阶段
function fn(a, b) {
  var c = 10;
}

// 等价于
function fn(a, b) {
  var c; // 变量声明提升
  var a; // 参数声明
  var b; // 参数声明
  
  a = arguments[0]; // 参数赋值
  b = arguments[1]; // 参数赋值
  
  // 函数声明提升
  // var c = 10; // 变量赋值不提升
}
```

**执行栈：**

```javascript
function first() {
  console.log('First start');
  second();
  console.log('First end');
}

function second() {
  console.log('Second start');
  third();
  console.log('Second end');
}

function third() {
  console.log('Third');
}

first();

// 执行栈变化：
// 1. 全局上下文入栈
// 2. first 入栈 -> "First start"
// 3. second 入栈 -> "Second start"
// 4. third 入栈 -> "Third"
// 5. third 出栈
// 6. -> "Second end"
// 7. second 出栈
// 8. -> "First end"
// 9. first 出栈
// 10. 全局上下文出栈
```

**场景题：**

```javascript
// 场景 1：变量提升
console.log(a); // undefined
var a = 10;

console.log(b); // ReferenceError
let b = 20;

// 场景 2：函数提升
console.log(fn1); // [Function: fn1]
console.log(fn2); // undefined

function fn1() {
  console.log('fn1');
}

var fn2 = function() {
  console.log('fn2');
};

// 场景 3：作用域链
var x = 'global';

function fn() {
  var x = 'local';
  
  function inner() {
    console.log(x); // "local"
  }
  
  inner();
}

fn();

// 场景 4：闭包与执行上下文
function createCounter() {
  let count = 0;
  
  return function() {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

---