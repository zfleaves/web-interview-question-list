# 5. 什么是原型链？如何理解原型继承？

**答案：**

**原型概念：**

每个 JavaScript 对象都有一个内部属性 `[[Prototype]]`（可以通过 `__proto__` 访问），指向它的原型对象。

```javascript
// 1. 原型链
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
};

const person = new Person('Alice');

// 原型链
person.__proto__ === Person.prototype; // true
Person.prototype.__proto__ === Object.prototype; // true
Object.prototype.__proto__ === null; // true

// 2. 属性查找
person.sayHello(); // 在 Person.prototype 中找到
person.toString(); // 在 Object.prototype 中找到
person.nonExistentMethod(); // 沿着原型链找不到，报错
```

**原型继承：**

```javascript
// 1. 原型链继承
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  console.log(`${this.name} is eating`);
};

function Dog(name, breed) {
  Animal.call(this, name); // 调用父类构造函数
  this.breed = breed;
}

// 设置原型链
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  console.log(`${this.name} is barking`);
};

const dog = new Dog('Buddy', 'Golden Retriever');
dog.eat(); // "Buddy is eating"
dog.bark(); // "Buddy is barking"

// 2. ES6 类继承
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  eat() {
    console.log(`${this.name} is eating`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }
  
  bark() {
    console.log(`${this.name} is barking`);
  }
}

const dog = new Dog('Buddy', 'Golden Retriever');
dog.eat(); // "Buddy is eating"
dog.bark(); // "Buddy is barking"
```

**原型链图解：**

```
person
  └── __proto__ → Person.prototype
                    └── __proto__ → Object.prototype
                                      └── __proto__ → null
```

**场景题：**

```javascript
// 场景 1：实现继承
function Shape(color) {
  this.color = color;
}

Shape.prototype.getArea = function() {
  return 0;
};

function Rectangle(color, width, height) {
  Shape.call(this, color);
  this.width = width;
  this.height = height;
}

Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;

Rectangle.prototype.getArea = function() {
  return this.width * this.height;
};

const rect = new Rectangle('red', 10, 5);
console.log(rect.getArea()); // 50
console.log(rect.color); // "red"

// 场景 2：方法扩展
Array.prototype.sum = function() {
  return this.reduce((sum, num) => sum + num, 0);
};

console.log([1, 2, 3, 4, 5].sum()); // 15

// 场景 3：检查原型链
function isPrototypeOf(obj, prototype) {
  let proto = Object.getPrototypeOf(obj);
  
  while (proto) {
    if (proto === prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  
  return false;
}

console.log(isPrototypeOf([], Array.prototype)); // true
console.log(isPrototypeOf([], Object.prototype)); // true

// 场景 4：实现 instanceof
function myInstanceof(left, right) {
  let prototype = right.prototype;
  left = left.__proto__;
  
  while (true) {
    if (left === null || left === undefined) {
      return false;
    }
    if (left === prototype) {
      return true;
    }
    left = left.__proto__;
  }
}

console.log(myInstanceof([], Array)); // true
console.log(myInstanceof([], Object)); // true
```

---

## ES6+ 新特性