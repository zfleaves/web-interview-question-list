# 4. 什么是闭包？闭包的使用场景有哪些？

**答案：**

**闭包定义：**

闭包是指函数能够访问其词法作用域外的变量，即使该函数在其词法作用域之外执行。

```javascript
// 基本示例
function outer() {
  const outerVar = 'I am from outer';
  
  function inner() {
    console.log(outerVar); // 访问外部变量
  }
  
  return inner;
}

const closure = outer();
closure(); // "I am from outer"
```

**闭包的特点：**

```javascript
// 1. 函数嵌套函数
function createCounter() {
  let count = 0;
  
  return {
    increment: function() {
      count++;
      console.log(count);
    },
    decrement: function() {
      count--;
      console.log(count);
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();
counter.increment(); // 1
counter.increment(); // 2
counter.decrement(); // 1
console.log(counter.getCount()); // 1

// 2. 外部函数返回内部函数
function createGreeter(greeting) {
  return function(name) {
    console.log(`${greeting}, ${name}!`);
  };
}

const greetHello = createGreeter('Hello');
const greetHi = createGreeter('Hi');

greetHello('Alice'); // "Hello, Alice!"
greetHi('Bob'); // "Hi, Bob!"

// 3. 内部函数引用外部函数的变量
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

**使用场景：**

```javascript
// 1. 数据私有化（模块模式）
const module = (function() {
  let privateVar = 0;
  
  return {
    getPrivateVar: function() {
      return privateVar;
    },
    setPrivateVar: function(value) {
      privateVar = value;
    },
    increment: function() {
      privateVar++;
    }
  };
})();

console.log(module.getPrivateVar()); // 0
module.setPrivateVar(10);
console.log(module.getPrivateVar()); // 10
module.increment();
console.log(module.getPrivateVar()); // 11

// 2. 函数柯里化
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return function(...moreArgs) {
      return curried.apply(this, args.concat(moreArgs));
    };
  };
}

function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6

// 3. 防抖和节流
function debounce(func, delay) {
  let timeoutId;
  
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

function throttle(func, delay) {
  let lastCall = 0;
  
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      func.apply(this, args);
      lastCall = now;
    }
  };
}

// 使用
const debouncedSearch = debounce(function(query) {
  console.log('Searching for:', query);
}, 300);

const throttledScroll = throttle(function() {
  console.log('Scrolling...');
}, 100);

// 4. 单例模式
function createSingleton() {
  let instance;
  
  return {
    getInstance: function() {
      if (!instance) {
        instance = {
          data: 'Singleton data'
        };
      }
      return instance;
    }
  };
}

const singleton = createSingleton();
const instance1 = singleton.getInstance();
const instance2 = singleton.getInstance();

console.log(instance1 === instance2); // true

// 5. 事件处理器
function setupButton(buttonId) {
  const button = document.getElementById(buttonId);
  let clickCount = 0;
  
  button.addEventListener('click', function() {
    clickCount++;
    console.log(`Button clicked ${clickCount} times`);
  });
}

// 6. 异步操作
function fetchData(url) {
  let cache = null;
  
  return async function() {
    if (cache) {
      return cache;
    }
    
    const response = await fetch(url);
    cache = await response.json();
    return cache;
  };
}

const getUserData = fetchData('/api/user');
const data1 = await getUserData(); // 发起请求
const data2 = await getUserData(); // 使用缓存
```

**场景题：**

```javascript
// 场景 1：实现私有变量
function Person(name) {
  let _name = name; // 私有变量
  
  return {
    getName: function() {
      return _name;
    },
    setName: function(newName) {
      _name = newName;
    }
  };
}

const person = Person('Alice');
console.log(person.getName()); // "Alice"
person.setName('Bob');
console.log(person.getName()); // "Bob"
console.log(person._name); // undefined (无法直接访问)

// 场景 2：状态管理
function createStore(reducer, initialState) {
  let state = initialState;
  const listeners = [];
  
  return {
    getState: function() {
      return state;
    },
    dispatch: function(action) {
      state = reducer(state, action);
      listeners.forEach(listener => listener());
    },
    subscribe: function(listener) {
      listeners.push(listener);
      return function() {
        const index = listeners.indexOf(listener);
        listeners.splice(index, 1);
      };
    }
  };
}

// 使用
const store = createStore(function(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    default:
      return state;
  }
}, { count: 0 });

store.subscribe(function() {
  console.log('State changed:', store.getState());
});

store.dispatch({ type: 'INCREMENT' }); // State changed: { count: 1 }

// 场景 3：函数工厂
function createValidator(rules) {
  return function(value) {
    const errors = [];
    
    for (const rule of rules) {
      if (!rule.test(value)) {
        errors.push(rule.message);
      }
    }
    
    return errors.length === 0 ? null : errors;
  };
}

const emailValidator = createValidator([
  { test: v => v.includes('@'), message: 'Must contain @' },
  { test: v => v.includes('.'), message: 'Must contain .' }
]);

console.log(emailValidator('test@example.com')); // null
console.log(emailValidator('invalid')); // ['Must contain @', 'Must contain .']
```

---