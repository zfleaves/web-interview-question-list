# 20. 什么是内存泄漏？常见的内存泄漏场景有哪些？

**答案：**

**内存泄漏定义：**

内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

**常见内存泄漏场景：**

```javascript
// 1. 意外的全局变量
function fn() {
  globalVar = 'global'; // 意外创建全局变量
}

// 2. 未清理的定时器
function startTimer() {
  setInterval(() => {
    console.log('tick');
  }, 1000);
  // 没有清除定时器，导致内存泄漏
}

// ✅ 正确做法
function startTimer() {
  const timer = setInterval(() => {
    console.log('tick');
  }, 1000);
  
  return function cleanup() {
    clearInterval(timer);
  };
}

// 3. 闭包引用
function createClosure() {
  const largeData = new Array(1000000).fill('data');
  
  return function() {
    // 闭包引用了 largeData，导致无法释放
    console.log('closure');
  };
}

// ✅ 正确做法
function createClosure() {
  const largeData = new Array(1000000).fill('data');
  
  return function() {
    // 只使用需要的数据
    console.log('closure');
  };
  
  // largeData 在函数执行完后可以被回收
}

// 4. DOM 引用
const elements = [];

function addElement() {
  const div = document.createElement('div');
  elements.push(div); // 保存 DOM 引用
  document.body.appendChild(div);
}

// ✅ 正确做法
function addElement() {
  const div = document.createElement('div');
  document.body.appendChild(div);
  
  // 不保存引用，让垃圾回收器回收
}

// 5. 事件监听器未移除
function addListener() {
  const button = document.getElementById('button');
  button.addEventListener('click', function() {
    console.log('clicked');
  });
  // 没有移除监听器
}

// ✅ 正确做法
function addListener() {
  const button = document.getElementById('button');
  const handler = function() {
    console.log('clicked');
  };
  
  button.addEventListener('click', handler);
  
  return function cleanup() {
    button.removeEventListener('click', handler);
  };
}

// 6. Map 和 Set 的强引用
const map = new Map();
const element = document.getElementById('element');
map.set(element, 'data'); // 强引用

// ✅ 正确做法：使用 WeakMap
const weakMap = new WeakMap();
weakMap.set(element, 'data'); // 弱引用
```

**场景题：**

```javascript
// 场景 1：单例模式的内存泄漏
class Singleton {
  static instance = null;
  
  constructor() {
    if (Singleton.instance) {
      return Singleton.instance;
    }
    
    this.data = new Array(1000000).fill('data');
    Singleton.instance = this;
  }
}

const instance1 = new Singleton();
const instance2 = new Singleton();
console.log(instance1 === instance2); // true

// 场景 2：事件委托避免内存泄漏
// ❌ 错误：为每个元素添加监听器
const items = document.querySelectorAll('.item');
items.forEach(item => {
  item.addEventListener('click', function() {
    console.log('clicked');
  });
});

// ✅ 正确：使用事件委托
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('item')) {
    console.log('clicked');
  }
});

// 场景 3：清理闭包
function createComponent() {
  const data = new Array(1000000).fill('data');
  let timer = null;
  
  function update() {
    console.log('update');
  }
  
  function mount() {
    timer = setInterval(update, 1000);
  }
  
  function unmount() {
    clearInterval(timer);
    // 清除引用
    data.length = 0;
  }
  
  return { mount, unmount };
}

const component = createComponent();
component.mount();
// 使用完成后
component.unmount();
```

---

## 总结

以上涵盖了 JavaScript 面试中最常问的问题，包括：

1. **JavaScript 基础**（数据类型、null/undefined、==/===、闭包、原型链）
2. **ES6+ 新特性**（let/const、箭头函数）
3. **异步编程**（Promise、async/await、事件循环）
4. **场景题**（深拷贝、防抖节流、EventEmitter）

这些题目覆盖了 JavaScript 的核心概念和实际应用场景，能够全面考察候选人的 JavaScript 知识深度和广度。