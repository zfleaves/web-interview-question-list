# 7. 箭头函数和普通函数的区别是什么？

**答案：**

**区别：**

```javascript
// 1. this 指向
const obj = {
  name: 'Alice',
  
  // 普通函数：this 指向调用者
  regular: function() {
    console.log(this.name);
  },
  
  // 箭头函数：this 继承外层作用域
  arrow: () => {
    console.log(this.name);
  }
};

obj.regular(); // "Alice"
obj.arrow(); // undefined (this 指向全局对象)

// 2. 不能作为构造函数
const Person = function(name) {
  this.name = name;
};

const person = new Person('Alice'); // ✅ 可以

const ArrowPerson = (name) => {
  this.name = name;
};

const arrowPerson = new ArrowPerson('Alice'); // ❌ TypeError

// 3. 没有 arguments 对象
function regular() {
  console.log(arguments);
}

regular(1, 2, 3); // [1, 2, 3]

const arrow = () => {
  console.log(arguments);
};

arrow(1, 2, 3); // ReferenceError

// 4. 没有 prototype 属性
function regular() {}
console.log(regular.prototype); // {}

const arrow = () => {};
console.log(arrow.prototype); // undefined

// 5. 不能使用 yield（不能作为生成器函数）
function* generator() {
  yield 1;
}

const* arrowGenerator = () => {
  yield 1; // ❌ SyntaxError
};
```

**使用场景：**

```javascript
// 1. 回调函数
// ❌ 普通函数需要 bind
const obj = {
  name: 'Alice',
  greet: function() {
    setTimeout(function() {
      console.log(`Hello, ${this.name}`); // undefined
    }, 100);
  }
};

// ✅ 使用箭头函数
const obj = {
  name: 'Alice',
  greet: function() {
    setTimeout(() => {
      console.log(`Hello, ${this.name}`); // "Alice"
    }, 100);
  }
};

// 2. 数组方法
const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

const filtered = numbers.filter(num => num % 2 === 0);
console.log(filtered); // [2, 4]

const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // 15

// 3. 简化函数表达式
// ❌ 普通
const add = function(a, b) {
  return a + b;
};

// ✅ 箭头函数
const add = (a, b) => a + b;

// 4. 对象方法（谨慎使用）
const obj = {
  name: 'Alice',
  
  // ❌ 不推荐：this 指向全局
  greet: () => {
    console.log(`Hello, ${this.name}`);
  },
  
  // ✅ 推荐：使用方法简写
  greet() {
    console.log(`Hello, ${this.name}`);
  }
};
```

**场景题：**

```javascript
// 场景 1：事件处理器
class Button {
  constructor() {
    this.count = 0;
    this.button = document.createElement('button');
    this.button.textContent = 'Click me';
    
    // ❌ 普通函数需要 bind
    this.button.addEventListener('click', function() {
      this.count++; // this 指向 button 元素
      console.log(this.count);
    }.bind(this));
    
    // ✅ 使用箭头函数
    this.button.addEventListener('click', () => {
      this.count++; // this 指向 Button 实例
      console.log(this.count);
    });
  }
}

// 场景 2：Promise 链
fetch('/api/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });

// 场景 3：高阶函数
function createMultiplier(factor) {
  return num => num * factor;
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

---

## 异步编程