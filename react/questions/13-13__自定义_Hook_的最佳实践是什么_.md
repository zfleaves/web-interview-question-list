# 13. 自定义 Hook 的最佳实践是什么？

**答案：**

自定义 Hook 是复用状态逻辑的函数，必须以 "use" 开头。

**基本示例：**

```javascript
// ✅ 自定义 Hook：复用窗口大小逻辑
function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return size;
}

// 使用
function Component() {
  const { width, height } = useWindowSize();
  return <div>{width} x {height}</div>;
}
```

**最佳实践：**

1. **单一职责原则：**
```javascript
// ❌ 不好的做法：一个 Hook 做太多事情
function useUserAndPosts() {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(false);
  // ... 混合了用户和帖子的逻辑
}

// ✅ 好的做法：拆分成多个 Hook
function useUser() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    setLoading(true);
    fetchUser().then(setUser).finally(() => setLoading(false));
  }, []);
  
  return { user, loading };
}

function usePosts(userId) {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    if (userId) {
      setLoading(true);
      fetchPosts(userId).then(setPosts).finally(() => setLoading(false));
    }
  }, [userId]);
  
  return { posts, loading };
}
```

2. **参数和返回值设计：**
```javascript
// ✅ 清晰的参数和返回值
function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    setLoading(true);
    fetch(url, options)
      .then(res => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [url, JSON.stringify(options)]);

  return { data, error, loading };
}

// 使用
function Component() {
  const { data, loading, error } = useFetch('/api/users');
  
  if (loading) return <div>加载中...</div>;
  if (error) return <div>错误：{error.message}</div>;
  return <div>{JSON.stringify(data)}</div>;
}
```

3. **清理副作用：**
```javascript
// ✅ 正确清理副作用
function useWebSocket(url) {
  const [socket, setSocket] = useState(null);
  const [message, setMessage] = useState(null);

  useEffect(() => {
    const ws = new WebSocket(url);
    
    ws.onmessage = (event) => {
      setMessage(JSON.parse(event.data));
    };

    setSocket(ws);

    return () => {
      ws.close();
    };
  }, [url]);

  return { socket, message };
}
```

4. **组合多个 Hook：**
```javascript
// ✅ 组合使用其他 Hook
function useAuth() {
  const [user, setUser] = useState(null);
  const [token, setToken] = useState(null);
  
  const login = useCallback(async (credentials) => {
    const response = await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify(credentials),
    });
    const data = await response.json();
    setToken(data.token);
    setUser(data.user);
  }, []);

  const logout = useCallback(() => {
    setToken(null);
    setUser(null);
  }, []);

  return { user, token, login, logout };
}

function useAuthenticatedFetch() {
  const { token } = useAuth();

  return useCallback(async (url, options = {}) => {
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${token}`,
      },
    });
    return response.json();
  }, [token]);
}
```

5. **错误处理：**
```javascript
// ✅ 完善的错误处理
function useAsync(asyncFunction, immediate = true) {
  const [status, setStatus] = useState('idle');
  const [value, setValue] = useState(null);
  const [error, setError] = useState(null);

  const execute = useCallback(async (...args) => {
    setStatus('pending');
    setValue(null);
    setError(null);

    try {
      const response = await asyncFunction(...args);
      setValue(response);
      setStatus('success');
    } catch (error) {
      setError(error);
      setStatus('error');
    }
  }, [asyncFunction]);

  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);

  return { execute, status, value, error };
}
```
