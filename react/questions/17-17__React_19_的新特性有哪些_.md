# 17. React 19 的新特性有哪些？

**答案：**

React 19 引入了多个简化开发体验的新特性。

**1. 简化的表单处理：**

```javascript
// React 18：需要手动处理表单提交
function Form() {
  const [formData, setFormData] = useState({ name: '', email: '' });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errors, setErrors] = useState({});

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    try {
      await submitForm(formData);
      alert('提交成功');
    } catch (error) {
      setErrors(error.response.data);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={formData.name}
        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
      />
      {errors.name && <span>{errors.name}</span>}
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? '提交中...' : '提交'}
      </button>
    </form>
  );
}

// React 19：使用 actions
function Form() {
  const [errors, setErrors] = useState({});

  return (
    <form
      action={async (formData) => {
        try {
          await submitForm(formData);
          alert('提交成功');
        } catch (error) {
          setErrors(error.response.data);
        }
      }}
    >
      <input name="name" />
      {errors.name && <span>{errors.name}</span>}
      <button type="submit">提交</button>
    </form>
  );
}
```

**2. useActionState Hook：**

```javascript
import { useActionState } from 'react';

function Form() {
  const [state, formAction, isPending] = useActionState(
    async (prevState, formData) => {
      const errors = await validate(formData);
      if (Object.keys(errors).length > 0) {
        return { errors };
      }
      await submitForm(formData);
      return { success: true };
    },
    { errors: {} }
  );

  return (
    <form action={formAction}>
      <input name="name" />
      {state.errors.name && <span>{state.errors.name}</span>}
      <button type="submit" disabled={isPending}>
        {isPending ? '提交中...' : '提交'}
      </button>
    </form>
  );
}
```

**3. useOptimistic Hook：**

```javascript
import { useOptimistic } from 'react';

function TodoList() {
  const [todos, setTodos] = useState([]);
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos,
    (state, newTodo) => [...state, { ...newTodo, optimistic: true }]
  );

  const addTodo = async (text) => {
    addOptimisticTodo({ id: Date.now(), text, completed: false });
    const newTodo = await api.addTodo(text);
    setTodos([...todos, newTodo]);
  };

  return (
    <ul>
      {optimisticTodos.map(todo => (
        <li key={todo.id} className={todo.optimistic ? 'opacity-50' : ''}>
          {todo.text}
        </li>
      ))}
    </ul>
  );
}
```

**4. use Hook：**

```javascript
import { use } from 'react';

async function fetchData() {
  const res = await fetch('/api/data');
  return res.json();
}

function Component() {
  // 在组件中直接使用 Promise
  const data = use(fetchData());
  
  return <div>{data.name}</div>;
}

// 配合 Suspense
function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Component />
    </Suspense>
  );
}
```

**5. Server Components 改进：**

```javascript
// 服务器组件（默认）
async function UserProfile({ userId }) {
  const user = await db.user.findUnique({ where: { id: userId } });
  const posts = await db.post.findMany({ where: { userId } });

  return (
    <div>
      <h1>{user.name}</h1>
      <PostList posts={posts} />
    </div>
  );
}

// 客户端组件
'use client';

function PostList({ posts }) {
  const [filter, setFilter] = useState('');

  const filteredPosts = posts.filter(post =>
    post.title.toLowerCase().includes(filter.toLowerCase())
  );

  return (
    <div>
      <input
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        placeholder="搜索帖子"
      />
      {filteredPosts.map(post => (
        <Post key={post.id} post={post} />
      ))}
    </div>
  );
}
```

**6. 改进的 ref 支持：**

```javascript
// 函数组件现在可以直接接收 ref
function Input({ ref, ...props }) {
  return <input ref={ref} {...props} />;
}

// 使用
function App() {
  const inputRef = useRef(null);
  
  return <Input ref={inputRef} />;
}

// 或者使用 forwardRef（仍然支持）
const Input = forwardRef(function Input(props, ref) {
  return <input ref={ref} {...props} />;
});
```
