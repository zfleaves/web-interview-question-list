# Vue3 å“åº”å¼ç³»ç»Ÿå®Œæ•´æµç¨‹

## æ ¸å¿ƒæ¦‚å¿µ

Vue3 çš„å“åº”å¼ç³»ç»Ÿæ˜¯ä¸€ä¸ªå®Œæ•´çš„é—­ç¯ï¼Œä»ä¾èµ–æ”¶é›†åˆ°è§†å›¾æ›´æ–°ï¼Œæ¶‰åŠå¤šä¸ªæ ¸å¿ƒæ¨¡å—çš„ååŒå·¥ä½œã€‚

**å®Œæ•´æµç¨‹ï¼š**
1. **ä¾èµ–æ”¶é›†**ï¼šåœ¨ effect æ‰§è¡Œæ—¶ï¼Œé€šè¿‡ track æ”¶é›†ä¾èµ–
2. **ä¾èµ–è¿½è¸ª**ï¼šå»ºç«‹å“åº”å¼æ•°æ®ä¸ effect çš„æ˜ å°„å…³ç³»
3. **è§¦å‘æ›´æ–°**ï¼šæ•°æ®å˜åŒ–æ—¶ï¼Œé€šè¿‡ trigger é€šçŸ¥æ‰€æœ‰ä¾èµ–
4. **è°ƒåº¦æ‰§è¡Œ**ï¼šé€šè¿‡è°ƒåº¦å™¨å®‰æ’ effect çš„æ‰§è¡Œæ—¶æœº
5. **è§†å›¾æ›´æ–°**ï¼šeffect æ‰§è¡Œåï¼Œè§¦å‘ç»„ä»¶é‡æ–°æ¸²æŸ“

## 1. ä¾èµ–æ”¶é›†é˜¶æ®µ

### 1.1 effect çš„åˆ›å»ºä¸æ‰§è¡Œ

```javascript
// effect å‡½æ•° - åˆ›å»ºå‰¯ä½œç”¨
function effect(fn, options = {}) {
  const _effect = new ReactiveEffect(fn, options.scheduler);
  
  // å»¶è¿Ÿæ‰§è¡Œ
  if (!options.lazy) {
    _effect.run();
  }
  
  // è¿”å› runnerï¼Œå¯ä»¥æ‰‹åŠ¨æ‰§è¡Œ
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}

// ReactiveEffect ç±»
class ReactiveEffect {
  constructor(fn, scheduler = null) {
    this.fn = fn; // å‰¯ä½œç”¨å‡½æ•°
    this.scheduler = scheduler; // è°ƒåº¦å™¨
    this.active = true; // æ˜¯å¦æ¿€æ´»
    this.deps = []; // ä¾èµ–çš„ dep é›†åˆ
    this.parent = null; // çˆ¶ effectï¼ˆæ”¯æŒåµŒå¥—ï¼‰
  }
  
  // æ‰§è¡Œ effect
  run() {
    if (!this.active) {
      return this.fn();
    }
    
    // å¤„ç†åµŒå¥— effect
    let parent = activeEffect;
    try {
      // è®¾ç½®å½“å‰ effect
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      
      // æ‰§è¡Œå‰¯ä½œç”¨å‡½æ•°
      return this.fn();
    } finally {
      // æ¢å¤çˆ¶ effect
      activeEffect = this.parent;
      shouldTrack = false;
    }
  }
  
  // åœæ­¢ effect
  stop() {
    if (this.active) {
      cleanupEffect(this);
      this.active = false;
    }
  }
}
```

### 1.2 track - ä¾èµ–æ”¶é›†

```javascript
// å…¨å±€å˜é‡
let activeEffect = null; // å½“å‰æ­£åœ¨æ‰§è¡Œçš„ effect
let shouldTrack = true; // æ˜¯å¦åº”è¯¥è¿½è¸ª
const targetMap = new WeakMap(); // ç›®æ ‡å¯¹è±¡åˆ°ä¾èµ–çš„æ˜ å°„

// track - ä¾èµ–æ”¶é›†
function track(target, type, key) {
  // å¦‚æœä¸åº”è¯¥è¿½è¸ªæˆ–æ²¡æœ‰ activeEffectï¼Œç›´æ¥è¿”å›
  if (!shouldTrack || activeEffect === null) {
    return;
  }
  
  // è·å– target çš„ä¾èµ–æ˜ å°„
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  
  // è·å– key çš„ä¾èµ–é›†åˆ
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = createDep()));
  }
  
  // æ”¶é›†ä¾èµ–
  trackEffects(dep);
}

// trackEffects - æ”¶é›†ä¾èµ–åˆ° effect
function trackEffects(dep) {
  let shouldTrack = false;
  
  // ä½¿ç”¨ä½è¿ç®—ä¼˜åŒ–æ€§èƒ½
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack = !wasTracked(dep);
    }
  } else {
    shouldTrack = !dep.has(activeEffect);
  }
  
  if (shouldTrack) {
    dep.add(activeEffect); // å°† effect æ·»åŠ åˆ° dep
    activeEffect.deps.push(dep); // å°† dep æ·»åŠ åˆ° effect
  }
}

// createDep - åˆ›å»ºä¾èµ–é›†åˆ
function createDep(effects) {
  const dep = new Set(effects);
  dep.w = 0; // ç”¨äºä½è¿ç®—
  dep.n = 0; // ç”¨äºä½è¿ç®—
  return dep;
}
```

**ä¾èµ–æ”¶é›†çš„æ—¶æœºï¼š**
```javascript
// ç»„ä»¶æ¸²æŸ“æ—¶
function mountComponent(vnode, container) {
  const instance = vnode.component;
  
  // åˆ›å»ºæ¸²æŸ“ effect
  instance.effect = new ReactiveEffect(componentUpdateFn, () => {
    queueJob(instance.update);
  });
  
  // æ‰§è¡Œ effectï¼Œè§¦å‘ä¾èµ–æ”¶é›†
  instance.effect.run();
}

// componentUpdateFn - ç»„ä»¶æ›´æ–°å‡½æ•°
function componentUpdateFn() {
  const instance = currentInstance;
  
  // è·å– props
  const { props } = instance;
  
  // æ‰§è¡Œ setup
  if (!instance.setupState) {
    const setupContext = createSetupContext(instance);
    instance.setupState = callSetup(instance, props, setupContext);
  }
  
  // æ‰§è¡Œ render
  const subTree = instance.render.call(instance.proxy);
  
  // æ›´æ–° DOM
  patch(instance.subTree, subTree, container);
  instance.subTree = subTree;
}
```

## 2. ä¾èµ–è¿½è¸ªé˜¶æ®µ

### 2.1 å“åº”å¼æ•°æ®çš„ getter

```javascript
// reactive çš„ get æ‹¦æˆªå™¨
function get(target, key, receiver) {
  const isReadonly = isReadonlyMap.get(target);
  const isShallow = isShallowMap.get(target);
  
  // å¤„ç†å†…éƒ¨å±æ€§
  if (key === ReactiveFlags.IS_REACTIVE) {
    return !isReadonly;
  }
  if (key === ReactiveFlags.IS_READONLY) {
    return isReadonly;
  }
  if (key === ReactiveFlags.RAW) {
    return target;
  }
  
  // è·å–å€¼
  const targetIsArray = isArray(target);
  
  // æ•°ç»„æ–¹æ³•ç‰¹æ®Šå¤„ç†
  if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
    return Reflect.get(arrayInstrumentations, key, receiver);
  }
  
  const res = Reflect.get(target, key, receiver);
  
  // å¦‚æœ key æ˜¯ symbolï¼Œç›´æ¥è¿”å›
  if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
    return res;
  }
  
  // éåªè¯»ï¼Œæ”¶é›†ä¾èµ–
  if (!isReadonly) {
    track(target, TrackOpTypes.GET, key); // ğŸ”´ ä¾èµ–æ”¶é›†
  }
  
  // å¦‚æœæ˜¯æµ…å“åº”å¼ï¼Œç›´æ¥è¿”å›
  if (isShallow) {
    return res;
  }
  
  // å¦‚æœæ˜¯ refï¼Œè‡ªåŠ¨è§£åŒ…
  if (isRef(res)) {
    if (targetIsArray && isIntegerKey(key)) {
      return res;
    } else {
      return res.value;
    }
  }
  
  // å¦‚æœæ˜¯å¯¹è±¡ï¼Œé€’å½’å“åº”å¼åŒ–
  if (isObject(res)) {
    return isReadonly ? readonly(res) : reactive(res);
  }
  
  return res;
}
```

### 2.2 ref çš„ getter

```javascript
// RefImpl çš„ getter
get value() {
  // ğŸ”´ ä¾èµ–æ”¶é›†
  trackRefValue(this);
  return this._value;
}

// trackRefValue - ref çš„ä¾èµ–æ”¶é›†
function trackRefValue(ref) {
  if (shouldTrack && activeEffect) {
    ref = toRaw(ref);
    
    // å¦‚æœæ²¡æœ‰ depï¼Œåˆ›å»º dep
    if (!ref.dep) {
      ref.dep = createDep();
    }
    
    // æ”¶é›†ä¾èµ–
    trackEffects(ref.dep);
  }
}
```

**ä¾èµ–è¿½è¸ªçš„æ•°æ®ç»“æ„ï¼š**
```
targetMap (WeakMap)
  â””â”€â”€ target (Proxyå¯¹è±¡)
      â””â”€â”€ depsMap (Map)
          â”œâ”€â”€ key1 (å±æ€§å)
          â”‚   â””â”€â”€ dep (Set)
          â”‚       â”œâ”€â”€ effect1
          â”‚       â”œâ”€â”€ effect2
          â”‚       â””â”€â”€ effect3
          â”œâ”€â”€ key2 (å±æ€§å)
          â”‚   â””â”€â”€ dep (Set)
          â”‚       â””â”€â”€ effect1
          â””â”€â”€ ...
```

## 3. è§¦å‘æ›´æ–°é˜¶æ®µ

### 3.1 reactive çš„ set æ‹¦æˆªå™¨

```javascript
// reactive çš„ set æ‹¦æˆªå™¨
function set(target, key, value, receiver) {
  // è·å–æ—§å€¼
  let oldValue = target[key];
  
  // å¦‚æœæ—§å€¼æ˜¯ refï¼Œæ–°å€¼ä¸æ˜¯ refï¼Œè®¾ç½® ref.value
  if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
    return false;
  }
  
  // åˆ¤æ–­æ˜¯å¦æ·»åŠ æ–°å±æ€§
  const hadKey = isArray(target) && isIntegerKey(key)
    ? Number(key) < target.length
    : hasOwn(target, key);
  
  // è®¾ç½®å€¼
  const result = Reflect.set(target, key, value, receiver);
  
  // å¦‚æœç›®æ ‡ä¸æ˜¯åŸå‹é“¾ä¸Šçš„å¯¹è±¡
  if (target === toRaw(receiver)) {
    // åˆ¤æ–­æ“ä½œç±»å‹
    if (!hadKey) {
      // æ·»åŠ æ–°å±æ€§
      trigger(target, TriggerOpTypes.ADD, key, value);
    } else if (hasChanged(value, oldValue)) {
      // ä¿®æ”¹å±æ€§
      trigger(target, TriggerOpTypes.SET, key, value, oldValue);
    }
  }
  
  return result;
}
```

### 3.2 ref çš„ setter

```javascript
// RefImpl çš„ setter
set value(newVal) {
  // æµ…æ¯”è¾ƒ
  newVal = this.__v_isShallow ? newVal : toRaw(newVal);
  
  // å€¼æœªå˜åŒ–ï¼Œç›´æ¥è¿”å›
  if (hasChanged(newVal, this._rawValue)) {
    this._rawValue = newVal;
    this._value = this.__v_isShallow ? newVal : toReactive(newVal);
    
    // ğŸ”´ è§¦å‘æ›´æ–°
    triggerRefValue(this);
  }
}

// triggerRefValue - ref çš„è§¦å‘æ›´æ–°
function triggerRefValue(ref) {
  ref = toRaw(ref);
  
  if (ref.dep) {
    triggerEffects(ref.dep);
  }
}
```

### 3.3 trigger - è§¦å‘æ›´æ–°

```javascript
// trigger - è§¦å‘æ›´æ–°
function trigger(target, type, key, newValue, oldValue) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  
  let deps = [];
  
  // æ·»åŠ  key çš„ä¾èµ–
  if (key !== void 0) {
    deps.push(depsMap.get(key));
  }
  
  // æ•°ç»„é•¿åº¦å˜åŒ–
  if (type === TriggerOpTypes.ADD) {
    if (!isArray(target)) {
      deps.push(depsMap.get(ITERATE_KEY));
      if (isMap(target)) {
        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
      }
    } else if (isIntegerKey(key)) {
      deps.push(depsMap.get('length'));
    }
  }
  
  // è§¦å‘æ‰€æœ‰ä¾èµ–
  triggerEffects(createDep(deps));
}

// triggerEffects - è§¦å‘ effects
function triggerEffects(dep) {
  const effects = isArray(dep) ? dep : [...dep];
  
  // å…ˆè§¦å‘ computed effects
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect);
    }
  }
  
  // å†è§¦å‘æ™®é€š effects
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect);
    }
  }
}

// triggerEffect - è§¦å‘å•ä¸ª effect
function triggerEffect(effect) {
  if (effect.scheduler) {
    // ä½¿ç”¨è°ƒåº¦å™¨
    effect.scheduler();
  } else {
    // ç›´æ¥æ‰§è¡Œ
    effect.run();
  }
}
```

## 4. è°ƒåº¦æ‰§è¡Œé˜¶æ®µ

### 4.1 è°ƒåº¦å™¨

```javascript
// è°ƒåº¦é˜Ÿåˆ—
const queue = [];
let isFlushing = false;
let isFlushPending = false;

// queueJob - åŠ å…¥é˜Ÿåˆ—
function queueJob(job) {
  // é¿å…é‡å¤åŠ å…¥
  if (!queue.includes(job)) {
    queue.push(job);
    queueFlush();
  }
}

// queueFlush - åˆ·æ–°é˜Ÿåˆ—
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}

// flushJobs - æ‰§è¡Œé˜Ÿåˆ—ä¸­çš„ job
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  
  // æ’åºï¼Œç¡®ä¿çˆ¶ç»„ä»¶å…ˆæ›´æ–°
  queue.sort((a, b) => getId(a) - getId(b));
  
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        callWithErrorHandling(job, null, 14 /* SCHEDULER */);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    isFlushing = false;
  }
}
```

### 4.2 ç»„ä»¶æ›´æ–°è°ƒåº¦

```javascript
// ç»„ä»¶å®ä¾‹çš„ update
function setupComponentInstance(instance) {
  instance.update = effect(componentUpdateFn, {
    scheduler: () => {
      queueJob(instance.update);
    }
  });
}

// æ•°æ®å˜åŒ–æ—¶
function setData(newData) {
  instance.data = newData; // è§¦å‘ trigger
  // trigger ä¼šè°ƒç”¨ effect.scheduler
  // scheduler ä¼šå°† effect åŠ å…¥é˜Ÿåˆ—
  // queueJob ä¼šå®‰æ’ effect çš„æ‰§è¡Œæ—¶æœº
}
```

## 5. è§†å›¾æ›´æ–°é˜¶æ®µ

### 5.1 ç»„ä»¶é‡æ–°æ¸²æŸ“

```javascript
// componentUpdateFn - ç»„ä»¶æ›´æ–°å‡½æ•°
function componentUpdateFn() {
  const instance = currentInstance;
  
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦å·²å¸è½½
  if (!instance.isMounted) {
    // é¦–æ¬¡æ¸²æŸ“
    const subTree = instance.render.call(instance.proxy);
    patch(null, subTree, instance.container);
    instance.subTree = subTree;
    instance.isMounted = true;
  } else {
    // æ›´æ–°æ¸²æŸ“
    const nextTree = instance.render.call(instance.proxy);
    const prevTree = instance.subTree;
    
    // Diff ç®—æ³•æ¯”è¾ƒæ–°æ—§æ ‘
    patch(prevTree, nextTree, instance.container);
    
    instance.subTree = nextTree;
  }
}

// patch - Diff ç®—æ³•å…¥å£
function patch(n1, n2, container) {
  // å¦‚æœæ–°æ—§èŠ‚ç‚¹ç›¸åŒï¼Œç›´æ¥è¿”å›
  if (n1 === n2) {
    return;
  }
  
  // å¦‚æœèŠ‚ç‚¹ç±»å‹ä¸åŒï¼Œç›´æ¥æ›¿æ¢
  if (n1.type !== n2.type) {
    unmount(n1);
    mount(n2, container);
    return;
  }
  
  // æ›´æ–°èŠ‚ç‚¹
  patchElement(n1, n2);
  
  // æ›´æ–°å­èŠ‚ç‚¹
  patchChildren(n1, n2, container);
}
```

### 5.2 DOM æ›´æ–°

```javascript
// patchElement - æ›´æ–°å…ƒç´ 
function patchElement(n1, n2) {
  const el = (n2.el = n1.el);
  const oldProps = n1.props || {};
  const newProps = n2.props || {};
  
  // æ›´æ–° props
  for (const key in newProps) {
    if (newProps[key] !== oldProps[key]) {
      hostPatchProp(el, key, oldProps[key], newProps[key]);
    }
  }
  
  // åˆ é™¤æ—§çš„ props
  for (const key in oldProps) {
    if (!(key in newProps)) {
      hostPatchProp(el, key, oldProps[key], null);
    }
  }
}

// hostPatchProp - æ›´æ–° DOM å±æ€§
function hostPatchProp(el, key, prevValue, nextValue) {
  if (key === 'class') {
    patchClass(el, nextValue);
  } else if (key === 'style') {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    // äº‹ä»¶
    patchEvent(el, key, prevValue, nextValue);
  } else {
    // å±æ€§
    patchAttr(el, key, nextValue);
  }
}
```

## å®Œæ•´æµç¨‹ç¤ºä¾‹

```javascript
// 1. åˆ›å»ºå“åº”å¼æ•°æ®
const state = reactive({
  count: 0,
  name: 'Vue3'
});

// 2. åˆ›å»º effect
effect(() => {
  console.log('count:', state.count);
  console.log('name:', state.name);
});

// æ‰§è¡Œæµç¨‹ï¼š
// 1. effect.run() å¼€å§‹æ‰§è¡Œ
// 2. activeEffect = å½“å‰ effect
// 3. æ‰§è¡Œå‰¯ä½œç”¨å‡½æ•°
// 4. è®¿é—® state.count â†’ è§¦å‘ get â†’ track(target, 'count')
// 5. è®¿é—® state.name â†’ è§¦å‘ get â†’ track(target, 'name')
// 6. ä¾èµ–æ”¶é›†å®Œæˆï¼š
//    targetMap = {
//      state: {
//        'count': [effect],
//        'name': [effect]
//      }
//    }
// 7. activeEffect = null

// 3. ä¿®æ”¹æ•°æ®
state.count = 1;

// æ‰§è¡Œæµç¨‹ï¼š
// 1. è§¦å‘ set â†’ set(state, 'count', 1)
// 2. æ£€æµ‹åˆ°å€¼å˜åŒ–
// 3. trigger(state, 'count')
// 4. ä» targetMap è·å– 'count' çš„ä¾èµ–
// 5. triggerEffects([effect])
// 6. effect.scheduler() â†’ queueJob(effect)
// 7. effect.run() é‡æ–°æ‰§è¡Œ
// 8. è¾“å‡º: count: 1, name: Vue3
// 9. å†æ¬¡è®¿é—® state.count å’Œ state.name
// 10. é‡æ–°æ”¶é›†ä¾èµ–
```

## é¢è¯•è¦ç‚¹

1. **ä¾èµ–æ”¶é›†çš„æ—¶æœº**ï¼š
   - åœ¨ effect æ‰§è¡Œæ—¶æ”¶é›†
   - åœ¨å“åº”å¼æ•°æ®çš„ getter ä¸­æ”¶é›†
   - ä½¿ç”¨ activeEffect æ ‡è®°å½“å‰ effect

2. **ä¾èµ–è¿½è¸ªçš„æ•°æ®ç»“æ„**ï¼š
   - WeakMap â†’ Map â†’ Set ä¸‰å±‚ç»“æ„
   - WeakMap é¿å…å†…å­˜æ³„æ¼
   - Set ä¿è¯ä¾èµ–å”¯ä¸€æ€§

3. **è§¦å‘æ›´æ–°çš„æµç¨‹**ï¼š
   - æ•°æ®å˜åŒ– â†’ trigger â†’ triggerEffects â†’ scheduler â†’ effect.run
   - ä½¿ç”¨è°ƒåº¦å™¨ä¼˜åŒ–æ€§èƒ½
   - å…ˆè§¦å‘ computed effectsï¼Œå†è§¦å‘æ™®é€š effects

4. **è§†å›¾æ›´æ–°çš„æµç¨‹**ï¼š
   - effect.run() â†’ componentUpdateFn â†’ render â†’ patch â†’ DOM æ›´æ–°
   - ä½¿ç”¨ Diff ç®—æ³•æœ€å°åŒ– DOM æ“ä½œ
   - æ‰¹é‡æ›´æ–°æé«˜æ€§èƒ½

5. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨ä½è¿ç®—ä¼˜åŒ–ä¾èµ–è¿½è¸ª
   - ä½¿ç”¨è°ƒåº¦å™¨æ‰¹é‡æ›´æ–°
   - ä½¿ç”¨ WeakMap é¿å…å†…å­˜æ³„æ¼
   - ä½¿ç”¨ Set ä¿è¯ä¾èµ–å”¯ä¸€æ€§

6. **Vue3 å“åº”å¼çš„ä¼˜åŠ¿**ï¼š
   - ä½¿ç”¨ Proxy æ›¿ä»£ Object.defineProperty
   - æ”¯æŒæ•°ç»„ç´¢å¼•å’Œé•¿åº¦å˜åŒ–
   - æ”¯æŒå¯¹è±¡æ–°å¢å’Œåˆ é™¤å±æ€§
   - æ›´å¥½çš„æ€§èƒ½å’ŒåŠŸèƒ½

7. **æ³¨æ„äº‹é¡¹**ï¼š
   - effect å¯ä»¥åµŒå¥—æ‰§è¡Œ
   - ä½¿ç”¨ shouldTrack æ§åˆ¶ä¾èµ–æ”¶é›†
   - ä½¿ç”¨è°ƒåº¦å™¨æ§åˆ¶æ‰§è¡Œæ—¶æœº
   - åŠæ—¶æ¸…ç†é¿å…å†…å­˜æ³„æ¼