# Vue2 自定义指令原理

## 核心概念

自定义指令是 Vue 提供的一种机制，允许开发者直接操作 DOM，实现对 DOM 元素的低级操作。

**指令钩子函数：**
- **bind**：指令第一次绑定到元素时调用（只调用一次）
- **inserted**：被绑定元素插入父节点时调用
- **update**：所在组件的 VNode 更新时调用
- **componentUpdated**：指令所在组件的 VNode 及其子 VNode 全部更新后调用
- **unbind**：指令与元素解绑时调用（只调用一次）

## 源码核心实现

### 1. 指令注册

```javascript
// 全局指令注册
Vue.directive = function (id, definition) {
  if (!definition) {
    return this.options.directives[id];
  }
  if (typeof definition === 'function') {
    definition = { bind: definition, update: definition };
  }
  this.options.directives[id] = definition;
  return this;
};

// 局部指令注册
function mergeOptions(parent, child, vm) {
  const options = {};
  let key;
  
  // 合并指令
  if (child.directives) {
    options.directives = extend(
      Object.create(parent.directives || null),
      child.directives
    );
  } else {
    options.directives = parent.directives;
  }
  
  return options;
}
```

### 2. 指令解析

```javascript
// 编译指令
function compileDirectives(el, options) {
  const dirs = parseDirectives(el);
  
  dirs.forEach(dir => {
    const def = resolveAsset(options, 'directives', dir.name);
    
    if (def) {
      const dirs = el.directives || (el.directives = []);
      dirs.push({
        name: dir.name,
        rawName: dir.rawName,
        value: dir.value,
        expression: dir.expression,
        arg: dir.arg,
        modifiers: dir.modifiers,
        def: def
      });
    }
  });
}

// 解析指令
function parseDirectives(el) {
  const dirs = [];
  let i = el.attrs.length;
  let attr, name, value;
  
  while (i--) {
    attr = el.attrs[i];
    name = attr.name;
    value = attr.value;
    
    // 检查是否是指令（以 v- 或 : 或 @ 开头）
    if (name.match(/v-|^:|^@/)) {
      const dirName = parseDirectiveName(name);
      const arg = parseDirectiveArg(name);
      const modifiers = parseModifiers(name);
      
      dirs.push({
        name: dirName,
        rawName: name,
        value: value,
        expression: value,
        arg: arg,
        modifiers: modifiers
      });
    }
  }
  
  return dirs;
}

// 解析指令名称
function parseDirectiveName(name) {
  if (name.startsWith('v-')) {
    return name.slice(2);
  }
  if (name.startsWith(':')) {
    return 'bind';
  }
  if (name.startsWith('@')) {
    return 'on';
  }
  return name;
}

// 解析指令参数
function parseDirectiveArg(name) {
  const match = name.match(/:(.+?)(?:\.(.+?))?$/);
  return match ? match[1] : null;
}

// 解析修饰符
function parseModifiers(name) {
  const match = name.match(/\.(.+?)$/);
  const modifiers = {};
  
  if (match) {
    match[1].split('.').forEach(mod => {
      modifiers[mod] = true;
    });
  }
  
  return modifiers;
}
```

### 3. 指令执行

```javascript
// 创建指令
function createDirective(dir, vnode) {
  const def = dir.def;
  const bind = def.bind;
  const inserted = def.inserted;
  const update = def.update;
  const componentUpdated = def.componentUpdated;
  const unbind = def.unbind;
  
  const baseDirective = {
    bind: function (vnode) {
      if (bind) {
        bind(vnode.elm, dir, vnode, oldVnode);
      }
    },
    inserted: function (vnode) {
      if (inserted) {
        inserted(vnode.elm, dir, vnode, oldVnode);
      }
    },
    update: function (oldVnode, vnode) {
      if (update) {
        update(vnode.elm, dir, vnode, oldVnode);
      }
    },
    componentUpdated: function (oldVnode, vnode) {
      if (componentUpdated) {
        componentUpdated(vnode.elm, dir, vnode, oldVnode);
      }
    },
    unbind: function (vnode) {
      if (unbind) {
        unbind(vnode.elm, dir, vnode, oldVnode);
      }
    }
  };
  
  return baseDirective;
}

// 调用指令钩子
function invokeDirectiveHook(vnode, hookName, dir) {
  const fn = dir.def && dir.def[hookName];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, vnode.parent);
    } catch (e) {
      handleError(e, vnode.context, `directive ${dir.name} ${hookName} hook`);
    }
  }
}

// 执行所有指令
function callHook(vnode, hookName) {
  const dirs = vnode.data.directives;
  if (!dirs) return;
  
  dirs.forEach(dir => {
    invokeDirectiveHook(vnode, hookName, dir);
  });
}
```

### 4. 指令生命周期

```javascript
// 在 patch 过程中调用指令钩子
function patchVnode(oldVnode, vnode) {
  const elm = vnode.elm = oldVnode.elm;
  const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
  const newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
  
  const isCreate = oldVnode === emptyNode;
  const isDestroy = vnode === emptyNode;
  
  // 触发 update 钩子
  const key = Object.keys(newDirs);
  const oldKey = Object.keys(oldDirs);
  
  // 触发 update 和 componentUpdated
  if (key.length || oldKey.length) {
    if (isCreate) {
      // 新节点，触发 bind 和 inserted
      callHook(vnode, 'bind');
      callHook(vnode, 'inserted');
    } else if (isDestroy) {
      // 删除节点，触发 unbind
      callHook(oldVnode, 'unbind');
    } else {
      // 更新节点
      for (let i = 0; i < key.length; i++) {
        const name = key[i];
        const dir = newDirs[name];
        const oldDir = oldDirs[name];
        
        if (oldDir) {
          // 已存在的指令，触发 update
          callHook(vnode, 'update', dir);
        } else {
          // 新指令，触发 bind
          callHook(vnode, 'bind', dir);
        }
      }
      
      // 触发 inserted 和 componentUpdated
      callHook(vnode, 'inserted');
      callHook(vnode, 'componentUpdated');
      
      // 删除不存在的指令
      for (let i = 0; i < oldKey.length; i++) {
        const name = oldKey[i];
        if (!newDirs[name]) {
          callHook(oldVnode, 'unbind', oldDirs[name]);
        }
      }
    }
  }
}

// 规范化指令
function normalizeDirectives(dirs, vm) {
  const res = Object.create(null);
  if (!dirs) {
    return res;
  }
  let i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || `${dir.name}.${Object.keys(dir.modifiers || {}).join('.')}`;
}
```

## 简化版实现

```javascript
// 简化版指令系统
class DirectiveSystem {
  constructor() {
    this.directives = {};
  }
  
  // 注册指令
  register(name, definition) {
    if (typeof definition === 'function') {
      definition = { bind: definition, update: definition };
    }
    this.directives[name] = definition;
  }
  
  // 获取指令
  get(name) {
    return this.directives[name];
  }
  
  // 解析指令
  parse(el) {
    const directives = [];
    const attrs = el.attributes;
    
    for (let i = 0; i < attrs.length; i++) {
      const attr = attrs[i];
      const name = attr.name;
      const value = attr.value;
      
      if (name.startsWith('v-')) {
        const dirName = name.slice(2);
        const [directiveName, ...modifiers] = dirName.split('.');
        
        directives.push({
          name: directiveName,
          value: value,
          modifiers: modifiers,
          rawName: name
        });
      }
    }
    
    return directives;
  }
  
  // 执行指令
  execute(el, directives, hookName) {
    directives.forEach(dir => {
      const definition = this.get(dir.name);
      
      if (definition && definition[hookName]) {
        definition[hookName](el, {
          name: dir.name,
          value: dir.value,
          modifiers: dir.modifiers
        });
      }
    });
  }
  
  // 绑定指令
  bind(el) {
    const directives = this.parse(el);
    this.execute(el, directives, 'bind');
    
    // 模拟插入
    setTimeout(() => {
      this.execute(el, directives, 'inserted');
    }, 0);
  }
  
  // 更新指令
  update(el) {
    const directives = this.parse(el);
    this.execute(el, directives, 'update');
  }
  
  // 解绑指令
  unbind(el) {
    const directives = this.parse(el);
    this.execute(el, directives, 'unbind');
  }
}

// 使用示例
const directiveSystem = new DirectiveSystem();

// 注册 v-focus 指令
directiveSystem.register('focus', {
  bind(el, binding) {
    console.log('bind:', binding);
  },
  inserted(el, binding) {
    el.focus();
    console.log('inserted:', binding);
  },
  update(el, binding) {
    console.log('update:', binding);
  },
  unbind(el, binding) {
    console.log('unbind:', binding);
  }
});

// 注册 v-color 指令
directiveSystem.register('color', {
  bind(el, binding) {
    el.style.color = binding.value;
  },
  update(el, binding) {
    el.style.color = binding.value;
  }
});

// 模拟 DOM 元素
const input = document.createElement('input');
input.setAttribute('v-focus', '');
input.setAttribute('v-color', 'red');

// 绑定指令
directiveSystem.bind(input);
console.log(input.hasFocus()); // true
console.log(input.style.color); // red
```

## 使用场景

1. **自动聚焦**：v-focus 指令
2. **权限控制**：v-permission 指令
3. **懒加载**：v-lazy 指令
4. **防抖节流**：v-debounce、v-throttle 指令
5. **无限滚动**：v-infinite-scroll 指令

```javascript
// 场景1: 自动聚焦
Vue.directive('focus', {
  inserted(el) {
    el.focus();
  }
});

// 场景2: 权限控制
Vue.directive('permission', {
  inserted(el, binding) {
    const { value } = binding;
    const permissions = store.getters.permissions;
    
    if (value && !permissions.includes(value)) {
      el.parentNode && el.parentNode.removeChild(el);
    }
  }
});

// 场景3: 懒加载
Vue.directive('lazy', {
  bind(el, binding) {
    el.dataset.src = binding.value;
    observer.observe(el);
  },
  unbind(el) {
    observer.unobserve(el);
  }
});

// 场景4: 防抖
Vue.directive('debounce', {
  inserted(el, binding) {
    let timer;
    el.addEventListener('click', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        binding.value();
      }, 500);
    });
  }
});
```

## 面试要点

1. **指令钩子的执行时机**：
   - bind：绑定元素时（元素还未插入 DOM）
   - inserted：元素插入父节点后
   - update：元素更新时
   - componentUpdated：组件及其子组件全部更新后
   - unbind：指令解绑时

2. **指令参数和修饰符**：
   - 参数：v-bind:href 中的 href
   - 修饰符：v-on:click.prevent 中的 prevent
   - 可以通过 binding 对象获取

3. **指令的 this 指向**：
   - 指令钩子中的 this 不指向组件实例
   - 需要通过 vnode.context 获取组件实例

4. **动态指令参数**：
   - Vue2.6+ 支持动态参数
   - 使用方括号：v-bind:[attribute]="value"
   - 可以动态绑定指令参数

5. **指令的性能优化**：
   - 使用 bind 而非 inserted 进行初始化
   - 避免在 update 中执行复杂操作
   - 及时解绑指令，避免内存泄漏

6. **Vue3 的改进**：
   - 钩子名称变化（如 bind → mounted）
   - 支持 Fragment 和 Teleport
   - 更好的 TypeScript 支持

7. **注意事项**：
   - 指令不能用于组件根元素
   - 指令的优先级低于组件
   - 避免在指令中修改组件数据
   - 指令应该无副作用或副作用可控