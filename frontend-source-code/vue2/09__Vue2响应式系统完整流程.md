# Vue2 å“åº”å¼ç³»ç»Ÿå®Œæ•´æµç¨‹

## æ ¸å¿ƒæ¦‚å¿µ

Vue2 çš„å“åº”å¼ç³»ç»Ÿæ˜¯ä¸€ä¸ªå®Œæ•´çš„é—­ç¯ï¼Œä»æ•°æ®åˆå§‹åŒ–åˆ°è§†å›¾æ›´æ–°ï¼Œæ¶‰åŠå¤šä¸ªæ ¸å¿ƒæ¨¡å—çš„ååŒå·¥ä½œã€‚

**å®Œæ•´æµç¨‹ï¼š**
1. **æ•°æ®åˆå§‹åŒ–**ï¼šObserver åŠ«æŒæ•°æ®ï¼Œå®šä¹‰ getter/setter
2. **ä¾èµ–æ”¶é›†**ï¼šDep æ”¶é›†ä¾èµ–ï¼ŒWatcher è®¢é˜…æ•°æ®å˜åŒ–
3. **æ•°æ®å˜åŒ–**ï¼šsetter è§¦å‘æ›´æ–°ï¼ŒDep é€šçŸ¥ Watcher
4. **è°ƒåº¦æ›´æ–°**ï¼šWatcher æ›´æ–°é˜Ÿåˆ—ï¼Œæ‰¹é‡å¤„ç†
5. **è§†å›¾æ›´æ–°**ï¼šé‡æ–°æ¸²æŸ“ï¼ŒDiff ç®—æ³•æ›´æ–° DOM

## 1. æ•°æ®åˆå§‹åŒ–é˜¶æ®µ

### 1.1 Observer - æ•°æ®åŠ«æŒ

```javascript
// Observer ç±»
class Observer {
  constructor(value) {
    this.value = value;
    this.dep = new Dep(); // ä¸ºæ¯ä¸ªå¯¹è±¡æ·»åŠ ä¸€ä¸ª dep
    this.vmCount = 0;
    
    def(value, '__ob__', this); // æ·»åŠ  __ob__ å±æ€§
    
    // æ•°ç»„ç‰¹æ®Šå¤„ç†
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods);
      } else {
        copyAugment(value, arrayMethods, arrayKeys);
      }
      this.observeArray(value);
    } else {
      // å¯¹è±¡å¤„ç†
      this.walk(value);
    }
  }
  
  // éå†å¯¹è±¡å±æ€§
  walk(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i]);
    }
  }
  
  // è§‚å¯Ÿæ•°ç»„
  observeArray(items) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  }
}

// observe - è§‚å¯Ÿæ•°æ®
function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }
  
  let ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  
  if (asRootData && ob) {
    ob.vmCount++;
  }
  
  return ob;
}

// defineReactive - å®šä¹‰å“åº”å¼
function defineReactive(obj, key, val, customSetter, shallow) {
  const dep = new Dep(); // ä¸ºæ¯ä¸ªå±æ€§åˆ›å»ºä¸€ä¸ªä¾èµ–æ”¶é›†å™¨
  
  const property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }
  
  // é¢„å¤„ç† getter/setter
  const getter = property && property.get;
  const setter = property && property.set;
  
  // é€’å½’å¤„ç†åµŒå¥—å¯¹è±¡
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }
  
  let childOb = !shallow && observe(val);
  
  // å®šä¹‰ getter/setter
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      const value = getter ? getter.call(obj) : val;
      
      // ğŸ”´ ä¾èµ–æ”¶é›†
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      
      return value;
    },
    
    set(newVal) {
      const value = getter ? getter.call(obj) : val;
      
      // å€¼æœªå˜åŒ–ï¼Œç›´æ¥è¿”å›
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return;
      }
      
      // å¦‚æœæ²¡æœ‰ setterï¼Œç›´æ¥è¿”å›
      if (getter && !setter) return;
      
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      
      // é€’å½’å¤„ç†æ–°å€¼
      childOb = !shallow && observe(newVal);
      
      // ğŸ”´ è§¦å‘æ›´æ–°
      dep.notify();
    }
  });
}
```

### 1.2 æ•°ç»„æ–¹æ³•é‡å†™

```javascript
// æ•°ç»„æ–¹æ³•é‡å†™
const arrayProto = Array.prototype;
const arrayMethods = Object.create(arrayProto);

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

methodsToPatch.forEach(method => {
  const original = arrayProto[method];
  def(arrayMethods, method, function mutator(...args) {
    const result = original.apply(this, args);
    const ob = this.__ob__;
    let inserted;
    
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    
    // è§‚å¯Ÿæ–°å¢çš„å…ƒç´ 
    if (inserted) {
      ob.observeArray(inserted);
    }
    
    // ğŸ”´ è§¦å‘æ›´æ–°
    ob.dep.notify();
    
    return result;
  });
});

// dependArray - ä¾èµ–æ•°ç»„
function dependArray(value) {
  for (let e, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
```

## 2. ä¾èµ–æ”¶é›†é˜¶æ®µ

### 2.1 Dep - ä¾èµ–æ”¶é›†å™¨

```javascript
// Dep ç±»
let uid = 0;

class Dep {
  constructor() {
    this.id = uid++;
    this.subs = []; // å­˜å‚¨è®¢é˜…è€…
  }
  
  // æ·»åŠ è®¢é˜…è€…
  addSub(sub) {
    this.subs.push(sub);
  }
  
  // ç§»é™¤è®¢é˜…è€…
  removeSub(sub) {
    remove(this.subs, sub);
  }
  
  // ä¾èµ–æ”¶é›†
  depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  }
  
  // é€šçŸ¥è®¢é˜…è€…
  notify() {
    const subs = this.subs.slice();
    
    // ç¨³å®šæ’åºï¼Œç¡®ä¿å…ˆæ·»åŠ çš„å…ˆæ‰§è¡Œ
    if (process.env.NODE_ENV !== 'production' && !config.async) {
      subs.sort((a, b) => a.id - b.id);
    }
    
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  }
}

// Dep.target - å½“å‰æ­£åœ¨æ”¶é›†ä¾èµ–çš„ Watcher
Dep.target = null;
const targetStack = [];

// pushTarget - å‹å…¥ç›®æ ‡
function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

// popTarget - å¼¹å‡ºç›®æ ‡
function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
```

### 2.2 Watcher - è®¢é˜…è€…

```javascript
// Watcher ç±»
let uid = 0;

class Watcher {
  constructor(vm, expOrFn, cb, options, isRenderWatcher) {
    this.vm = vm;
    
    // å¦‚æœæ˜¯æ¸²æŸ“ watcherï¼Œæ·»åŠ åˆ° vm
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    
    vm._watchers.push(this);
    
    // é€‰é¡¹
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    
    this.cb = cb;
    this.id = ++uid;
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new Set();
    this.newDepIds = new Set();
    
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : '';
    
    // è§£æ getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = noop;
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        );
      }
    }
    
    this.value = this.lazy ? undefined : this.get();
  }
  
  // è·å–å€¼
  get() {
    pushTarget(this);
    let value;
    const vm = this.vm;
    
    try {
      // ğŸ”´ æ‰§è¡Œ getterï¼Œè§¦å‘ä¾èµ–æ”¶é›†
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher "${this.expression}"`);
      } else {
        throw e;
      }
    } finally {
      // æ·±åº¦è§‚å¯Ÿ
      if (this.deep) {
        traverse(value);
      }
      
      // æ¸…ç†ä¾èµ–
      popTarget();
      this.cleanupDeps();
    }
    
    return value;
  }
  
  // æ·»åŠ ä¾èµ–
  addDep(dep) {
    const id = dep.id;
    
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  }
  
  // æ¸…ç†ä¾èµ–
  cleanupDeps() {
    let i = this.deps.length;
    while (i--) {
      const dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    
    let tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  }
  
  // æ›´æ–°
  update() {
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  }
  
  // è¿è¡Œ
  run() {
    if (this.active) {
      const value = this.get();
      
      if (
        value !== this.value ||
        isObject(value) ||
        this.deep
      ) {
        const oldValue = this.value;
        this.value = value;
        
        if (this.user) {
          const info = `callback for watcher "${this.expression}"`;
          invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  }
  
  // æ±‚å€¼
  evaluate() {
    this.value = this.get();
    this.dirty = false;
  }
  
  // æ·»åŠ ä¾èµ–
  depend() {
    let i = this.deps.length;
    while (i--) {
      this.deps[i].depend();
    }
  }
  
  // åœæ­¢
  teardown() {
    if (this.active) {
      remove(this.vm._watchers, this);
      let i = this.deps.length;
      while (i--) {
        this.deps[i].removeSub(this);
      }
      this.active = false;
    }
  }
}
```

### 2.3 ä¾èµ–æ”¶é›†çš„æ—¶æœº

```javascript
// åˆ›å»ºæ¸²æŸ“ watcher
function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  
  // è°ƒç”¨ beforeMount é’©å­
  callHook(vm, 'beforeMount');
  
  // å®šä¹‰æ›´æ–°å‡½æ•°
  let updateComponent;
  
  updateComponent = () => {
    vm._update(vm._render(), hydrating);
  };
  
  // ğŸ”´ åˆ›å»ºæ¸²æŸ“ watcher
  new Watcher(vm, updateComponent, noop, {
    before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  
  hydrating = false;
  
  // æ ‡è®°ä¸ºå·²æŒ‚è½½
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  
  return vm;
}

// _render - æ¸²æŸ“å‡½æ•°
Vue.prototype._render = function () {
  const vm = this;
  const { render, _parentVnode } = vm.$options;
  
  // è®¾ç½®çˆ¶ vnode
  vm.$vnode = _parentVnode;
  
  // è®¾ç½® vnode
  let vnode;
  try {
    currentRenderingInstance = vm;
    // ğŸ”´ æ‰§è¡Œæ¸²æŸ“å‡½æ•°ï¼Œè§¦å‘ä¾èµ–æ”¶é›†
    vnode = render.call(vm._renderProxy, vm.$createElement);
  } catch (e) {
    handleError(e, vm, `render`);
    vnode = vm._staticTrees[0];
  } finally {
    currentRenderingInstance = null;
  }
  
  return vnode;
};
```

## 3. æ•°æ®å˜åŒ–é˜¶æ®µ

### 3.1 è§¦å‘æ›´æ–°

```javascript
// setter è§¦å‘
set(newVal) {
  const value = getter ? getter.call(obj) : val;
  
  // å€¼æœªå˜åŒ–ï¼Œç›´æ¥è¿”å›
  if (newVal === value || (newVal !== newVal && value !== value)) {
    return;
  }
  
  if (setter) {
    setter.call(obj, newVal);
  } else {
    val = newVal;
  }
  
  // é€’å½’å¤„ç†æ–°å€¼
  childOb = !shallow && observe(newVal);
  
  // ğŸ”´ è§¦å‘æ›´æ–°
  dep.notify();
}

// dep.notify - é€šçŸ¥è®¢é˜…è€…
notify() {
  const subs = this.subs.slice();
  
  // ç¨³å®šæ’åº
  if (process.env.NODE_ENV !== 'production' && !config.async) {
    subs.sort((a, b) => a.id - b.id);
  }
  
  // é€šçŸ¥æ‰€æœ‰è®¢é˜…è€…
  for (let i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}
```

### 3.2 Watcher æ›´æ–°

```javascript
// update - æ›´æ–° watcher
update() {
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    // ğŸ”´ åŠ å…¥æ›´æ–°é˜Ÿåˆ—
    queueWatcher(this);
  }
}

// queueWatcher - åŠ å…¥æ›´æ–°é˜Ÿåˆ—
function queueWatcher(watcher) {
  const id = watcher.id;
  
  // é¿å…é‡å¤åŠ å…¥
  if (has[id] == null) {
    has[id] = true;
    
    if (!flushing) {
      queue.push(watcher);
    } else {
      // å¦‚æœæ­£åœ¨åˆ·æ–°ï¼Œæ’å…¥åˆ°æ­£ç¡®çš„ä½ç½®
      let i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    
    // é˜Ÿåˆ—æœªåˆ·æ–°ï¼ŒåŠ å…¥åˆ·æ–°é˜Ÿåˆ—
    if (!waiting) {
      waiting = true;
      
      if (process.env.NODE_ENV !== 'production' && !config.async) {
        flushSchedulerQueue();
        return;
      }
      
      // ğŸ”´ å¼‚æ­¥åˆ·æ–°é˜Ÿåˆ—
      nextTick(flushSchedulerQueue);
    }
  }
}
```

## 4. è°ƒåº¦æ›´æ–°é˜¶æ®µ

### 4.1 nextTick

```javascript
// nextTick - ä¸‹ä¸€ä¸ª tick
const callbacks = [];
let pending = false;

function nextTick(cb, ctx) {
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    }
  });
  
  if (!pending) {
    pending = true;
    timerFunc();
  }
  
  // å¦‚æœæ²¡æœ‰å›è°ƒï¼Œè¿”å› Promise
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve;
    });
  }
}

// timerFunc - å®šæ—¶å™¨å‡½æ•°
let timerFunc;

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve();
  timerFunc = () => {
    p.then(flushCallbacks);
    if (isIOS) setTimeout(noop);
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  let counter = 1;
  const observer = new MutationObserver(flushCallbacks);
  const textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = () => {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  timerFunc = () => {
    setImmediate(flushCallbacks);
  };
} else {
  timerFunc = () => {
    setTimeout(flushCallbacks, 0);
  };
}

// flushCallbacks - åˆ·æ–°å›è°ƒ
function flushCallbacks() {
  pending = false;
  const copies = callbacks.slice(0);
  callbacks.length = 0;
  
  for (let i = 0; i < copies.length; i++) {
    copies[i]();
  }
}
```

### 4.2 flushSchedulerQueue

```javascript
// flushSchedulerQueue - åˆ·æ–°è°ƒåº¦é˜Ÿåˆ—
function flushSchedulerQueue() {
  flushing = true;
  let watcher, id;
  
  // å¤åˆ¶é˜Ÿåˆ—
  queue.sort((a, b) => a.id - b.id);
  
  // éå†é˜Ÿåˆ—
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    
    if (watcher.before) {
      watcher.before();
    }
    
    id = watcher.id;
    has[id] = null;
    
    // ğŸ”´ æ‰§è¡Œ watcher
    watcher.run();
    
    // å¦‚æœå·²ç»é”€æ¯ï¼Œåœæ­¢
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' +
          `(watcher with id "${id}")`,
          watcher.vm
        );
        break;
      }
    }
  }
  
  // é‡ç½®é˜Ÿåˆ—
  resetSchedulerState();
  
  // è°ƒç”¨ç»„ä»¶æ›´æ–°é’©å­
  callActivatedHooks(queue);
  callUpdatedHooks(queue);
  
  // æ¸…ç†
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

// resetSchedulerState - é‡ç½®è°ƒåº¦çŠ¶æ€
function resetSchedulerState() {
  index = queue.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}
```

## 5. è§†å›¾æ›´æ–°é˜¶æ®µ

### 5.1 Watcher.run

```javascript
// run - è¿è¡Œ watcher
run() {
  if (this.active) {
    // ğŸ”´ é‡æ–°è·å–å€¼
    const value = this.get();
    
    // å€¼å˜åŒ–ï¼Œæ‰§è¡Œå›è°ƒ
    if (
      value !== this.value ||
      isObject(value) ||
      this.deep
    ) {
      const oldValue = this.value;
      this.value = value;
      
      if (this.user) {
        const info = `callback for watcher "${this.expression}"`;
        invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
}

// get - è·å–å€¼
get() {
  pushTarget(this);
  let value;
  const vm = this.vm;
  
  try {
    // ğŸ”´ æ‰§è¡Œ getterï¼Œè§¦å‘ä¾èµ–æ”¶é›†
    value = this.getter.call(vm, vm);
    
    // æ¸²æŸ“ watcher çš„ getter æ˜¯ updateComponent
    // updateComponent = () => {
    //   vm._update(vm._render(), hydrating);
    // }
  } catch (e) {
    if (this.user) {
      handleError(e, vm, `getter for watcher "${this.expression}"`);
    } else {
      throw e;
    }
  } finally {
    // æ·±åº¦è§‚å¯Ÿ
    if (this.deep) {
      traverse(value);
    }
    
    // æ¸…ç†ä¾èµ–
    popTarget();
    this.cleanupDeps();
  }
  
  return value;
}
```

### 5.2 _update æ›´æ–°è§†å›¾

```javascript
// _update - æ›´æ–°è§†å›¾
Vue.prototype._update = function (vnode, hydrating) {
  const vm = this;
  const prevEl = vm.$el;
  const prevVnode = vm._vnode;
  const restoreActiveInstance = setActiveInstance(vm);
  
  vm._vnode = vnode;
  
  // Vue.prototype.__patch__ åœ¨å…¥å£æ–‡ä»¶ä¸­æ³¨å…¥
  if (!prevVnode) {
    // é¦–æ¬¡æ¸²æŸ“
    vm.$el = vm.__patch__(
      vm.$el, vnode, hydrating, false /* removeOnly */,
      vm.$options._parentElm,
      vm.$options._refElm
    );
  } else {
    // æ›´æ–°æ¸²æŸ“
    vm.$el = vm.__patch__(prevVnode, vnode);
  }
  
  restoreActiveInstance();
  
  // æ›´æ–° __vue__ å¼•ç”¨
  if (prevEl) {
    prevEl.__vue__ = null;
  }
  
  if (vm.$el) {
    vm.$el.__vue__ = vm;
  }
};
```

### 5.3 __patch__ Diff ç®—æ³•

```javascript
// __patch__ - è¡¥ä¸å‡½æ•°
Vue.prototype.__patch__ = function (oldVnode, vnode, hydrating, removeOnly) {
  // å¦‚æœæ²¡æœ‰ vnodeï¼Œé”€æ¯èŠ‚ç‚¹
  if (!vnode) {
    if (oldVnode) invokeDestroyHook(oldVnode);
    return;
  }
  
  const isRealElement = isDef(oldVnode.nodeType);
  
  if (!isRealElement && sameVnode(oldVnode, vnode)) {
    // ç›¸åŒèŠ‚ç‚¹ï¼Œæ‰§è¡Œ patch
    patchVnode(oldVnode, vnode);
  } else {
    // ä¸åŒèŠ‚ç‚¹
    if (isRealElement) {
      oldVnode = emptyNodeAt(oldVnode);
    }
    
    const oldElm = oldVnode.elm;
    const parentElm = nodeOps.parentNode(oldElm);
    
    // åˆ›å»ºæ–°èŠ‚ç‚¹
    createElm(
      vnode,
      insertedVnodeQueue,
      oldElm._leaveCb ? null : parentElm,
      nodeOps.nextSibling(oldElm)
    );
    
    // ç§»é™¤æ—§èŠ‚ç‚¹
    if (isDef(parentElm)) {
      removeVnodes([oldVnode], 0, 0);
    } else if (isDef(oldVnode.tag)) {
      invokeDestroyHook(oldVnode);
    }
  }
  
  return vnode.elm;
};

// patchVnode - å¯¹æ¯” vnode
function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
  // å¦‚æœç›¸åŒï¼Œç›´æ¥è¿”å›
  if (oldVnode === vnode) {
    return;
  }
  
  const elm = vnode.elm = oldVnode.elm;
  
  // å¦‚æœæ˜¯å¼‚æ­¥ç»„ä»¶å ä½ç¬¦ï¼Œè·³è¿‡
  if (isTrue(oldVnode.isAsyncPlaceholder)) {
    if (isDef(vnode.asyncFactory.resolved)) {
      hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
    } else {
      vnode.isAsyncPlaceholder = true;
    }
    return;
  }
  
  // å¦‚æœæ˜¯é™æ€èŠ‚ç‚¹ï¼Œè·³è¿‡
  if (isTrue(vnode.isStatic) &&
    isTrue(oldVnode.isStatic) &&
    vnode.key === oldVnode.key &&
    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
  ) {
    vnode.componentInstance = oldVnode.componentInstance;
    return;
  }
  
  // æ›´æ–°ç»„ä»¶
  let i;
  const data = vnode.data;
  if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
    i(oldVnode, vnode);
  }
  
  const oldCh = oldVnode.children;
  const ch = vnode.children;
  
  // æ›´æ–°å­èŠ‚ç‚¹
  if (isDef(data) && isPatchable(vnode)) {
    for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
    if (isDef(i = data.hook) && isDef(i = i.update)) i(oldVnode, vnode);
  }
  
  if (isUndef(vnode.text)) {
    if (isDef(oldCh) && isDef(ch)) {
      if (oldCh !== ch) {
        // ğŸ”´ æ›´æ–°å­èŠ‚ç‚¹
        updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
      }
    } else if (isDef(ch)) {
      // æ·»åŠ æ–°å­èŠ‚ç‚¹
      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '');
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
    } else if (isDef(oldCh)) {
      // ç§»é™¤æ—§å­èŠ‚ç‚¹
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    } else if (isDef(oldVnode.text)) {
      // ç§»é™¤æ–‡æœ¬
      nodeOps.setTextContent(elm, '');
    }
  } else if (oldVnode.text !== vnode.text) {
    // æ›´æ–°æ–‡æœ¬
    nodeOps.setTextContent(elm, vnode.text);
  }
}
```

## å®Œæ•´æµç¨‹ç¤ºä¾‹

```javascript
// 1. åˆ›å»º Vue å®ä¾‹
const vm = new Vue({
  el: '#app',
  data: {
    count: 0,
    message: 'Hello Vue'
  },
  template: `
    <div>
      <p>{{ message }}</p>
      <p>Count: {{ count }}</p>
    </div>
  `
});

// æ‰§è¡Œæµç¨‹ï¼š
// 1. new Vue(options)
// 2. this._init(options)
// 3. initData(vm) - åˆå§‹åŒ– data
//    - observe(data) - è§‚å¯Ÿæ•°æ®
//    - new Observer(data) - åˆ›å»º Observer
//    - walk(data) - éå†å¯¹è±¡
//    - defineReactive(obj, key) - å®šä¹‰å“åº”å¼
//      - Object.defineProperty(obj, key, {
//          get() {
//            // ğŸ”´ ä¾èµ–æ”¶é›†
//            if (Dep.target) {
//              dep.depend();
//            }
//            return value;
//          },
//          set(newVal) {
//            // ğŸ”´ è§¦å‘æ›´æ–°
//            dep.notify();
//          }
//        })
// 4. mountComponent(vm, el) - æŒ‚è½½ç»„ä»¶
// 5. new Watcher(vm, updateComponent) - åˆ›å»ºæ¸²æŸ“ watcher
// 6. watcher.get() - è·å–å€¼
//    - pushTarget(this) - è®¾ç½® Dep.target
//    - updateComponent() - æ‰§è¡Œæ›´æ–°å‡½æ•°
//      - vm._render() - æ‰§è¡Œæ¸²æŸ“å‡½æ•°
//        - render.call(vm._renderProxy, vm.$createElement)
//        - è®¿é—® vm.message â†’ è§¦å‘ get â†’ dep.depend()
//        - è®¿é—® vm.count â†’ è§¦å‘ get â†’ dep.depend()
//      - vm._update(vnode) - æ›´æ–° DOM
//        - vm.__patch__() - æ‰§è¡Œ Diff ç®—æ³•
//        - createElm(vnode) - åˆ›å»ºçœŸå® DOM
//        - insert(parentElm, vnode.elm) - æ’å…¥ DOM
//    - popTarget() - æ¢å¤ Dep.target
//    - cleanupDeps() - æ¸…ç†ä¾èµ–
// 7. ä¾èµ–æ”¶é›†å®Œæˆï¼š
//    - message.dep.subs = [watcher]
//    - count.dep.subs = [watcher]

// 8. ä¿®æ”¹æ•°æ®
vm.count = 1;

// æ‰§è¡Œæµç¨‹ï¼š
// 1. è§¦å‘ set â†’ set(1)
// 2. æ£€æµ‹åˆ°å€¼å˜åŒ–
// 3. dep.notify() - é€šçŸ¥è®¢é˜…è€…
// 4. watcher.update() - æ›´æ–° watcher
// 5. queueWatcher(watcher) - åŠ å…¥æ›´æ–°é˜Ÿåˆ—
// 6. nextTick(flushSchedulerQueue) - å¼‚æ­¥åˆ·æ–°
// 7. flushSchedulerQueue() - åˆ·æ–°è°ƒåº¦é˜Ÿåˆ—
// 8. watcher.run() - è¿è¡Œ watcher
//    - watcher.get() - è·å–å€¼
//      - pushTarget(this) - è®¾ç½® Dep.target
//      - updateComponent() - æ‰§è¡Œæ›´æ–°å‡½æ•°
//        - vm._render() - æ‰§è¡Œæ¸²æŸ“å‡½æ•°
//          - è®¿é—® vm.message â†’ è§¦å‘ get â†’ dep.depend()
//          - è®¿é—® vm.count â†’ è§¦å‘ get â†’ dep.depend()
//        - vm._update(vnode) - æ›´æ–° DOM
//          - vm.__patch__(prevVnode, vnode) - æ‰§è¡Œ Diff ç®—æ³•
//          - patchVnode(oldVnode, vnode) - å¯¹æ¯” vnode
//          - updateChildren() - æ›´æ–°å­èŠ‚ç‚¹
//          - æ›´æ–° DOM: <p>Count: 1</p>
//      - popTarget() - æ¢å¤ Dep.target
//      - cleanupDeps() - æ¸…ç†ä¾èµ–
// 9. DOM æ›´æ–°å®Œæˆ
```

## é¢è¯•è¦ç‚¹

1. **å“åº”å¼ç³»ç»Ÿçš„æ ¸å¿ƒ**ï¼š
   - Observerï¼šåŠ«æŒæ•°æ®ï¼Œå®šä¹‰ getter/setter
   - Depï¼šä¾èµ–æ”¶é›†å™¨ï¼Œç®¡ç†è®¢é˜…è€…
   - Watcherï¼šè®¢é˜…è€…ï¼Œç›‘å¬æ•°æ®å˜åŒ–

2. **ä¾èµ–æ”¶é›†çš„æ—¶æœº**ï¼š
   - åœ¨ Watcher.get() æ‰§è¡Œæ—¶æ”¶é›†
   - åœ¨å“åº”å¼æ•°æ®çš„ getter ä¸­æ”¶é›†
   - ä½¿ç”¨ Dep.target æ ‡è®°å½“å‰ Watcher

3. **ä¾èµ–è¿½è¸ªçš„æ•°æ®ç»“æ„**ï¼š
   - Dep.subsï¼šå­˜å‚¨ Watcher
   - Watcher.depsï¼šå­˜å‚¨ Dep
   - åŒå‘å¼•ç”¨ï¼Œä¾¿äºæ¸…ç†

4. **è§¦å‘æ›´æ–°çš„æµç¨‹**ï¼š
   - æ•°æ®å˜åŒ– â†’ setter â†’ dep.notify() â†’ watcher.update() â†’ queueWatcher() â†’ nextTick() â†’ flushSchedulerQueue() â†’ watcher.run()

5. **å¼‚æ­¥æ›´æ–°çš„ä¼˜åŠ¿**ï¼š
   - æ‰¹é‡å¤„ç†ï¼Œæé«˜æ€§èƒ½
   - é¿å…é‡å¤æ¸²æŸ“
   - ä¿è¯æ‰§è¡Œé¡ºåº

6. **nextTick çš„å®ç°**ï¼š
   - ä¼˜å…ˆä½¿ç”¨ Promise
   - å…¶æ¬¡ä½¿ç”¨ MutationObserver
   - æœ€åä½¿ç”¨ setTimeout

7. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - ä¾èµ–å»é‡
   - å¼‚æ­¥æ›´æ–°
   - æ‰¹é‡å¤„ç†
   - é™æ€èŠ‚ç‚¹æ ‡è®°

8. **æ³¨æ„äº‹é¡¹**ï¼š
   - æ— æ³•æ£€æµ‹å¯¹è±¡å±æ€§çš„æ·»åŠ /åˆ é™¤
   - æ— æ³•æ£€æµ‹æ•°ç»„ç´¢å¼•å’Œé•¿åº¦çš„å˜åŒ–
   - éœ€è¦ä½¿ç”¨ $set/$delete
   - åµŒå¥—å¯¹è±¡éœ€è¦é€’å½’å¤„ç†