# Vue2 实例挂载流程

## 核心概念

Vue2 的实例挂载流程是从 `new Vue()` 到 DOM 渲染完成的完整过程，涉及多个核心模块的协同工作。

**完整流程：**
1. **初始化配置**：合并选项、初始化生命周期
2. **初始化状态**：初始化 props、methods、data、computed、watch
3. **初始化事件**：初始化事件监听
4. **初始化渲染**：初始化渲染函数
5. **挂载实例**：$mount 挂载到 DOM
6. **渲染模板**：编译模板为渲染函数
7. **创建虚拟 DOM**：执行渲染函数生成 VNode
8. **更新真实 DOM**：将 VNode 转换为真实 DOM 并插入页面

## 1. Vue 构造函数

```javascript
// Vue 构造函数
function Vue(options) {
  // 安全检查：不能直接调用 Vue，必须通过 new
  if (!(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  
  // 初始化实例
  this._init(options);
}

// 在原型上挂载 _init 方法
initMixin(Vue);

// 初始化混入
function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    const vm = this;
    
    // 保存 options
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    );
    
    // 初始化生命周期
    initLifecycle(vm);
    
    // 初始化事件
    initEvents(vm);
    
    // 初始化渲染
    initRender(vm);
    
    // 调用 beforeCreate 钩子
    callHook(vm, 'beforeCreate');
    
    // 初始化注入
    initInjections(vm);
    
    // 初始化状态
    initState(vm);
    
    // 初始化提供
    initProvide(vm);
    
    // 调用 created 钩子
    callHook(vm, 'created');
    
    // 如果有 el 选项，自动挂载
    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}
```

## 2. 初始化生命周期

```javascript
// initLifecycle - 初始化生命周期
function initLifecycle(vm) {
  const options = vm.$options;
  
  // 定位第一个非抽象父组件
  let parent = options.parent;
  
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }
  
  // 设置父组件引用
  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  
  // 设置子组件引用
  vm.$children = [];
  
  // 设置其他属性
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}
```

## 3. 初始化状态

```javascript
// initState - 初始化状态
function initState(vm) {
  vm._watchers = [];
  const opts = vm.$options;
  
  // 初始化 props
  if (opts.props) initProps(vm, opts.props);
  
  // 初始化 methods
  if (opts.methods) initMethods(vm, opts.methods);
  
  // 初始化 data
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  
  // 初始化 computed
  if (opts.computed) initComputed(vm, opts.computed);
  
  // 初始化 watch
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

// initData - 初始化 data
function initData(vm) {
  let data = vm.$options.data;
  
  // 如果 data 是函数，执行它
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  
  // 验证 data 是否是纯对象
  if (!isPlainObject(data)) {
    data = {};
    warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  
  // 代理 data 到实例上
  const keys = Object.keys(data);
  const props = vm.$options.props;
  const methods = vm.$options.methods;
  let i = keys.length;
  
  while (i--) {
    const key = keys[i];
    
    // 检查是否与 props 或 methods 冲突
    if (props && hasOwn(props, key)) {
      warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      );
    } else if (!isReserved(key)) {
      // 代理到实例
      proxy(vm, `_data`, key);
    }
  }
  
  // 观察数据
  observe(data, true /* asRootData */);
}

// proxy - 代理数据到实例
function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  
  Object.defineProperty(target, key, sharedPropertyDefinition);
}
```

## 4. $mount 挂载方法

```javascript
// $mount - 挂载方法
Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// mountComponent - 挂载组件
function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  
  // 如果没有渲染函数，编译模板
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    
    if (process.env.NODE_ENV !== 'production') {
      // 开发环境警告
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      }
    }
  }
  
  // 调用 beforeMount 钩子
  callHook(vm, 'beforeMount');
  
  // 定义更新函数
  let updateComponent;
  
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name;
      const id = vm._uid;
      const startTag = `vue-perf-start:${id}`;
      const endTag = `vue-perf-end:${id}`;
      
      mark(startTag);
      const vnode = vm._render();
      mark(endTag);
      measure(`vue ${name} render`, startTag, endTag);
      
      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(`vue ${name} patch`, startTag, endTag);
    };
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating);
    };
  }
  
  // 创建渲染 watcher
  new Watcher(vm, updateComponent, noop, {
    before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  
  hydrating = false;
  
  // 手动挂载的实例，标记为已挂载
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  
  return vm;
}
```

## 5. _render 渲染函数

```javascript
// _render - 渲染函数
Vue.prototype._render = function () {
  const vm = this;
  const { render, _parentVnode } = vm.$options;
  
  // 重置 _vnode
  if (_parentVnode) {
    vm.$scopedSlots = normalizeScopedSlots(
      _parentVnode.data.scopedSlots,
      vm.$slots,
      vm.$scopedSlots
    );
  }
  
  // 设置父 vnode
  vm.$vnode = _parentVnode;
  
  // 渲染 vnode
  let vnode;
  try {
    currentRenderingInstance = vm;
    vnode = render.call(vm._renderProxy, vm.$createElement);
  } catch (e) {
    handleError(e, vm, `render`);
    
    // 返回错误 vnode
    if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
      try {
        vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
      } catch (e) {
        handleError(e, vm, `renderError`);
        vnode = vm._staticTrees[0];
      }
    } else {
      vnode = vm._staticTrees[0];
    }
  } finally {
    currentRenderingInstance = null;
  }
  
  // 如果返回数组，只取第一个元素
  if (Array.isArray(vnode) && vnode.length === 1) {
    vnode = vnode[0];
  }
  
  // 返回空 vnode
  if (!(vnode instanceof VNode)) {
    if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
      warn(
        'Multiple root nodes returned from render function. Render function ' +
        'should return a single root node',
        vm
      );
    }
    vnode = createEmptyVNode();
  }
  
  // 设置父节点
  vnode.parent = _parentVnode;
  return vnode;
};
```

## 6. _update 更新函数

```javascript
// _update - 更新函数
Vue.prototype._update = function (vnode, hydrating) {
  const vm = this;
  const prevEl = vm.$el;
  const prevVnode = vm._vnode;
  const restoreActiveInstance = setActiveInstance(vm);
  
  vm._vnode = vnode;
  
  // Vue.prototype.__patch__ 在入口文件中注入
  if (!prevVnode) {
    // 首次渲染
    vm.$el = vm.__patch__(
      vm.$el, vnode, hydrating, false /* removeOnly */,
      vm.$options._parentElm,
      vm.$options._refElm
    );
  } else {
    // 更新渲染
    vm.$el = vm.__patch__(prevVnode, vnode);
  }
  
  restoreActiveInstance();
  
  // 更新 __vue__ 引用
  if (prevEl) {
    prevEl.__vue__ = null;
  }
  
  if (vm.$el) {
    vm.$el.__vue__ = vm;
  }
  
  // 如果父组件是 HOC，更新其 vnode
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el;
  }
  
  // 更新列表渲染的 __vlist 引用
  if (vm.$options._renderChildren && vm.$options._renderChildren[0]) {
    vm.$options._renderChildren[0].__vlist__ = vm._vnode.children;
  }
};
```

## 7. __patch__ 补丁函数

```javascript
// __patch__ - 补丁函数
Vue.prototype.__patch__ = function (oldVnode, vnode, hydrating, removeOnly) {
  // 如果没有 vnode，销毁节点
  if (!vnode) {
    if (oldVnode) invokeDestroyHook(oldVnode);
    return;
  }
  
  const isRealElement = isDef(oldVnode.nodeType);
  
  if (!isRealElement && sameVnode(oldVnode, vnode)) {
    // 相同节点，执行 patch
    patchVnode(oldVnode, vnode);
  } else {
    // 不同节点
    if (isRealElement) {
      // 如果是真实 DOM，创建空 vnode
      oldVnode = emptyNodeAt(oldVnode);
    }
    
    // 获取父节点
    const oldElm = oldVnode.elm;
    const parentElm = nodeOps.parentNode(oldElm);
    
    // 创建新节点
    createElm(
      vnode,
      insertedVnodeQueue,
      oldElm._leaveCb ? null : parentElm,
      nodeOps.nextSibling(oldElm)
    );
    
    // 更新父节点的占位符
    if (isDef(vnode.parent)) {
      let ancestor = vnode.parent;
      const patchable = isPatchable(vnode);
      while (ancestor) {
        for (let i = 0; i < cbs.destroy.length; ++i) {
          cbs.destroy[i](ancestor);
        }
        ancestor.elm = vnode.elm;
        if (patchable) {
          for (let i = 0; i < cbs.create.length; ++i) {
            cbs.create[i](emptyNode, ancestor);
          }
        } else {
          registerRef(ancestor);
        }
        ancestor = ancestor.parent;
      }
    }
    
    // 移除旧节点
    if (isDef(parentElm)) {
      removeVnodes([oldVnode], 0, 0);
    } else if (isDef(oldVnode.tag)) {
      invokeDestroyHook(oldVnode);
    }
  }
  
  // 调用 insert 钩子
  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
  return vnode.elm;
};

// createElm - 创建元素
function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
  if (isDef(vnode.elm) && isDef(ownerArray)) {
    vnode = ownerArray[index] = cloneVNode(vnode);
  }
  
  vnode.isRootInsert = !nested;
  
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
    return;
  }
  
  const data = vnode.data;
  const children = vnode.children;
  const tag = vnode.tag;
  
  if (isDef(tag)) {
    // 创建元素节点
    vnode.elm = nodeOps.createElement(tag, vnode);
    setScope(vnode);
    
    // 创建子节点
    createChildren(vnode, children, insertedVnodeQueue);
    
    // 插入 DOM
    if (isDef(data)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
    }
    insert(parentElm, vnode.elm, refElm);
  } else if (isTrue(vnode.isComment)) {
    // 创建注释节点
    vnode.elm = nodeOps.createComment(vnode.text);
    insert(parentElm, vnode.elm, refElm);
  } else {
    // 创建文本节点
    vnode.elm = nodeOps.createTextNode(vnode.text);
    insert(parentElm, vnode.elm, refElm);
  }
}
```

## 8. 模板编译

```javascript
// compileToFunctions - 编译模板为渲染函数
function compileToFunctions(template, options, vm) {
  options = extend({}, options);
  const warns = [];
  options.warn = warns;
  
  // 检查缓存
  const key = options.delimiters
    ? String(options.delimiters) + template
    : template;
  
  if (cache[key]) {
    return cache[key];
  }
  
  // 编译
  const compiled = compile(template, options);
  
  // 转换为代码
  const res = {};
  const fnGenErrors = [];
  
  res.render = createFunction(compiled.render, fnGenErrors);
  res.staticRenderFns = compiled.staticRenderFns.map(code => {
    return createFunction(code, fnGenErrors);
  });
  
  return (cache[key] = res);
}

// compile - 编译模板
function compile(template, options) {
  const ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  const code = generate(ast, options);
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
}

// parse - 解析模板为 AST
function parse(template, options) {
  const stack = [];
  const root = {
    type: 1,
    tag: 'template',
    attrsList: [],
    attrsMap: {},
    parent: null,
    children: []
  };
  
  parseHTML(template, {
    start(tag, attrs, unary, start) {
      const element = {
        type: 1,
        tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        parent: currentParent,
        children: []
      };
      
      if (currentParent) {
        currentParent.children.push(element);
      }
      
      if (!unary) {
        stack.push(element);
        currentParent = element;
      }
    },
    end(tag, start, end) {
      stack.pop();
      currentParent = stack[stack.length - 1];
    },
    chars(text, start, end) {
      if (!currentParent) return;
      const children = currentParent.children;
      if (text.trim()) {
        children.push({
          type: 3,
          text
        });
      }
    }
  });
  
  return root;
}

// generate - 生成渲染函数代码
function generate(ast, options) {
  const state = new CodegenState(options);
  const code = ast ? genElement(ast, state) : '_c("div")';
  
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  };
}

// genElement - 生成元素代码
function genElement(el, state) {
  if (el.for) {
    return genFor(el, state);
  } else if (el.if) {
    return genIf(el, state);
  } else if (el.tag === 'template') {
    return genChildren(el, state);
  } else {
    let code;
    
    // 生成子节点
    const children = genChildren(el, state);
    
    // 生成属性
    const data = genData(el, state);
    
    // 生成标签
    code = `_c('${el.tag}'${data ? `,${data}` : ''}${children ? `,${children}` : ''})`;
    
    return code;
  }
}
```

## 完整流程示例

```javascript
// 1. 创建 Vue 实例
const vm = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue'
  },
  template: '<div>{{ message }}</div>'
});

// 执行流程：
// 1. new Vue(options)
// 2. this._init(options)
// 3. initLifecycle(vm) - 初始化生命周期
// 4. initEvents(vm) - 初始化事件
// 5. initRender(vm) - 初始化渲染
// 6. callHook(vm, 'beforeCreate') - 调用 beforeCreate 钩子
// 7. initInjections(vm) - 初始化注入
// 8. initState(vm) - 初始化状态
//    - initData(vm) - 初始化 data
//    - observe(data) - 观察数据，创建响应式
//    - proxy(vm, '_data', key) - 代理到实例
// 9. initProvide(vm) - 初始化提供
// 10. callHook(vm, 'created') - 调用 created 钩子
// 11. vm.$mount(vm.$options.el) - 挂载实例
// 12. compileToFunctions(template) - 编译模板
//     - parse(template) - 解析为 AST
//     - optimize(ast) - 优化 AST
//     - generate(ast) - 生成渲染函数代码
// 13. mountComponent(vm, el) - 挂载组件
// 14. callHook(vm, 'beforeMount') - 调用 beforeMount 钩子
// 15. new Watcher(vm, updateComponent) - 创建渲染 watcher
// 16. updateComponent() - 执行更新函数
//     - vm._render() - 执行渲染函数，生成 VNode
//     - vm._update(vnode) - 更新 DOM
//     - vm.__patch__() - 执行补丁算法
//     - createElm(vnode) - 创建真实 DOM
//     - insert(parentElm, vnode.elm) - 插入 DOM
// 17. vm._isMounted = true - 标记为已挂载
// 18. callHook(vm, 'mounted') - 调用 mounted 钩子
// 19. DOM 更新完成，页面显示 <div>Hello Vue</div>
```

## 面试要点

1. **实例挂载的流程**：
   - 初始化配置 → 初始化状态 → 初始化事件 → 初始化渲染
   - 挂载实例 → 渲染模板 → 创建虚拟 DOM → 更新真实 DOM

2. **生命周期钩子的执行时机**：
   - beforeCreate：实例初始化之后，数据观测之前
   - created：实例创建完成，数据观测完成
   - beforeMount：挂载开始之前
   - mounted：挂载完成，DOM 已创建

3. **模板编译的过程**：
   - 解析：将模板解析为 AST
   - 优化：标记静态节点，优化 diff
   - 生成：生成渲染函数代码

4. **渲染函数的作用**：
   - 将模板转换为 VNode
   - 支持动态数据绑定
   - 支持条件渲染和列表渲染

5. **Watcher 的作用**：
   - 监听数据变化
   - 触发视图更新
   - 管理依赖关系

6. **Vue2 的性能优化**：
   - 静态节点标记，避免重复渲染
   - 异步更新，批量处理
   - 虚拟 DOM，减少 DOM 操作

7. **注意事项**：
   - $el 必须在 mounted 之后才能访问
   - 在 beforeCreate 中无法访问 data 和 methods
   - 在 created 中可以访问 data 和 methods，但 DOM 未创建
   - 在 mounted 中可以访问 DOM，但子组件可能未挂载完成