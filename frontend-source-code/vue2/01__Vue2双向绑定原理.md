# Vue2 双向绑定原理

## 核心概念

Vue2 的双向绑定是通过 **数据劫持（Object.defineProperty）** + **发布订阅模式** 实现的。

**核心流程：**
1. Observer：通过 Object.defineProperty 劫持 data 中所有属性，添加 getter/setter
2. Dep：每个属性都有一个依赖收集器（Dep），在 getter 中收集依赖（Watcher）
3. Watcher：当数据变化时，在 setter 中通知 Dep，Dep 通知所有 Watcher 更新视图

## 源码核心实现

### 1. Observer - 数据劫持

```javascript
class Observer {
  constructor(value) {
    this.value = value;
    this.dep = new Dep(); // 为每个对象添加一个 dep
    this.walk(value);
  }

  walk(obj) {
    Object.keys(obj).forEach(key => {
      defineReactive(obj, key, obj[key]);
    });
  }
}

// 核心方法：定义响应式
function defineReactive(obj, key, val) {
  const dep = new Dep(); // 为每个属性创建一个依赖收集器
  
  // 递归处理嵌套对象
  let childOb = observe(val);
  
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      // 依赖收集：在 getter 中收集当前 watcher
      if (Dep.target) {
        dep.depend(); // 将当前 watcher 添加到 dep.subs 中
        if (childOb) {
          childOb.dep.depend(); // 收集子对象的依赖
        }
      }
      return val;
    },
    set(newVal) {
      if (newVal === val) return;
      
      val = newVal;
      childOb = observe(newVal); // 新值也需要响应式化
      
      // 派发更新：通知所有订阅的 watcher
      dep.notify();
    }
  });
}

function observe(value) {
  if (!isObject(value)) return;
  return new Observer(value);
}
```

### 2. Dep - 依赖收集器

```javascript
let uid = 0;

class Dep {
  constructor() {
    this.id = uid++;
    this.subs = []; // 存储所有的 watcher
  }

  addSub(sub) {
    this.subs.push(sub);
  }

  removeSub(sub) {
    const index = this.subs.indexOf(sub);
    if (index > -1) {
      this.subs.splice(index, 1);
    }
  }

  depend() {
    if (Dep.target) {
      Dep.target.addDep(this); // 将当前 dep 添加到 watcher 的依赖中
    }
  }

  notify() {
    // 通知所有订阅的 watcher 更新
    const subs = this.subs.slice();
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  }
}

// 全局变量，存储当前正在计算的 watcher
Dep.target = null;
```

### 3. Watcher - 观察者

```javascript
class Watcher {
  constructor(vm, expOrFn, cb, options) {
    this.vm = vm;
    this.cb = cb; // 回调函数
    this.deps = []; // 依赖的 dep 数组
    this.newDeps = []; // 新收集的 dep 数组
    this.depIds = new Set();
    this.newDepIds = new Set();
    
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
    }
    
    this.value = this.get(); // 立即执行一次，触发依赖收集
  }

  get() {
    // 将当前 watcher 设置为 Dep.target
    pushTarget(this);
    let value;
    try {
      // 执行 getter，触发响应式数据的 getter，进行依赖收集
      value = this.getter.call(this.vm, this.vm);
    } finally {
      popTarget();
      this.cleanupDeps();
    }
    return value;
  }

  addDep(dep) {
    const id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this); // 双向绑定：watcher 订阅 dep
      }
    }
  }

  update() {
    // 异步更新，避免重复渲染
    queueWatcher(this);
  }

  run() {
    const value = this.get();
    if (value !== this.value) {
      const oldValue = this.value;
      this.value = value;
      this.cb.call(this.vm, value, oldValue); // 执行回调
    }
  }
}

// 目标栈，支持嵌套 watcher
const targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
```

## 简化版实现

```javascript
// 简化版 Vue2 响应式系统
class MiniVue {
  constructor(options) {
    this.data = options.data;
    this.observe(this.data);
  }

  observe(data) {
    if (!data || typeof data !== 'object') return;
    
    Object.keys(data).forEach(key => {
      this.defineReactive(data, key, data[key]);
    });
  }

  defineReactive(obj, key, val) {
    const dep = new Dep();
    
    // 递归处理嵌套对象
    this.observe(val);
    
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get() {
        if (Dep.target) {
          dep.depend();
        }
        return val;
      },
      set(newVal) {
        if (newVal === val) return;
        val = newVal;
        dep.notify();
      }
    });
  }
}

class Dep {
  constructor() {
    this.subs = [];
  }

  depend() {
    if (Dep.target) {
      this.subs.push(Dep.target);
    }
  }

  notify() {
    this.subs.forEach(watcher => watcher.update());
  }
}

Dep.target = null;

class Watcher {
  constructor(vm, key, callback) {
    this.vm = vm;
    this.key = key;
    this.callback = callback;
    Dep.target = this;
    this.vm.data[this.key]; // 触发 getter，收集依赖
    Dep.target = null;
  }

  update() {
    this.callback.call(this.vm, this.vm.data[this.key]);
  }
}

// 使用示例
const vm = new MiniVue({
  data: {
    message: 'Hello Vue2'
  }
});

new Watcher(vm, 'message', (value) => {
  console.log('数据变化了:', value);
});

vm.data.message = 'Hello World'; // 输出: 数据变化了: Hello World
```

## 使用场景

1. **表单双向绑定**：v-model 指令实现表单元素与数据的同步
2. **计算属性**：computed 基于响应式数据自动计算
3. **侦听器**：watch 监听数据变化执行回调
4. **组件通信**：props 和 emit 都依赖响应式系统

## 面试要点

1. **Object.defineProperty 的局限性**：
   - 无法监听数组索引和长度的变化
   - 无法监听对象新增/删除属性（需要用 Vue.set/Vue.delete）
   - 必须遍历对象所有属性，性能开销大

2. **依赖收集的时机**：
   - 在组件渲染时创建渲染 watcher
   - 在 computed 计算时创建 computed watcher
   - 在 watch 监听时创建 user watcher

3. **异步更新队列**：
   - 数据变化不会立即更新 DOM
   - 使用 nextTick 将更新操作放入微任务队列
   - 同一个事件循环中的多次数据变化只会触发一次更新

4. **Vue3 的改进**：
   - 使用 Proxy 替代 Object.defineProperty
   - 支持数组索引、对象新增属性
   - 性能更好，不需要遍历所有属性