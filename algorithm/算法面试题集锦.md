# 算法面试题集锦

## 1. 什么是时间复杂度和空间复杂度？

**答案：**

### 时间复杂度

时间复杂度是指算法执行时间随着输入规模增长而增长的趋势。

#### 常见时间复杂度

```javascript
// O(1) - 常数时间
function getFirstElement(arr) {
  return arr[0];
}

// O(log n) - 对数时间
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
}

// O(n) - 线性时间
function findElement(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) return i;
  }
  return -1;
}

// O(n log n) - 线性对数时间
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));
  
  return merge(left, right);
}

// O(n²) - 平方时间
function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}

// O(2ⁿ) - 指数时间
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

### 空间复杂度

空间复杂度是指算法执行过程中所需的存储空间随着输入规模增长而增长的趋势。

```javascript
// O(1) - 常数空间
function sum(arr) {
  let total = 0;
  for (let i = 0; i < arr.length; i++) {
    total += arr[i];
  }
  return total;
}

// O(n) - 线性空间
function reverseArray(arr) {
  const reversed = [];
  for (let i = arr.length - 1; i >= 0; i--) {
    reversed.push(arr[i]);
  }
  return reversed;
}

// O(n²) - 平方空间
function createMatrix(n) {
  const matrix = [];
  for (let i = 0; i < n; i++) {
    matrix[i] = [];
    for (let j = 0; j < n; j++) {
      matrix[i][j] = i * j;
    }
  }
  return matrix;
}
```

### 复杂度对比

| 复杂度 | 描述 | 示例 |
|--------|------|------|
| O(1) | 常数时间 | 数组访问 |
| O(log n) | 对数时间 | 二分查找 |
| O(n) | 线性时间 | 线性查找 |
| O(n log n) | 线性对数时间 | 归并排序 |
| O(n²) | 平方时间 | 冒泡排序 |
| O(2ⁿ) | 指数时间 | 递归斐波那契 |

---

## 2. 数组去重有哪些方法？

**答案：**

### 方法 1：使用 Set

```javascript
function uniqueArray(arr) {
  return [...new Set(arr)];
}

const arr = [1, 2, 2, 3, 3, 4];
console.log(uniqueArray(arr)); // [1, 2, 3, 4]
```

### 方法 2：使用 filter 和 indexOf

```javascript
function uniqueArray(arr) {
  return arr.filter((item, index) => arr.indexOf(item) === index);
}

const arr = [1, 2, 2, 3, 3, 4];
console.log(uniqueArray(arr)); // [1, 2, 3, 4]
```

### 方法 3：使用 reduce

```javascript
function uniqueArray(arr) {
  return arr.reduce((unique, item) => {
    return unique.includes(item) ? unique : [...unique, item];
  }, []);
}

const arr = [1, 2, 2, 3, 3, 4];
console.log(uniqueArray(arr)); // [1, 2, 3, 4]
```

### 方法 4：使用 Map

```javascript
function uniqueArray(arr) {
  const map = new Map();
  return arr.filter(item => !map.has(item) && map.set(item, 1));
}

const arr = [1, 2, 2, 3, 3, 4];
console.log(uniqueArray(arr)); // [1, 2, 3, 4]
```

### 方法 5：对象去重（根据属性）

```javascript
function uniqueArrayByKey(arr, key) {
  const map = new Map();
  return arr.filter(item => !map.has(item[key]) && map.set(item[key], 1));
}

const users = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' },
  { id: 1, name: 'John' }
];
console.log(uniqueArrayByKey(users, 'id'));
// [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }]
```

---

## 3. 如何判断一个字符串是否是回文？

**答案：**

### 方法 1：反转字符串

```javascript
function isPalindrome(str) {
  const reversed = str.split('').reverse().join('');
  return str === reversed;
}

console.log(isPalindrome('racecar')); // true
console.log(isPalindrome('hello')); // false
```

### 方法 2：双指针

```javascript
function isPalindrome(str) {
  let left = 0;
  let right = str.length - 1;
  
  while (left < right) {
    if (str[left] !== str[right]) {
      return false;
    }
    left++;
    right--;
  }
  return true;
}

console.log(isPalindrome('racecar')); // true
console.log(isPalindrome('hello')); // false
```

### 方法 3：忽略大小写和非字母字符

```javascript
function isPalindrome(str) {
  const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');
  return cleaned === cleaned.split('').reverse().join('');
}

console.log(isPalindrome('A man, a plan, a canal: Panama')); // true
console.log(isPalindrome('race a car')); // false
```

---

## 4. 如何找出数组中的最大值和最小值？

**答案：**

### 方法 1：使用 Math.max 和 Math.min

```javascript
function findMinMax(arr) {
  return {
    max: Math.max(...arr),
    min: Math.min(...arr)
  };
}

const arr = [1, 5, 3, 9, 2];
console.log(findMinMax(arr)); // { max: 9, min: 1 }
```

### 方法 2：遍历数组

```javascript
function findMinMax(arr) {
  if (arr.length === 0) return { max: null, min: null };
  
  let max = arr[0];
  let min = arr[0];
  
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) max = arr[i];
    if (arr[i] < min) min = arr[i];
  }
  
  return { max, min };
}

const arr = [1, 5, 3, 9, 2];
console.log(findMinMax(arr)); // { max: 9, min: 1 }
```

### 方法 3：使用 reduce

```javascript
function findMinMax(arr) {
  return arr.reduce((acc, val) => ({
    max: Math.max(acc.max, val),
    min: Math.min(acc.min, val)
  }), { max: -Infinity, min: Infinity });
}

const arr = [1, 5, 3, 9, 2];
console.log(findMinMax(arr)); // { max: 9, min: 1 }
```

---

## 5. 如何实现斐波那契数列？

**答案：**

### 方法 1：递归

```javascript
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(10)); // 55
// 时间复杂度：O(2ⁿ)
// 空间复杂度：O(n)
```

### 方法 2：递归 + 缓存（记忆化）

```javascript
function fibonacci(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 1) return n;
  
  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);
  return memo[n];
}

console.log(fibonacci(10)); // 55
// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

### 方法 3：迭代

```javascript
function fibonacci(n) {
  if (n <= 1) return n;
  
  let a = 0;
  let b = 1;
  
  for (let i = 2; i <= n; i++) {
    const temp = a + b;
    a = b;
    b = temp;
  }
  
  return b;
}

console.log(fibonacci(10)); // 55
// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 方法 4：动态规划

```javascript
function fibonacci(n) {
  const dp = [0, 1];
  
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  
  return dp[n];
}

console.log(fibonacci(10)); // 55
// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

---

## 6. 如何实现快速排序？

**答案：**

```javascript
function quickSort(arr) {
  if (arr.length <= 1) return arr;
  
  const pivot = arr[Math.floor(arr.length / 2)];
  const left = [];
  const right = [];
  const equal = [];
  
  for (const item of arr) {
    if (item < pivot) {
      left.push(item);
    } else if (item > pivot) {
      right.push(item);
    } else {
      equal.push(item);
    }
  }
  
  return [...quickSort(left), ...equal, ...quickSort(right)];
}

const arr = [3, 6, 8, 10, 1, 2, 1];
console.log(quickSort(arr)); // [1, 1, 2, 3, 6, 8, 10]
// 时间复杂度：平均 O(n log n)，最坏 O(n²)
// 空间复杂度：O(log n)
```

### 原地快速排序

```javascript
function quickSortInPlace(arr, left = 0, right = arr.length - 1) {
  if (left >= right) return;
  
  const pivotIndex = partition(arr, left, right);
  quickSortInPlace(arr, left, pivotIndex - 1);
  quickSortInPlace(arr, pivotIndex + 1, right);
}

function partition(arr, left, right) {
  const pivot = arr[right];
  let i = left;
  
  for (let j = left; j < right; j++) {
    if (arr[j] < pivot) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      i++;
    }
  }
  
  [arr[i], arr[right]] = [arr[right], arr[i]];
  return i;
}

const arr = [3, 6, 8, 10, 1, 2, 1];
quickSortInPlace(arr);
console.log(arr); // [1, 1, 2, 3, 6, 8, 10]
```

---

## 7. 如何实现二分查找？

**答案：**

```javascript
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return -1;
}

const arr = [1, 3, 5, 7, 9, 11, 13];
console.log(binarySearch(arr, 7)); // 3
console.log(binarySearch(arr, 8)); // -1
// 时间复杂度：O(log n)
// 空间复杂度：O(1)
```

### 递归实现

```javascript
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
  if (left > right) return -1;
  
  const mid = Math.floor((left + right) / 2);
  
  if (arr[mid] === target) {
    return mid;
  } else if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, right);
  } else {
    return binarySearchRecursive(arr, target, left, mid - 1);
  }
}

const arr = [1, 3, 5, 7, 9, 11, 13];
console.log(binarySearchRecursive(arr, 7)); // 3
```

---

## 8. 如何实现深拷贝？

**答案：**

### 方法 1：JSON 序列化

```javascript
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

const obj = {
  name: 'John',
  age: 30,
  address: {
    city: 'New York',
    country: 'USA'
  }
};

const cloned = deepClone(obj);
console.log(cloned); // { name: 'John', age: 30, address: { city: 'New York', country: 'USA' } }

// 缺点：无法拷贝函数、Symbol、undefined
```

### 方法 2：递归

```javascript
function deepClone(obj, hash = new WeakMap()) {
  // 处理基本类型和 null
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理循环引用
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  // 处理日期
  if (obj instanceof Date) {
    return new Date(obj);
  }
  
  // 处理正则
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  
  // 处理数组
  if (Array.isArray(obj)) {
    const cloned = [];
    hash.set(obj, cloned);
    for (const item of obj) {
      cloned.push(deepClone(item, hash));
    }
    return cloned;
  }
  
  // 处理对象
  const cloned = {};
  hash.set(obj, cloned);
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone(obj[key], hash);
    }
  }
  
  return cloned;
}

const obj = {
  name: 'John',
  age: 30,
  address: {
    city: 'New York',
    country: 'USA'
  },
  hobbies: ['reading', 'coding']
};

const cloned = deepClone(obj);
console.log(cloned);
```

### 方法 3：使用 structuredClone（现代浏览器）

```javascript
function deepClone(obj) {
  return structuredClone(obj);
}

const obj = {
  name: 'John',
  age: 30,
  address: {
    city: 'New York',
    country: 'USA'
  }
};

const cloned = deepClone(obj);
console.log(cloned);
```

---

## 9. 如何实现防抖和节流？

**答案：**

### 防抖（Debounce）

```javascript
function debounce(func, delay) {
  let timer = null;
  
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// 使用
const debouncedSearch = debounce((keyword) => {
  console.log('Search:', keyword);
}, 300);

debouncedSearch('a');
debouncedSearch('ab');
debouncedSearch('abc'); // 只执行最后一次
```

### 节流（Throttle）

```javascript
function throttle(func, delay) {
  let timer = null;
  let lastTime = 0;
  
  return function(...args) {
    const now = Date.now();
    
    if (now - lastTime >= delay) {
      func.apply(this, args);
      lastTime = now;
    } else if (!timer) {
      timer = setTimeout(() => {
        func.apply(this, args);
        lastTime = Date.now();
        timer = null;
      }, delay - (now - lastTime));
    }
  };
}

// 使用
const throttledScroll = throttle(() => {
  console.log('Scroll');
}, 300);

window.addEventListener('scroll', throttledScroll);
```

### 应用场景

**防抖：**
- 搜索框输入
- 窗口大小调整
- 表单验证

**节流：**
- 滚动事件
- 鼠标移动
- 按钮点击

---

## 10. 如何实现一个简单的 LRU 缓存？

**答案：**

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }

    // 删除并重新添加，使其成为最近使用的
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  put(key, value) {
    // 如果已存在，先删除
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }

    // 如果超出容量，删除最久未使用的
    if (this.cache.size >= this.capacity) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    this.cache.set(key, value);
  }
}

// 使用
const cache = new LRUCache(2);

cache.put(1, 1);
cache.put(2, 2);
console.log(cache.get(1)); // 1
cache.put(3, 3); // 删除 key 2
console.log(cache.get(2)); // -1
console.log(cache.get(3)); // 3
console.log(cache.get(1)); // 1
cache.put(4, 4); // 删除 key 1
console.log(cache.get(1)); // -1
console.log(cache.get(3)); // 3
console.log(cache.get(4)); // 4
```

---

## 总结

算法面试题是前端面试中的重要部分，重点掌握：

1. **时间复杂度和空间复杂度**：O(1)、O(n)、O(log n)、O(n²)
2. **常用算法**：排序、查找、递归、动态规划
3. **常用数据结构**：数组、对象、Map、Set、栈、队列
4. **实际应用**：防抖、节流、深拷贝、缓存

**练习建议：**
- 多刷 LeetCode
- 理解算法原理
- 注意边界条件
- 优化时间和空间复杂度