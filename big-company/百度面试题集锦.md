# 百度面试题集锦（截止 2025 年底）

## 目录
1. [前端基础](#前端基础)
2. [算法题](#算法题)
3. [场景题](#场景题)

---

## 前端基础

### 1. 谈谈你对浏览器渲染原理的理解

**答案：**

**浏览器渲染流程：**

```
1. 解析 HTML → 构建 DOM 树
2. 解析 CSS → 构建 CSSOM 树
3. 合并 DOM 和 CSSOM → 构建 Render 树
4. 布局（Layout）→ 计算元素位置和大小
5. 绘制（Paint）→ 填充像素
6. 合成（Composite）→ 将图层合成到屏幕
```

**详细过程：**

```javascript
// 1. DOM 树构建
// 浏览器将 HTML 解析为 DOM 树
// <div><p>Hello</p></div>
// → DIV
//    └── P
//         └── "Hello"

// 2. CSSOM 树构建
// 浏览器将 CSS 解析为 CSSOM 树
// div { color: red; }
// p { font-size: 16px; }
// → DIV
//    ├── color: red
//    └── P
//         ├── font-size: 16px
//         └── color: red (继承)

// 3. Render 树构建
// 合并 DOM 和 CSSOM，只包含可见元素
// → DIV
//    └── P (visible)

// 4. 布局（Layout/Reflow）
// 计算每个元素的位置和大小
function layout(element) {
  // 计算元素的几何属性
  const width = element.computedStyle.width;
  const height = element.computedStyle.height;
  const x = element.parent.x + element.computedStyle.marginLeft;
  const y = element.parent.y + element.computedStyle.marginTop;
  
  element.layout = { x, y, width, height };
  
  // 递归布局子元素
  for (const child of element.children) {
    layout(child);
  }
}

// 5. 绘制（Paint）
// 将元素绘制到图层
function paint(element, layer) {
  const { x, y, width, height } = element.layout;
  
  // 绘制背景
  if (element.computedStyle.backgroundColor) {
    layer.fillRect(x, y, width, height, element.computedStyle.backgroundColor);
  }
  
  // 绘制边框
  if (element.computedStyle.border) {
    layer.strokeRect(x, y, width, height, element.computedStyle.border);
  }
  
  // 绘制文本
  if (element.textContent) {
    layer.fillText(element.textContent, x, y, element.computedStyle);
  }
  
  // 递归绘制子元素
  for (const child of element.children) {
    paint(child, layer);
  }
}

// 6. 合成（Composite）
// 将多个图层合成到屏幕
function composite(layers) {
  for (const layer of layers) {
    // 将图层绘制到屏幕
    screen.drawImage(layer);
  }
}
```

**重排（Reflow）和重绘（Repaint）：**

```javascript
// 重排：元素位置或大小变化
// 触发重排的操作：
function triggerReflow() {
  // 1. 添加/删除可见 DOM 元素
  document.body.appendChild(div);
  
  // 2. 改变元素位置
  element.style.left = '100px';
  element.style.top = '100px';
  
  // 3. 改变元素尺寸
  element.style.width = '200px';
  element.style.height = '200px';
  
  // 4. 改变元素内容
  element.textContent = 'New content';
  
  // 5. 改变浏览器窗口大小
  window.onresize = () => {
    // 触发重排
  };
  
  // 6. 读取某些属性（强制同步布局）
  const height = element.offsetHeight; // 触发重排
  const width = element.offsetWidth;
  const scrollTop = element.scrollTop;
}

// 重绘：元素外观变化但位置不变
// 触发重绘的操作：
function triggerRepaint() {
  // 1. 改变颜色
  element.style.color = 'red';
  element.style.backgroundColor = 'blue';
  
  // 2. 改变背景
  element.style.backgroundImage = 'url(...)';
  
  // 3. 改变边框
  element.style.border = '1px solid red';
  
  // 4. 改变阴影
  element.style.boxShadow = '0 0 10px black';
}
```

---

### 2. 如何实现一个前端构建工具（类似 Webpack）？

**答案：**

```javascript
// 简化版 Webpack
class MiniWebpack {
  constructor(options) {
    this.entry = options.entry;
    this.output = options.output;
    this.modules = [];
  }
  
  // 解析文件
  parse(filename) {
    const content = fs.readFileSync(filename, 'utf-8');
    
    // 解析依赖
    const dependencies = [];
    const ast = parser.parse(content, {
      sourceType: 'module',
    });
    
    traverse(ast, {
      ImportDeclaration({ node }) {
        dependencies.push(node.source.value);
      },
    });
    
    // 转换代码
    const { code } = babel.transformFromAst(ast, null, {
      presets: ['@babel/preset-env'],
    });
    
    return {
      filename,
      dependencies,
      code,
    };
  }
  
  // 构建依赖图
  buildDependencyGraph(entry) {
    const entryModule = this.parse(entry);
    const queue = [entryModule];
    
    for (const module of queue) {
      const dirname = path.dirname(module.filename);
      
      module.dependencies.forEach(relativePath => {
        const absolutePath = path.join(dirname, relativePath);
        const child = this.parse(absolutePath);
        this.modules.push(child);
        queue.push(child);
      });
    }
  }
  
  // 生成代码
  generate() {
    const modulesStr = this.modules
      .map(module => {
        return `${JSON.stringify(module.filename)}: function(module, exports, require) {
          ${module.code}
        }`;
      })
      .join(',\n');
    
    return `
      (function(modules) {
        const installedModules = {};
        
        function require(filename) {
          if (installedModules[filename]) {
            return installedModules[filename].exports;
          }
          
          const module = installedModules[filename] = {
            exports: {},
          };
          
          modules[filename](module, module.exports, require);
          
          return module.exports;
        }
        
        require('${this.entry}');
      })({
        ${modulesStr}
      });
    `;
  }
  
  // 运行
  run() {
    this.buildDependencyGraph(this.entry);
    const code = this.generate();
    
    fs.writeFileSync(this.output.path, code);
  }
}
```

---

## 算法题

### 3. 实现一个快速排序

**答案：**

```javascript
// 快速排序
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  
  const pivot = arr[0];
  const left = [];
  const right = [];
  
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  
  return [...quickSort(left), pivot, ...quickSort(right)];
}

// 原地快速排序（优化空间）
function quickSortInPlace(arr, left = 0, right = arr.length - 1) {
  if (left >= right) {
    return;
  }
  
  const pivotIndex = partition(arr, left, right);
  
  quickSortInPlace(arr, left, pivotIndex - 1);
  quickSortInPlace(arr, pivotIndex + 1, right);
}

function partition(arr, left, right) {
  const pivot = arr[right];
  let i = left;
  
  for (let j = left; j < right; j++) {
    if (arr[j] < pivot) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      i++;
    }
  }
  
  [arr[i], arr[right]] = [arr[right], arr[i]];
  return i;
}

// 优化：三路快速排序（处理重复元素）
function quickSort3Way(arr, left = 0, right = arr.length - 1) {
  if (left >= right) {
    return;
  }
  
  let pivot = arr[left];
  let lt = left;     // 小于 pivot 的边界
  let gt = right;    // 大于 pivot 的边界
  let i = left + 1;  // 当前元素
  
  while (i <= gt) {
    if (arr[i] < pivot) {
      [arr[i], arr[lt]] = [arr[lt], arr[i]];
      lt++;
      i++;
    } else if (arr[i] > pivot) {
      [arr[i], arr[gt]] = [arr[gt], arr[i]];
      gt--;
    } else {
      i++;
    }
  }
  
  quickSort3Way(arr, left, lt - 1);
  quickSort3Way(arr, gt + 1, right);
}
```

---

### 4. 实现一个节流函数

**答案：**

```javascript
// 基础节流
function throttle(fn, delay) {
  let lastCall = 0;
  
  return function(...args) {
    const now = Date.now();
    
    if (now - lastCall >= delay) {
      fn.apply(this, args);
      lastCall = now;
    }
  };
}

// 支持立即执行和尾随调用
function throttle(fn, delay, options = {}) {
  const { leading = true, trailing = true } = options;
  let timer = null;
  let lastCall = 0;
  
  return function(...args) {
    const now = Date.now();
    const context = this;
    
    // 首次调用
    if (!lastCall && !leading) {
      lastCall = now;
    }
    
    const remaining = delay - (now - lastCall);
    
    if (remaining <= 0) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      
      lastCall = now;
      fn.apply(context, args);
    } else if (!timer && trailing) {
      timer = setTimeout(() => {
        lastCall = leading ? Date.now() : 0;
        timer = null;
        fn.apply(context, args);
      }, remaining);
    }
  };
}

// 使用示例
const throttledScroll = throttle(function() {
  console.log('滚动事件');
}, 100);

window.addEventListener('scroll', throttledScroll);
```

---

## 场景题

### 5. 如何实现一个虚拟滚动列表？

**答案：**

```javascript
class VirtualList extends React.Component {
  state = {
    visibleStart: 0,
    visibleEnd: 10
  };
  
  containerRef = React.createRef();
  
  componentDidMount() {
    this.containerRef.current.addEventListener('scroll', this.handleScroll);
  }
  
  componentWillUnmount() {
    this.containerRef.current.removeEventListener('scroll', this.handleScroll);
  }
  
  handleScroll = () => {
    const container = this.containerRef.current;
    const scrollTop = container.scrollTop;
    const itemHeight = 50;
    const visibleCount = Math.ceil(container.clientHeight / itemHeight);
    
    const start = Math.floor(scrollTop / itemHeight);
    const end = start + visibleCount;
    
    this.setState({
      visibleStart: start,
      visibleEnd: end
    });
  };
  
  render() {
    const { items, itemHeight = 50 } = this.props;
    const { visibleStart, visibleEnd } = this.state;
    
    const visibleItems = items.slice(visibleStart, visibleEnd);
    const totalHeight = items.length * itemHeight;
    const offsetY = visibleStart * itemHeight;
    
    return (
      <div
        ref={this.containerRef}
        style={{
          height: '500px',
          overflow: 'auto'
        }}
      >
        <div style={{ height: totalHeight, position: 'relative' }}>
          <div
            style={{
              transform: `translateY(${offsetY}px)`,
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0
            }}
          >
            {visibleItems.map((item, index) => (
              <div
                key={index}
                style={{
                  height: itemHeight,
                  boxSizing: 'border-box',
                  padding: '10px',
                  borderBottom: '1px solid #eee'
                }}
              >
                {item}
              </div>
            ))}
          </div>
        </div>
      </div>
    );
  }
}
```

---

### 6. 如何实现一个前端日志系统？

**答案：**

```javascript
class Logger {
  constructor(options = {}) {
    this.options = {
      level: 'info',
      maxLogs: 100,
      enableConsole: true,
      enableStorage: true,
      enableRemote: false,
      remoteUrl: '',
      ...options
    };
    
    this.logs = [];
    this.init();
  }
  
  init() {
    if (this.options.enableStorage) {
      const savedLogs = localStorage.getItem('logs');
      if (savedLogs) {
        this.logs = JSON.parse(savedLogs);
      }
    }
    
    window.addEventListener('error', this.handleError.bind(this));
    window.addEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this));
  }
  
  handleError(event) {
    this.error('Error:', {
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack
    });
  }
  
  handleUnhandledRejection(event) {
    this.error('Unhandled Rejection:', {
      reason: event.reason,
      promise: event.promise
    });
  }
  
  log(message, data) {
    this.addLog('log', message, data);
  }
  
  info(message, data) {
    this.addLog('info', message, data);
  }
  
  warn(message, data) {
    this.addLog('warn', message, data);
  }
  
  error(message, data) {
    this.addLog('error', message, data);
  }
  
  addLog(level, message, data) {
    const log = {
      level,
      message,
      data,
      timestamp: new Date().toISOString(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };
    
    this.logs.push(log);
    
    if (this.logs.length > this.options.maxLogs) {
      this.logs.shift();
    }
    
    if (this.options.enableStorage) {
      localStorage.setItem('logs', JSON.stringify(this.logs));
    }
    
    if (this.options.enableConsole) {
      console[level](message, data);
    }
    
    if (this.options.enableRemote && this.options.remoteUrl) {
      this.sendToRemote(log);
    }
  }
  
  sendToRemote(log) {
    fetch(this.options.remoteUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(log)
    }).catch(error => {
      console.error('Failed to send log to remote:', error);
    });
  }
  
  getLogs() {
    return this.logs;
  }
  
  clearLogs() {
    this.logs = [];
    if (this.options.enableStorage) {
      localStorage.removeItem('logs');
    }
  }
  
  exportLogs() {
    const data = JSON.stringify(this.logs, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `logs-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }
}
```

---

### 7. 如何实现一个前端监控 SDK？

**答案：**

```javascript
class MonitorSDK {
  constructor(options = {}) {
    this.options = {
      appId: '',
      userId: '',
      enablePerformance: true,
      enableError: true,
      enableBehavior: false,
      reportUrl: '',
      sampleRate: 1,
      ...options
    };
    
    this.init();
  }
  
  init() {
    if (this.options.enablePerformance) {
      this.initPerformanceMonitor();
    }
    
    if (this.options.enableError) {
      this.initErrorMonitor();
    }
    
    if (this.options.enableBehavior) {
      this.initBehaviorMonitor();
    }
    
    setInterval(() => this.report(), 30000);
  }
  
  initPerformanceMonitor() {
    window.addEventListener('load', () => {
      const timing = performance.timing;
      const perfData = {
        type: 'performance',
        data: {
          dns: timing.domainLookupEnd - timing.domainLookupStart,
          tcp: timing.connectEnd - timing.connectStart,
          request: timing.responseEnd - timing.requestStart,
          dom: timing.domComplete - timing.domLoading,
          whiteScreen: timing.responseStart - timing.fetchStart,
          firstScreen: timing.domContentLoadedEventEnd - timing.fetchStart,
          loadPage: timing.loadEventEnd - timing.fetchStart
        }
      };
      this.collect(perfData);
    });
    
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        if (entry.entryType === 'resource') {
          this.collect({
            type: 'resource',
            data: {
              name: entry.name,
              duration: entry.duration,
              size: entry.transferSize,
              type: entry.initiatorType
            }
          });
        }
      });
    });
    
    observer.observe({ entryTypes: ['resource'] });
  }
  
  initErrorMonitor() {
    window.addEventListener('error', (event) => {
      this.collect({
        type: 'error',
        data: {
          message: event.message,
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno,
          stack: event.error?.stack
        }
      });
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      this.collect({
        type: 'promise',
        data: {
          reason: event.reason,
          promise: event.promise
        }
      });
    });
    
    window.addEventListener('error', (event) => {
      if (event.target !== window) {
        this.collect({
          type: 'resource-error',
          data: {
            tagName: event.target.tagName,
            src: event.target.src || event.target.href
          }
        });
      }
    }, true);
  }
  
  initBehaviorMonitor() {
    document.addEventListener('click', (event) => {
      const target = event.target;
      this.collect({
        type: 'click',
        data: {
          tagName: target.tagName,
          className: target.className,
          id: target.id,
          text: target.textContent?.slice(0, 50)
        }
      });
    });
    
    this.collect({
      type: 'pageview',
      data: {
        url: window.location.href,
        referrer: document.referrer
      }
    });
  }
  
  collect(data) {
    if (Math.random() > this.options.sampleRate) {
      return;
    }
    
    const reportData = {
      appId: this.options.appId,
      userId: this.options.userId,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      ...data
    };
    
    this.queue = this.queue || [];
    this.queue.push(reportData);
  }
  
  report() {
    if (!this.queue || this.queue.length === 0) {
      return;
    }
    
    const data = this.queue;
    this.queue = [];
    
    fetch(this.options.reportUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    }).catch(error => {
      console.error('Failed to report data:', error);
      this.queue = [...data, ...this.queue];
    });
  }
}
```

---

### 8. 如何实现一个前端缓存系统？

**答案：**

```javascript
class CacheSystem {
  constructor(options = {}) {
    this.options = {
      storage: 'localStorage',
      prefix: 'cache_',
      ttl: 3600000,
      ...options
    };
    
    this.cache = new Map();
    this.init();
  }
  
  init() {
    if (this.options.storage === 'localStorage') {
      this.loadFromStorage();
    }
  }
  
  set(key, value, ttl = this.options.ttl) {
    const item = {
      value,
      expire: Date.now() + ttl
    };
    
    if (this.options.storage === 'localStorage') {
      localStorage.setItem(this.options.prefix + key, JSON.stringify(item));
    } else if (this.options.storage === 'sessionStorage') {
      sessionStorage.setItem(this.options.prefix + key, JSON.stringify(item));
    } else {
      this.cache.set(key, item);
    }
  }
  
  get(key) {
    let item;
    
    if (this.options.storage === 'localStorage') {
      const data = localStorage.getItem(this.options.prefix + key);
      item = data ? JSON.parse(data) : null;
    } else if (this.options.storage === 'sessionStorage') {
      const data = sessionStorage.getItem(this.options.prefix + key);
      item = data ? JSON.parse(data) : null;
    } else {
      item = this.cache.get(key);
    }
    
    if (item && item.expire < Date.now()) {
      this.delete(key);
      return null;
    }
    
    return item ? item.value : null;
  }
  
  delete(key) {
    if (this.options.storage === 'localStorage') {
      localStorage.removeItem(this.options.prefix + key);
    } else if (this.options.storage === 'sessionStorage') {
      sessionStorage.removeItem(this.options.prefix + key);
    } else {
      this.cache.delete(key);
    }
  }
  
  clear() {
    if (this.options.storage === 'localStorage') {
      const keys = Object.keys(localStorage);
      keys.forEach(key => {
        if (key.startsWith(this.options.prefix)) {
          localStorage.removeItem(key);
        }
      });
    } else if (this.options.storage === 'sessionStorage') {
      const keys = Object.keys(sessionStorage);
      keys.forEach(key => {
        if (key.startsWith(this.options.prefix)) {
          sessionStorage.removeItem(key);
        }
      });
    } else {
      this.cache.clear();
    }
  }
  
  cleanup() {
    const now = Date.now();
    
    if (this.options.storage === 'localStorage') {
      const keys = Object.keys(localStorage);
      keys.forEach(key => {
        if (key.startsWith(this.options.prefix)) {
          const data = localStorage.getItem(key);
          const item = JSON.parse(data);
          if (item && item.expire < now) {
            localStorage.removeItem(key);
          }
        }
      });
    } else if (this.options.storage === 'sessionStorage') {
      const keys = Object.keys(sessionStorage);
      keys.forEach(key => {
        if (key.startsWith(this.options.prefix)) {
          const data = sessionStorage.getItem(key);
          const item = JSON.parse(data);
          if (item && item.expire < now) {
            sessionStorage.removeItem(key);
          }
        }
      });
    } else {
      this.cache.forEach((item, key) => {
        if (item.expire < now) {
          this.cache.delete(key);
        }
      });
    }
  }
  
  loadFromStorage() {
    const keys = Object.keys(localStorage);
    keys.forEach(key => {
      if (key.startsWith(this.options.prefix)) {
        const data = localStorage.getItem(key);
        const item = JSON.parse(data);
        this.cache.set(key.slice(this.options.prefix.length), item);
      }
    });
  }
}
```

### 9. 如何设计一个大规模数据可视化的前端方案？

**答案：**

大规模数据可视化需要考虑性能、交互、可扩展性等多个方面。

**方案设计：**

**方案 1：基于 Canvas 的数据可视化**
```javascript
class CanvasDataVisualization {
  constructor(canvas, data) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.data = data;
    this.visibleData = [];
    this.offsetX = 0;
    this.offsetY = 0;
    this.scale = 1;
    this.isDragging = false;
    this.lastMouseX = 0;
    this.lastMouseY = 0;
    
    this.init();
  }
  
  init() {
    // 设置 Canvas 大小
    this.resizeCanvas();
    window.addEventListener('resize', () => this.resizeCanvas());
    
    // 初始化交互
    this.initInteractions();
    
    // 初始渲染
    this.render();
  }
  
  resizeCanvas() {
    const container = this.canvas.parentElement;
    this.canvas.width = container.clientWidth;
    this.canvas.height = container.clientHeight;
    this.render();
  }
  
  initInteractions() {
    // 鼠标拖拽
    this.canvas.addEventListener('mousedown', (e) => {
      this.isDragging = true;
      this.lastMouseX = e.clientX;
      this.lastMouseY = e.clientY;
    });
    
    this.canvas.addEventListener('mousemove', (e) => {
      if (this.isDragging) {
        const dx = e.clientX - this.lastMouseX;
        const dy = e.clientY - this.lastMouseY;
        this.offsetX += dx;
        this.offsetY += dy;
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        this.render();
      }
    });
    
    this.canvas.addEventListener('mouseup', () => {
      this.isDragging = false;
    });
    
    // 滚轮缩放
    this.canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      this.scale *= zoomFactor;
      this.render();
    });
  }
  
  render() {
    // 清空画布
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // 计算可见区域
    const visibleStart = Math.floor(-this.offsetY / this.scale);
    const visibleEnd = visibleStart + Math.ceil(this.canvas.height / this.scale) + 1;
    
    // 只渲染可见区域的数据
    this.visibleData = this.data.slice(Math.max(0, visibleStart), visibleEnd);
    
    // 绘制数据点
    this.visibleData.forEach((point, index) => {
      const x = point.x * this.scale + this.offsetX;
      const y = point.y * this.scale + this.offsetY;
      
      // 绘制点
      this.ctx.beginPath();
      this.ctx.arc(x, y, 3 * this.scale, 0, Math.PI * 2);
      this.ctx.fillStyle = point.color || '#1890ff';
      this.ctx.fill();
      
      // 绘制标签
      if (this.scale > 1) {
        this.ctx.font = `${12 * this.scale}px Arial`;
        this.ctx.fillStyle = '#333';
        this.ctx.fillText(point.label, x + 5 * this.scale, y);
      }
    });
    
    // 绘制坐标轴
    this.drawAxes();
  }
  
  drawAxes() {
    const padding = 50 * this.scale;
    
    // X 轴
    this.ctx.beginPath();
    this.ctx.moveTo(padding, this.canvas.height - padding);
    this.ctx.lineTo(this.canvas.width - padding, this.canvas.height - padding);
    this.ctx.strokeStyle = '#333';
    this.ctx.lineWidth = 2 * this.scale;
    this.ctx.stroke();
    
    // Y 轴
    this.ctx.beginPath();
    this.ctx.moveTo(padding, padding);
    this.ctx.lineTo(padding, this.canvas.height - padding);
    this.ctx.strokeStyle = '#333';
    this.ctx.lineWidth = 2 * this.scale;
    this.ctx.stroke();
  }
}
```

**方案 2：基于 WebGL 的高性能渲染**
```javascript
class WebGLDataVisualization {
  constructor(canvas, data) {
    this.canvas = canvas;
    this.gl = canvas.getContext('webgl');
    this.data = data;
    this.program = null;
    this.positionBuffer = null;
    this.colorBuffer = null;
    
    this.init();
  }
  
  init() {
    // 创建着色器程序
    this.createShaders();
    this.createProgram();
    
    // 创建缓冲区
    this.createBuffers();
    
    // 设置视口
    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    
    // 渲染
    this.render();
  }
  
  createShaders() {
    // 顶点着色器
    const vertexShaderSource = `
      attribute vec2 a_position;
      attribute vec3 a_color;
      uniform vec2 u_resolution;
      uniform vec2 u_offset;
      uniform float u_scale;
      varying vec3 v_color;
      
      void main() {
        vec2 position = (a_position * u_scale + u_offset) / u_resolution * 2.0 - 1.0;
        gl_Position = vec4(position, 0.0, 1.0);
        gl_PointSize = 5.0;
        v_color = a_color;
      }
    `;
    
    // 片段着色器
    const fragmentShaderSource = `
      precision mediump float;
      varying vec3 v_color;
      
      void main() {
        gl_FragColor = vec4(v_color, 1.0);
      }
    `;
    
    this.vertexShader = this.compileShader(this.gl.VERTEX_SHADER, vertexShaderSource);
    this.fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
  }
  
  compileShader(type, source) {
    const shader = this.gl.createShader(type);
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
      this.gl.deleteShader(shader);
      return null;
    }
    
    return shader;
  }
  
  createProgram() {
    this.program = this.gl.createProgram();
    this.gl.attachShader(this.program, this.vertexShader);
    this.gl.attachShader(this.program, this.fragmentShader);
    this.gl.linkProgram(this.program);
    
    if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
      console.error('Program link error:', this.gl.getProgramInfoLog(this.program));
      return;
    }
    
    this.gl.useProgram(this.program);
  }
  
  createBuffers() {
    // 位置缓冲区
    this.positionBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
    
    const positions = this.data.map(point => [point.x, point.y]).flat();
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
    
    const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
    this.gl.enableVertexAttribArray(positionLocation);
    this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
    
    // 颜色缓冲区
    this.colorBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
    
    const colors = this.data.map(point => {
      const color = point.color || [0.1, 0.57, 1.0];
      return color;
    }).flat();
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);
    
    const colorLocation = this.gl.getAttribLocation(this.program, 'a_color');
    this.gl.enableVertexAttribArray(colorLocation);
    this.gl.vertexAttribPointer(colorLocation, 3, this.gl.FLOAT, false, 0, 0);
  }
  
  render() {
    this.gl.clearColor(1.0, 1.0, 1.0, 1.0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    
    // 设置 uniform 变量
    const resolutionLocation = this.gl.getUniformLocation(this.program, 'u_resolution');
    this.gl.uniform2f(resolutionLocation, this.canvas.width, this.canvas.height);
    
    const offsetLocation = this.gl.getUniformLocation(this.program, 'u_offset');
    this.gl.uniform2f(offsetLocation, 0, 0);
    
    const scaleLocation = this.gl.getUniformLocation(this.program, 'u_scale');
    this.gl.uniform1f(scaleLocation, 1.0);
    
    // 绘制点
    this.gl.drawArrays(this.gl.POINTS, 0, this.data.length);
  }
}
```

**方案 3：基于 Web Workers 的数据处理**
```javascript
// 主线程
class DataVisualizationWithWorkers {
  constructor(canvas, data) {
    this.canvas = canvas;
    this.data = data;
    this.workers = [];
    this.workerCount = navigator.hardwareConcurrency || 4;
    this.chunkSize = Math.ceil(data.length / this.workerCount);
    
    this.init();
  }
  
  init() {
    // 创建 Workers
    for (let i = 0; i < this.workerCount; i++) {
      const worker = new Worker('data-worker.js');
      this.workers.push(worker);
    }
    
    // 分发数据到 Workers
    this.distributeData();
  }
  
  distributeData() {
    const promises = this.workers.map((worker, index) => {
      const start = index * this.chunkSize;
      const end = Math.min(start + this.chunkSize, this.data.length);
      const chunk = this.data.slice(start, end);
      
      return new Promise((resolve) => {
        worker.onmessage = (e) => {
          resolve(e.data);
        };
        
        worker.postMessage({
          type: 'process',
          data: chunk,
          config: {
            filter: this.filter,
            group: this.group
          }
        });
      });
    });
    
    Promise.all(promises).then((results) => {
      const processedData = results.flat();
      this.render(processedData);
    });
  }
  
  render(data) {
    // 渲染处理后的数据
    console.log('Rendering data:', data.length, 'points');
  }
}

// data-worker.js
self.onmessage = (e) => {
  const { type, data, config } = e.data;
  
  if (type === 'process') {
    const processedData = processData(data, config);
    self.postMessage(processedData);
  }
};

function processData(data, config) {
  // 数据处理逻辑
  let result = data;
  
  if (config.filter) {
    result = result.filter(config.filter);
  }
  
  if (config.group) {
    result = groupData(result, config.group);
  }
  
  return result;
}
```

**优化技巧：**

1. **数据分片加载**
```javascript
class DataLoader {
  constructor(dataSource, chunkSize = 10000) {
    this.dataSource = dataSource;
    this.chunkSize = chunkSize;
    this.loadedChunks = 0;
    this.totalChunks = 0;
  }
  
  async loadChunks(onProgress) {
    const total = await this.getTotalCount();
    this.totalChunks = Math.ceil(total / this.chunkSize);
    
    for (let i = 0; i < this.totalChunks; i++) {
      const chunk = await this.loadChunk(i);
      onProgress(chunk, i, this.totalChunks);
      this.loadedChunks++;
    }
  }
  
  async loadChunk(index) {
    const response = await fetch(`${this.dataSource}?offset=${index * this.chunkSize}&limit=${this.chunkSize}`);
    return await response.json();
  }
  
  async getTotalCount() {
    const response = await fetch(`${this.dataSource}?count=true`);
    const data = await response.json();
    return data.count;
  }
}
```

2. **使用 OffscreenCanvas**
```javascript
class OffscreenCanvasRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.offscreen = canvas.transferControlToOffscreen();
    this.worker = new Worker('renderer-worker.js', { type: 'module' });
    this.worker.postMessage({ canvas: this.offscreen }, [this.offscreen]);
  }
  
  render(data) {
    this.worker.postMessage({ type: 'render', data });
  }
}
```

3. **使用 IndexedDB 存储大数据**
```javascript
class IndexedDBStorage {
  constructor(dbName, storeName) {
    this.dbName = dbName;
    this.storeName = storeName;
    this.db = null;
  }
  
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
          store.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }
  
  async add(data) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.add(data);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  async getAll() {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.getAll();
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}
```

---

### 10. 如何设计一个前端项目的监控和告警系统？

**答案：**

前端监控和告警系统需要覆盖性能、错误、用户行为等多个维度。

**系统设计：**

**方案 1：性能监控系统**
```javascript
class PerformanceMonitor {
  constructor(options = {}) {
    this.options = {
      sampleRate: 1,
      reportUrl: '',
      metrics: ['FCP', 'LCP', 'FID', 'CLS', 'TTFB'],
      ...options
    };
    
    this.metrics = {};
    this.init();
  }
  
  init() {
    // 监听页面加载
    if (document.readyState === 'complete') {
      this.collectMetrics();
    } else {
      window.addEventListener('load', () => this.collectMetrics());
    }
    
    // 监听性能指标
    this.observeWebVitals();
    
    // 监听资源加载
    this.observeResources();
  }
  
  collectMetrics() {
    const timing = performance.timing;
    
    this.metrics = {
      // 页面加载相关
      DNS: timing.domainLookupEnd - timing.domainLookupStart,
      TCP: timing.connectEnd - timing.connectStart,
      TTFB: timing.responseStart - timing.requestStart,
      Download: timing.responseEnd - timing.responseStart,
      DOMContentLoaded: timing.domContentLoadedEventEnd - timing.fetchStart,
      Load: timing.loadEventEnd - timing.fetchStart,
      
      // 首屏相关
      FirstPaint: timing.responseStart - timing.fetchStart,
      FirstContentfulPaint: timing.domLoading - timing.fetchStart,
    };
    
    this.report();
  }
  
  observeWebVitals() {
    // FCP (First Contentful Paint)
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach(entry => {
          if (entry.name === 'first-contentful-paint') {
            this.metrics.FCP = entry.startTime;
          }
        });
      });
      observer.observe({ entryTypes: ['paint'] });
      
      // LCP (Largest Contentful Paint)
      const lcpObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        const lastEntry = entries[entries.length - 1];
        this.metrics.LCP = lastEntry.startTime;
      });
      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
      
      // FID (First Input Delay)
      const fidObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach(entry => {
          this.metrics.FID = entry.processingStart - entry.startTime;
        });
      });
      fidObserver.observe({ entryTypes: ['first-input'] });
      
      // CLS (Cumulative Layout Shift)
      let clsValue = 0;
      const clsObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach(entry => {
          if (!entry.hadRecentInput) {
            clsValue += entry.value;
          }
        });
        this.metrics.CLS = clsValue;
      });
      clsObserver.observe({ entryTypes: ['layout-shift'] });
    }
  }
  
  observeResources() {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        if (entry.duration > 1000) { // 超过1秒的资源
          this.reportSlowResource(entry);
        }
      });
    });
    observer.observe({ entryTypes: ['resource'] });
  }
  
  reportSlowResource(entry) {
    this.report({
      type: 'slow-resource',
      data: {
        name: entry.name,
        duration: entry.duration,
        size: entry.transferSize,
        type: entry.initiatorType
      }
    });
  }
  
  report(extraData = {}) {
    if (Math.random() > this.options.sampleRate) {
      return;
    }
    
    const data = {
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      metrics: this.metrics,
      ...extraData
    };
    
    // 使用 sendBeacon 优先
    if (navigator.sendBeacon) {
      navigator.sendBeacon(this.options.reportUrl, JSON.stringify(data));
    } else {
      fetch(this.options.reportUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
        keepalive: true
      }).catch(() => {
        // 失败时存储到 localStorage
        this.storeFailedReport(data);
      });
    }
  }
  
  storeFailedReport(data) {
    const failedReports = JSON.parse(localStorage.getItem('failed-reports') || '[]');
    failedReports.push(data);
    localStorage.setItem('failed-reports', JSON.stringify(failedReports));
  }
  
  retryFailedReports() {
    const failedReports = JSON.parse(localStorage.getItem('failed-reports') || '[]');
    
    failedReports.forEach(data => {
      fetch(this.options.reportUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      }).then(() => {
        const index = failedReports.indexOf(data);
        if (index > -1) {
          failedReports.splice(index, 1);
          localStorage.setItem('failed-reports', JSON.stringify(failedReports));
        }
      });
    });
  }
}
```

**方案 2：错误监控系统**
```javascript
class ErrorMonitor {
  constructor(options = {}) {
    this.options = {
      sampleRate: 1,
      reportUrl: '',
      maxErrors: 100,
      ...options
    };
    
    this.errors = [];
    this.init();
  }
  
  init() {
    // 监听全局错误
    window.addEventListener('error', this.handleError.bind(this));
    
    // 监听 Promise 错误
    window.addEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this));
    
    // 监听资源加载错误
    window.addEventListener('error', this.handleResourceError.bind(this), true);
    
    // 监听 Vue 错误
    if (window.Vue) {
      Vue.config.errorHandler = this.handleVueError.bind(this);
    }
    
    // 监听 React 错误
    if (window.React) {
      window.addEventListener('error', this.handleReactError.bind(this));
    }
  }
  
  handleError(event) {
    const error = {
      type: 'javascript',
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      timestamp: Date.now(),
      url: window.location.href
    };
    
    this.collectError(error);
  }
  
  handleUnhandledRejection(event) {
    const error = {
      type: 'promise',
      reason: event.reason?.toString(),
      stack: event.reason?.stack,
      timestamp: Date.now(),
      url: window.location.href
    };
    
    this.collectError(error);
  }
  
  handleResourceError(event) {
    if (event.target !== window) {
      const error = {
        type: 'resource',
        tagName: event.target.tagName,
        src: event.target.src || event.target.href,
        timestamp: Date.now(),
        url: window.location.href
      };
      
      this.collectError(error);
    }
  }
  
  handleVueError(error, vm, info) {
    const errorData = {
      type: 'vue',
      message: error.message,
      stack: error.stack,
      info: info,
      component: vm?.$options?.name,
      timestamp: Date.now(),
      url: window.location.href
    };
    
    this.collectError(errorData);
  }
  
  handleReactError(event) {
    // React 错误边界处理
    if (event.error) {
      const error = {
        type: 'react',
        message: event.error.message,
        stack: event.error.stack,
        timestamp: Date.now(),
        url: window.location.href
      };
      
      this.collectError(error);
    }
  }
  
  collectError(error) {
    if (Math.random() > this.options.sampleRate) {
      return;
    }
    
    this.errors.push(error);
    
    // 限制错误数量
    if (this.errors.length > this.options.maxErrors) {
      this.errors.shift();
    }
    
    // 立即上报
    this.report(error);
  }
  
  report(error) {
    if (navigator.sendBeacon) {
      navigator.sendBeacon(this.options.reportUrl, JSON.stringify(error));
    } else {
      fetch(this.options.reportUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(error),
        keepalive: true
      }).catch(() => {
        // 失败时存储
        this.storeFailedError(error);
      });
    }
  }
  
  storeFailedError(error) {
    const failedErrors = JSON.parse(localStorage.getItem('failed-errors') || '[]');
    failedErrors.push(error);
    localStorage.setItem('failed-errors', JSON.stringify(failedErrors));
  }
}
```

**方案 3：告警系统**
```javascript
class AlertSystem {
  constructor(options = {}) {
    this.options = {
      webhookUrl: '',
      thresholds: {
        errorRate: 0.01, // 错误率 1%
        slowResponse: 3000, // 慢响应 3秒
        memoryUsage: 0.8 // 内存使用率 80%
      },
      ...options
    };
    
    this.errorCount = 0;
    this.totalRequests = 0;
    this.alertHistory = [];
    this.init();
  }
  
  init() {
    // 监控错误率
    setInterval(() => this.checkErrorRate(), 60000);
    
    // 监控内存使用
    setInterval(() => this.checkMemoryUsage(), 30000);
    
    // 监控慢请求
    this.monitorSlowRequests();
  }
  
  checkErrorRate() {
    const errorRate = this.errorCount / this.totalRequests;
    
    if (errorRate > this.options.thresholds.errorRate) {
      this.sendAlert({
        type: 'high-error-rate',
        severity: 'critical',
        message: `错误率过高: ${(errorRate * 100).toFixed(2)}%`,
        data: {
          errorCount: this.errorCount,
          totalRequests: this.totalRequests
        }
      });
    }
    
    // 重置计数器
    this.errorCount = 0;
    this.totalRequests = 0;
  }
  
  checkMemoryUsage() {
    if (performance.memory) {
      const usage = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
      
      if (usage > this.options.thresholds.memoryUsage) {
        this.sendAlert({
          type: 'high-memory-usage',
          severity: 'warning',
          message: `内存使用率过高: ${(usage * 100).toFixed(2)}%`,
          data: {
            used: performance.memory.usedJSHeapSize,
            total: performance.memory.jsHeapSizeLimit
          }
        });
      }
    }
  }
  
  monitorSlowRequests() {
    const originalFetch = window.fetch;
    
    window.fetch = async (...args) => {
      const start = Date.now();
      
      try {
        const response = await originalFetch(...args);
        const duration = Date.now() - start;
        
        if (duration > this.options.thresholds.slowResponse) {
          this.sendAlert({
            type: 'slow-request',
            severity: 'warning',
            message: `请求响应过慢: ${duration}ms`,
            data: {
              url: args[0],
              duration
            }
          });
        }
        
        return response;
      } catch (error) {
        this.errorCount++;
        throw error;
      } finally {
        this.totalRequests++;
      }
    };
  }
  
  sendAlert(alert) {
    // 避免重复告警
    const alertKey = `${alert.type}-${alert.message}`;
    const lastAlert = this.alertHistory[alertKey];
    
    if (lastAlert && Date.now() - lastAlert < 300000) { // 5分钟内不重复告警
      return;
    }
    
    this.alertHistory[alertKey] = Date.now();
    
    // 发送告警
    if (this.options.webhookUrl) {
      fetch(this.options.webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...alert,
          timestamp: Date.now(),
          url: window.location.href
        })
      }).catch(error => {
        console.error('Failed to send alert:', error);
      });
    }
    
    // 本地通知
    this.showNotification(alert);
  }
  
  showNotification(alert) {
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(alert.message, {
        body: alert.type,
        icon: '/alert-icon.png'
      });
    }
  }
}
```

---

## 总结

百度面试题重点掌握：

### 前端基础
1. **浏览器渲染**：DOM树、CSSOM树、Render树、重排重绘
2. **构建工具**：Webpack原理、模块化、代码分割
3. **性能优化**：大规模数据可视化、监控告警系统

### 算法题
1. **快速排序**：原地排序、三路快排
2. **节流函数**：立即执行、尾随调用

### 场景题
1. **虚拟滚动**：性能优化、大数据渲染
2. **数据可视化**：Canvas、WebGL、Web Workers
3. **监控系统**：性能监控、错误监控、告警系统
4. **工程化体系**：构建优化、代码质量、CI/CD

**面试准备建议：**
1. 深入理解浏览器渲染原理
2. 掌握常见排序算法
3. 熟悉性能优化技巧
4. 注重代码质量和可维护性
5. 了解大规模数据处理方案
6. 掌握监控和告警系统设计