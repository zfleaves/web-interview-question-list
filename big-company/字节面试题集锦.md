# 字节面试题集锦（截止 2025 年底）

## 目录
1. [前端基础](#前端基础)
2. [算法题](#算法题)
3. [场景题](#场景题)

---

## 前端基础

### 1. 谈谈你对 React 并发模式的理解

**答案：**

**React 并发模式（Concurrent Mode）核心概念：**

```javascript
// 1. 可中断渲染
// 传统模式：同步渲染，一旦开始就不能中断
function TraditionalRendering() {
  // 执行大量计算
  const result = heavyComputation();
  
  return <div>{result}</div>;
}

// 并发模式：可中断渲染，优先处理用户交互
function ConcurrentRendering() {
  const [result, setResult] = useState(null);
  
  // 使用 startTransition 标记非紧急更新
  const handleClick = () => {
    startTransition(() => {
      setResult(heavyComputation());
    });
  };
  
  return (
    <div>
      <button onClick={handleClick}>计算</button>
      {result && <div>{result}</div>}
    </div>
  );
}

// 2. useTransition Hook
function TransitionExample() {
  const [isPending, startTransition] = useTransition();
  const [filter, setFilter] = useState('');
  const [results, setResults] = useState([]);
  
  const handleSearch = (value) => {
    // 立即更新输入框
    setFilter(value);
    
    // 标记为过渡更新，可以中断
    startTransition(() => {
      const filtered = heavySearch(value);
      setResults(filtered);
    });
  };
  
  return (
    <div>
      <input
        type="text"
        value={filter}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="搜索..."
      />
      {isPending && <div>搜索中...</div>}
      <ul>
        {results.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}

// 3. useDeferredValue Hook
function DeferredValueExample() {
  const [query, setQuery] = useState('');
  
  // 延迟更新，减少频繁渲染
  const deferredQuery = useDeferredValue(query);
  
  const results = useMemo(() => {
    return heavySearch(deferredQuery);
  }, [deferredQuery]);
  
  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="搜索..."
      />
      <ul>
        {results.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

**并发模式的优势：**

```javascript
// 1. 提升用户体验
// 传统模式：长时间计算导致界面卡顿
function TraditionalList({ items }) {
  const results = items.map(item => heavyComputation(item));
  return <ul>{results.map(r => <li>{r}</li>)}</ul>;
}

// 并发模式：优先响应用户交互
function ConcurrentList({ items }) {
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  useEffect(() => {
    startTransition(() => {
      const computed = items.map(item => heavyComputation(item));
      setResults(computed);
    });
  }, [items]);
  
  return (
    <div>
      {isPending && <div>计算中...</div>}
      <ul>{results.map(r => <li>{r}</li>)}</ul>
    </div>
  );
}
```

---

### 2. 如何实现一个前端微前端架构？

**答案：**

```javascript
// 微前端架构实现

// 1. 基座应用（主应用）
class MicroApp {
  constructor(options) {
    this.apps = new Map();
    this.activeApp = null;
    this.container = options.container;
  }
  
  // 注册子应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      ...config,
      status: 'unmounted',
    });
  }
  
  // 启动应用
  async start() {
    // 启动默认应用
    const defaultApp = Array.from(this.apps.values())[0];
    if (defaultApp) {
      await this.loadApp(defaultApp.name);
    }
  }
  
  // 加载应用
  async loadApp(name) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    // 卸载当前应用
    if (this.activeApp && this.activeApp.name !== name) {
      await this.unloadApp(this.activeApp.name);
    }
    
    // 加载新应用
    app.status = 'loading';
    
    try {
      // 动态加载应用资源
      await this.loadResources(app);
      
      // 挂载应用
      await this.mountApp(app);
      
      app.status = 'mounted';
      this.activeApp = app;
    } catch (error) {
      app.status = 'error';
      console.error(`Failed to load app ${name}:`, error);
    }
  }
  
  // 加载资源
  async loadResources(app) {
    // 加载 JS
    if (app.js) {
      await this.loadScript(app.js);
    }
    
    // 加载 CSS
    if (app.css) {
      await this.loadStylesheet(app.css);
    }
  }
  
  // 加载脚本
  loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  
  // 加载样式
  loadStylesheet(url) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      link.onload = resolve;
      link.onerror = reject;
      document.head.appendChild(link);
    });
  }
  
  // 挂载应用
  async mountApp(app) {
    const { mount, container = this.container } = app;
    
    if (mount && typeof mount === 'function') {
      await mount(container);
    } else if (window[app.name]) {
      // 全局变量方式
      await window[app.name].mount(container);
    }
  }
  
  // 卸载应用
  async unloadApp(name) {
    const app = this.apps.get(name);
    if (!app || app.status !== 'mounted') {
      return;
    }
    
    app.status = 'unmounting';
    
    try {
      const { unmount } = app;
      
      if (unmount && typeof unmount === 'function') {
        await unmount();
      } else if (window[name]) {
        await window[name].unmount();
      }
      
      // 清理资源
      this.cleanupResources(app);
      
      app.status = 'unmounted';
    } catch (error) {
      app.status = 'error';
      console.error(`Failed to unload app ${name}:`, error);
    }
  }
  
  // 清理资源
  cleanupResources(app) {
    // 移除样式
    if (app.css) {
      const links = document.querySelectorAll(`link[href="${app.css}"]`);
      links.forEach(link => link.remove());
    }
    
    // 清空容器
    if (this.container) {
      this.container.innerHTML = '';
    }
  }
}

// 使用
const microApp = new MicroApp({
  container: document.getElementById('app'),
});

// 注册子应用
microApp.registerApp('app1', {
  name: 'app1',
  js: 'https://cdn.example.com/app1.js',
  css: 'https://cdn.example.com/app1.css',
  mount: (container) => {
    // 挂载逻辑
    container.innerHTML = '<div>App 1</div>';
  },
  unmount: () => {
    // 卸载逻辑
  },
});

// 启动
microApp.start();

// 切换应用
microApp.loadApp('app2');
```

---

## 算法题

### 3. 实现一个最长公共子序列（LCS）

**答案：**

```javascript
// 最长公共子序列
function longestCommonSubsequence(text1, text2) {
  const m = text1.length;
  const n = text2.length;
  
  // 创建 DP 表
  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
  
  // 填充 DP 表
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }
  
  // 回溯找到 LCS
  const lcs = [];
  let i = m, j = n;
  
  while (i > 0 && j > 0) {
    if (text1[i - 1] === text2[j - 1]) {
      lcs.unshift(text1[i - 1]);
      i--;
      j--;
    } else if (dp[i - 1][j] > dp[i][j - 1]) {
      i--;
    } else {
      j--;
    }
  }
  
  return {
    length: dp[m][n],
    sequence: lcs.join(''),
  };
}

// 优化空间复杂度
function longestCommonSubsequenceOptimized(text1, text2) {
  const m = text1.length;
  const n = text2.length;
  
  // 只需要两行
  let prev = Array(n + 1).fill(0);
  let curr = Array(n + 1).fill(0);
  
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) {
        curr[j] = prev[j - 1] + 1;
      } else {
        curr[j] = Math.max(prev[j], curr[j - 1]);
      }
    }
    
    // 交换行
    [prev, curr] = [curr, prev];
  }
  
  return prev[n];
}
```

---

### 4. 实现一个 Trie（前缀树）

**答案：**

```javascript
// Trie 节点
class TrieNode {
  constructor() {
    this.children = {};
    this.isEnd = false;
    this.count = 0; // 记录经过该节点的单词数
  }
}

// Trie 实现
class Trie {
  constructor() {
    this.root = new TrieNode();
  }
  
  // 插入单词
  insert(word) {
    let node = this.root;
    
    for (const char of word) {
      if (!node.children[char]) {
        node.children[char] = new TrieNode();
      }
      node = node.children[char];
      node.count++;
    }
    
    node.isEnd = true;
  }
  
  // 搜索单词
  search(word) {
    let node = this.root;
    
    for (const char of word) {
      if (!node.children[char]) {
        return false;
      }
      node = node.children[char];
    }
    
    return node.isEnd;
  }
  
  // 搜索前缀
  startsWith(prefix) {
    let node = this.root;
    
    for (const char of prefix) {
      if (!node.children[char]) {
        return false;
      }
      node = node.children[char];
    }
    
    return true;
  }
  
  // 删除单词
  delete(word) {
    return this._deleteHelper(this.root, word, 0);
  }
  
  _deleteHelper(node, word, index) {
    if (index === word.length) {
      if (!node.isEnd) {
        return false;
      }
      node.isEnd = false;
      return Object.keys(node.children).length === 0;
    }
    
    const char = word[index];
    if (!node.children[char]) {
      return false;
    }
    
    const shouldDelete = this._deleteHelper(node.children[char], word, index + 1);
    
    if (shouldDelete) {
      delete node.children[char];
      return Object.keys(node.children).length === 0 && !node.isEnd;
    }
    
    return false;
  }
  
  // 获取所有以 prefix 开头的单词
  getWordsWithPrefix(prefix) {
    const words = [];
    let node = this.root;
    
    // 找到前缀对应的节点
    for (const char of prefix) {
      if (!node.children[char]) {
        return words;
      }
      node = node.children[char];
    }
    
    // DFS 收集所有单词
    this._collectWords(node, prefix, words);
    
    return words;
  }
  
  _collectWords(node, prefix, words) {
    if (node.isEnd) {
      words.push(prefix);
    }
    
    for (const char in node.children) {
      this._collectWords(node.children[char], prefix + char, words);
    }
  }
  
  // 统计以 prefix 开头的单词数量
  countWordsWithPrefix(prefix) {
    let node = this.root;
    
    for (const char of prefix) {
      if (!node.children[char]) {
        return 0;
      }
      node = node.children[char];
    }
    
    return node.count;
  }
}
```

---

## 场景题

### 5. 如何实现一个防抖的搜索框？

**答案：**

```javascript
// 封装防抖函数
function debounce(func, delay) {
  let timer = null;
  
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// 使用
class SearchBox extends React.Component {
  state = {
    keyword: '',
    results: []
  };
  
  handleSearch = debounce((keyword) => {
    // 模拟 API 请求
    fetch(`/api/search?keyword=${keyword}`)
      .then(res => res.json())
      .then(data => {
        this.setState({ results: data });
      });
  }, 300);
  
  handleChange = (e) => {
    const keyword = e.target.value;
    this.setState({ keyword });
    this.handleSearch(keyword);
  };
  
  render() {
    return (
      <div>
        <input
          type="text"
          value={this.state.keyword}
          onChange={this.handleChange}
          placeholder="搜索..."
        />
        <ul>
          {this.state.results.map(item => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      </div>
    );
  }
}
```

---

### 6. 如何实现一个虚拟滚动列表？

**答案：**

```javascript
class VirtualList extends React.Component {
  state = {
    visibleStart: 0,
    visibleEnd: 10
  };
  
  containerRef = React.createRef();
  
  componentDidMount() {
    this.containerRef.current.addEventListener('scroll', this.handleScroll);
  }
  
  componentWillUnmount() {
    this.containerRef.current.removeEventListener('scroll', this.handleScroll);
  }
  
  handleScroll = () => {
    const container = this.containerRef.current;
    const scrollTop = container.scrollTop;
    const itemHeight = 50;
    const visibleCount = Math.ceil(container.clientHeight / itemHeight);
    
    const start = Math.floor(scrollTop / itemHeight);
    const end = start + visibleCount;
    
    this.setState({
      visibleStart: start,
      visibleEnd: end
    });
  };
  
  render() {
    const { items, itemHeight = 50 } = this.props;
    const { visibleStart, visibleEnd } = this.state;
    
    const visibleItems = items.slice(visibleStart, visibleEnd);
    const totalHeight = items.length * itemHeight;
    const offsetY = visibleStart * itemHeight;
    
    return (
      <div
        ref={this.containerRef}
        style={{
          height: '500px',
          overflow: 'auto'
        }}
      >
        <div style={{ height: totalHeight, position: 'relative' }}>
          <div
            style={{
              transform: `translateY(${offsetY}px)`,
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0
            }}
          >
            {visibleItems.map((item, index) => (
              <div
                key={index}
                style={{
                  height: itemHeight,
                  boxSizing: 'border-box',
                  padding: '10px',
                  borderBottom: '1px solid #eee'
                }}
              >
                {item}
              </div>
            ))}
          </div>
        </div>
      </div>
    );
  }
}
```

---

### 7. 如何实现一个图片懒加载？

**答案：**

```javascript
class LazyImage extends React.Component {
  constructor(props) {
    super(props);
    this.imgRef = React.createRef();
    this.state = {
      loaded: false,
      inView: false
    };
  }
  
  componentDidMount() {
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            this.setState({ inView: true });
            this.observer.unobserve(entry.target);
          }
        });
      },
      {
        rootMargin: '100px'
      }
    );
    
    if (this.imgRef.current) {
      this.observer.observe(this.imgRef.current);
    }
  }
  
  componentWillUnmount() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
  
  render() {
    const { src, alt, placeholder } = this.props;
    const { loaded, inView } = this.state;
    
    return (
      <img
        ref={this.imgRef}
        src={inView && loaded ? src : placeholder}
        alt={alt}
        onLoad={() => this.setState({ loaded: true })}
        style={{
          opacity: loaded ? 1 : 0.5,
          transition: 'opacity 0.3s'
        }}
      />
    );
  }
}
```

---

### 8. 如何实现一个无限滚动加载？

**答案：**

```javascript
class InfiniteScroll {
  constructor() {
    this.state = {
      items: [],
      page: 1,
      loading: false,
      hasMore: true
    };
    
    this.init();
  }
  
  init() {
    this.loadItems();
    window.addEventListener('scroll', this.handleScroll);
  }
  
  loadItems = async () => {
    if (this.state.loading || !this.state.hasMore) return;
    
    this.state.loading = true;
    
    try {
      const { page } = this.state;
      const newItems = await this.fetchItems(page);
      
      this.state.items = [...this.state.items, ...newItems];
      this.state.page = page + 1;
      this.state.loading = false;
      this.state.hasMore = newItems.length >= 10;
      
      this.render();
    } catch (error) {
      console.error(error);
      this.state.loading = false;
    }
  };
  
  fetchItems = async (page) => {
    const response = await fetch(`/api/items?page=${page}`);
    const data = await response.json();
    return data;
  };
  
  handleScroll = () => {
    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
    
    if (scrollTop + clientHeight >= scrollHeight - 100) {
      this.loadItems();
    }
  };
  
  render() {
    const container = document.getElementById('container');
    container.innerHTML = `
      <ul>
        ${this.state.items.map((item, index) => `
          <li key="${index}">${item.name}</li>
        `).join('')}
      </ul>
      ${this.state.loading ? '<div>加载中...</div>' : ''}
    `;
  }
}
```

### 7. 如何处理输入框连续触发请求的问题？

**答案：**

输入框连续触发请求是一个常见问题，需要通过防抖、请求取消等方式来解决。

**实现方案：**

**方案 1：使用 AbortController 取消请求**
```javascript
import { useState, useRef, useEffect } from 'react';

function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const [loading, setLoading] = useState(false);
  const [results, setResults] = useState([]);
  const abortControllerRef = useRef(null);
  const searchTermRef = useRef('');

  const handleSearch = async (value) => {
    // 取消之前的请求
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    // 保存当前搜索词
    searchTermRef.current = value;

    // 创建新的 AbortController
    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    setLoading(true);

    try {
      const response = await fetch(`/api/search?q=${encodeURIComponent(value)}`, {
        signal: abortController.signal
      });

      // 检查搜索词是否变化
      if (searchTermRef.current !== value) {
        return;
      }

      const data = await response.json();
      setResults(data);
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Search error:', error);
      }
    } finally {
      setLoading(false);
    }
  };

  const handleChange = (e) => {
    const value = e.target.value;
    setSearchTerm(value);
    handleSearch(value);
  };

  useEffect(() => {
    return () => {
      // 组件卸载时取消请求
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  return (
    <div>
      <input
        type="text"
        value={searchTerm}
        onChange={handleChange}
        placeholder="搜索..."
      />
      {loading && <div>搜索中...</div>}
      <ul>
        {results.map((item, index) => (
          <li key={index}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

**方案 2：使用防抖 + AbortController**
```javascript
import { useState, useRef, useCallback } from 'react';

function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

function SearchWithDebounce() {
  const [searchTerm, setSearchTerm] = useState('');
  const [loading, setLoading] = useState(false);
  const [results, setResults] = useState([]);
  const abortControllerRef = useRef(null);
  const searchTermRef = useRef('');

  const performSearch = useCallback(async (value) => {
    // 取消之前的请求
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    searchTermRef.current = value;

    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    setLoading(true);

    try {
      const response = await fetch(`/api/search?q=${encodeURIComponent(value)}`, {
        signal: abortController.signal
      });

      if (searchTermRef.current !== value) {
        return;
      }

      const data = await response.json();
      setResults(data);
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Search error:', error);
      }
    } finally {
      setLoading(false);
    }
  }, []);

  // 防抖处理
  const debouncedSearch = useCallback(
    debounce(performSearch, 300),
    [performSearch]
  );

  const handleChange = (e) => {
    const value = e.target.value;
    setSearchTerm(value);
    debouncedSearch(value);
  };

  return (
    <div>
      <input
        type="text"
        value={searchTerm}
        onChange={handleChange}
        placeholder="搜索..."
      />
      {loading && <div>搜索中...</div>}
      <ul>
        {results.map((item, index) => (
          <li key={index}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

**方案 3：使用 Axios CancelToken**
```javascript
import { useState, useRef } from 'react';
import axios from 'axios';

function SearchWithAxios() {
  const [searchTerm, setSearchTerm] = useState('');
  const [loading, setLoading] = useState(false);
  const [results, setResults] = useState([]);
  const cancelTokenRef = useRef(null);
  const searchTermRef = useRef('');

  const handleSearch = async (value) => {
    // 取消之前的请求
    if (cancelTokenRef.current) {
      cancelTokenRef.current.cancel('Operation canceled due to new request.');
    }

    searchTermRef.current = value;

    // 创建新的 CancelToken
    const CancelToken = axios.CancelToken;
    const source = CancelToken.source();
    cancelTokenRef.current = source;

    setLoading(true);

    try {
      const response = await axios.get('/api/search', {
        params: { q: value },
        cancelToken: source.token
      });

      // 检查搜索词是否变化
      if (searchTermRef.current !== value) {
        return;
      }

      setResults(response.data);
    } catch (error) {
      if (axios.isCancel(error)) {
        console.log('Request canceled:', error.message);
      } else {
        console.error('Search error:', error);
      }
    } finally {
      setLoading(false);
    }
  };

  const handleChange = (e) => {
    const value = e.target.value;
    setSearchTerm(value);
    handleSearch(value);
  };

  return (
    <div>
      <input
        type="text"
        value={searchTerm}
        onChange={handleChange}
        placeholder="搜索..."
      />
      {loading && <div>搜索中...</div>}
      <ul>
        {results.map((item, index) => (
          <li key={index}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

**方案 4：使用 React Query（TanStack Query）**
```javascript
import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';

function SearchWithReactQuery() {
  const [searchTerm, setSearchTerm] = useState('');

  const { data: results, isLoading } = useQuery({
    queryKey: ['search', searchTerm],
    queryFn: async () => {
      const response = await fetch(`/api/search?q=${encodeURIComponent(searchTerm)}`);
      return response.json();
    },
    enabled: searchTerm.length > 0,
    staleTime: 5000,
    refetchOnWindowFocus: false
  });

  return (
    <div>
      <input
        type="text"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="搜索..."
      />
      {isLoading && <div>搜索中...</div>}
      <ul>
        {results?.map((item, index) => (
          <li key={index}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

**优化技巧：**

1. **使用 requestAnimationFrame 优化**
```javascript
function rafDebounce(func) {
  let rafId = null;
  return function (...args) {
    if (rafId) {
      cancelAnimationFrame(rafId);
    }
    rafId = requestAnimationFrame(() => {
      func.apply(this, args);
      rafId = null;
    });
  };
}
```

2. **使用 IdleCallback 优化**
```javascript
function idleDebounce(func, timeout = 1000) {
  let idleId = null;
  return function (...args) {
    if (idleId) {
      cancelIdleCallback(idleId);
    }
    idleId = requestIdleCallback(() => {
      func.apply(this, args);
      idleId = null;
    }, { timeout });
  };
}
```

3. **缓存搜索结果**
```javascript
class SearchCache {
  constructor(maxSize = 100) {
    this.cache = new Map();
    this.maxSize = maxSize;
  }
  
  get(key) {
    return this.cache.get(key);
  }
  
  set(key, value) {
    if (this.cache.size >= this.maxSize) {
      // 删除最早的缓存
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
  
  clear() {
    this.cache.clear();
  }
}

const searchCache = new SearchCache();

async function searchWithCache(query) {
  const cached = searchCache.get(query);
  if (cached) {
    return cached;
  }
  
  const results = await fetch(`/api/search?q=${query}`);
  const data = await results.json();
  
  searchCache.set(query, data);
  return data;
}
```

---

### 8. 如何实现一个高性能的虚拟列表？

**答案：**

虚拟列表是处理大量数据渲染的关键技术，通过只渲染可见区域的元素来提升性能。

**实现方案：**

**方案 1：基础虚拟列表**
```javascript
class VirtualList {
  constructor(options) {
    this.container = options.container;
    this.itemHeight = options.itemHeight || 50;
    this.items = options.items || [];
    this.renderItem = options.renderItem;
    
    this.visibleCount = Math.ceil(this.container.clientHeight / this.itemHeight);
    this.startIndex = 0;
    this.endIndex = this.visibleCount;
    
    this.init();
  }
  
  init() {
    // 设置容器高度
    this.container.style.position = 'relative';
    this.container.style.overflow = 'auto';
    
    // 创建内容容器
    this.content = document.createElement('div');
    this.content.style.position = 'absolute';
    this.content.style.top = '0';
    this.content.style.left = '0';
    this.content.style.right = '0';
    this.container.appendChild(this.content);
    
    // 创建占位容器
    this.placeholder = document.createElement('div');
    this.placeholder.style.position = 'absolute';
    this.placeholder.style.top = '0';
    this.placeholder.style.left = '0';
    this.placeholder.style.right = '0';
    this.placeholder.style.zIndex = '-1';
    this.container.appendChild(this.placeholder);
    
    // 监听滚动
    this.container.addEventListener('scroll', this.handleScroll.bind(this));
    
    // 初始渲染
    this.update();
  }
  
  handleScroll() {
    const scrollTop = this.container.scrollTop;
    this.startIndex = Math.floor(scrollTop / this.itemHeight);
    this.endIndex = Math.min(
      this.startIndex + this.visibleCount + 2,
      this.items.length
    );
    
    this.update();
  }
  
  update() {
    // 更新占位高度
    this.placeholder.style.height = `${this.items.length * this.itemHeight}px`;
    
    // 更新内容位置
    const offsetY = this.startIndex * this.itemHeight;
    this.content.style.transform = `translateY(${offsetY}px)`;
    
    // 渲染可见项
    const visibleItems = this.items.slice(this.startIndex, this.endIndex);
    this.content.innerHTML = visibleItems.map((item, index) => {
      const actualIndex = this.startIndex + index;
      return this.renderItem(item, actualIndex);
    }).join('');
  }
  
  updateItems(newItems) {
    this.items = newItems;
    this.update();
  }
  
  scrollToItem(index) {
    const scrollTop = index * this.itemHeight;
    this.container.scrollTop = scrollTop;
  }
  
  destroy() {
    this.container.removeEventListener('scroll', this.handleScroll.bind(this));
  }
}

// 使用
const list = new VirtualList({
  container: document.getElementById('list-container'),
  itemHeight: 50,
  items: Array.from({ length: 10000 }, (_, i) => ({ id: i, name: `Item ${i}` })),
  renderItem: (item, index) => `
    <div style="height: 50px; border-bottom: 1px solid #eee;">
      ${item.name}
    </div>
  `
});
```

**方案 2：React 虚拟列表组件**
```javascript
import { useState, useEffect, useRef, useCallback } from 'react';

function VirtualList({ items, itemHeight, renderItem }) {
  const containerRef = useRef(null);
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 10 });
  
  const handleScroll = useCallback(() => {
    if (!containerRef.current) return;
    
    const scrollTop = containerRef.current.scrollTop;
    const containerHeight = containerRef.current.clientHeight;
    
    const start = Math.floor(scrollTop / itemHeight);
    const end = Math.min(
      start + Math.ceil(containerHeight / itemHeight) + 2,
      items.length
    );
    
    setVisibleRange({ start, end });
  }, [itemHeight, items.length]);
  
  useEffect(() => {
    const container = containerRef.current;
    if (container) {
      container.addEventListener('scroll', handleScroll);
      handleScroll(); // 初始渲染
      
      return () => {
        container.removeEventListener('scroll', handleScroll);
      };
    }
  }, [handleScroll]);
  
  const { start, end } = visibleRange;
  const visibleItems = items.slice(start, end);
  const totalHeight = items.length * itemHeight;
  const offsetY = start * itemHeight;
  
  return (
    <div
      ref={containerRef}
      style={{
        height: '500px',
        overflow: 'auto',
        position: 'relative'
      }}
    >
      <div
        style={{
          height: totalHeight,
          position: 'relative'
        }}
      >
        <div
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            transform: `translateY(${offsetY}px)`
          }}
        >
          {visibleItems.map((item, index) => (
            <div
              key={item.id || index}
              style={{
                height: itemHeight,
                boxSizing: 'border-box'
              }}
            >
              {renderItem(item, start + index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// 使用
function App() {
  const items = Array.from({ length: 10000 }, (_, i) => ({
    id: i,
    name: `Item ${i}`
  }));
  
  return (
    <VirtualList
      items={items}
      itemHeight={50}
      renderItem={(item, index) => (
        <div style={{ padding: '10px', borderBottom: '1px solid #eee' }}>
          {item.name}
        </div>
      )}
    />
  );
}
```

**方案 3：动态高度的虚拟列表**
```javascript
class DynamicVirtualList {
  constructor(options) {
    this.container = options.container;
    this.items = options.items || [];
    this.renderItem = options.renderItem;
    this.itemHeights = new Map();
    this.estimatedItemHeight = options.estimatedItemHeight || 50;
    
    this.visibleRange = { start: 0, end: 10 };
    this.scrollTop = 0;
    
    this.init();
  }
  
  init() {
    this.container.style.position = 'relative';
    this.container.style.overflow = 'auto';
    
    this.content = document.createElement('div');
    this.content.style.position = 'absolute';
    this.content.style.top = '0';
    this.content.style.left = '0';
    this.content.style.right = '0';
    this.container.appendChild(this.content);
    
    this.placeholder = document.createElement('div');
    this.placeholder.style.position = 'absolute';
    this.placeholder.style.top = '0';
    this.placeholder.style.left = '0';
    this.placeholder.style.right = '0';
    this.placeholder.style.zIndex = '-1';
    this.container.appendChild(this.placeholder);
    
    this.container.addEventListener('scroll', this.handleScroll.bind(this));
    
    this.update();
  }
  
  handleScroll() {
    this.scrollTop = this.container.scrollTop;
    this.calculateVisibleRange();
    this.update();
  }
  
  calculateVisibleRange() {
    let currentTop = 0;
    let start = 0;
    let end = 0;
    
    // 找到起始索引
    for (let i = 0; i < this.items.length; i++) {
      const height = this.itemHeights.get(i) || this.estimatedItemHeight;
      if (currentTop + height >= this.scrollTop) {
        start = i;
        break;
      }
      currentTop += height;
    }
    
    // 找到结束索引
    currentTop = 0;
    for (let i = 0; i < this.items.length; i++) {
      const height = this.itemHeights.get(i) || this.estimatedItemHeight;
      if (currentTop >= this.scrollTop + this.container.clientHeight) {
        end = i;
        break;
      }
      currentTop += height;
    }
    
    this.visibleRange = {
      start,
      end: Math.min(end + 5, this.items.length)
    };
  }
  
  update() {
    // 计算总高度
    const totalHeight = this.items.reduce((sum, _, index) => {
      return sum + (this.itemHeights.get(index) || this.estimatedItemHeight);
    }, 0);
    
    this.placeholder.style.height = `${totalHeight}px`;
    
    // 计算偏移量
    let offsetY = 0;
    for (let i = 0; i < this.visibleRange.start; i++) {
      offsetY += this.itemHeights.get(i) || this.estimatedItemHeight;
    }
    
    this.content.style.transform = `translateY(${offsetY}px)`;
    
    // 渲染可见项
    const visibleItems = this.items.slice(
      this.visibleRange.start,
      this.visibleRange.end
    );
    
    this.content.innerHTML = visibleItems.map((item, index) => {
      const actualIndex = this.visibleRange.start + index;
      return this.renderItem(item, actualIndex, (height) => {
        this.itemHeights.set(actualIndex, height);
      });
    }).join('');
  }
  
  scrollToItem(index) {
    let scrollTop = 0;
    for (let i = 0; i < index; i++) {
      scrollTop += this.itemHeights.get(i) || this.estimatedItemHeight;
    }
    this.container.scrollTop = scrollTop;
  }
}
```

**优化技巧：**

1. **预加载和预渲染**
```javascript
function preloadItems(startIndex, count) {
  const preloadStart = Math.max(0, startIndex - count);
  const preloadEnd = Math.min(items.length, startIndex + count);
  
  // 预加载图片等资源
  for (let i = preloadStart; i < preloadEnd; i++) {
    const item = items[i];
    if (item.image) {
      const img = new Image();
      img.src = item.image;
    }
  }
}
```

2. **使用 Intersection Observer**
```javascript
function observeVisibility(items) {
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const index = parseInt(entry.target.dataset.index);
          // 加载可见项的数据
          loadDataForIndex(index);
        }
      });
    },
    { rootMargin: '200px' }
  );
  
  items.forEach(item => {
    observer.observe(item.element);
  });
}
```

3. **使用 requestIdleCallback**
```javascript
function updateListIdle(items) {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() => {
      updateList(items);
    });
  } else {
    setTimeout(() => {
      updateList(items);
    }, 0);
  }
}
```

---

## 总结

字节面试题重点掌握：

### 前端基础
1. **微前端**：架构设计、通信方式、样式隔离
2. **构建工具**：Webpack、Vite、Rollup
3. **React 并发模式**：Suspense、useTransition、useDeferredValue
4. **请求优化**：AbortController、防抖节流、缓存
5. **虚拟列表**：高性能渲染、动态高度

### 算法题
1. **Trie（前缀树）**：搜索建议、自动补全
2. **快速排序**：经典排序算法

### 场景题
1. **防抖搜索**：性能优化、用户体验
2. **请求取消**：AbortController、Axios CancelToken
3. **虚拟列表**：大数据渲染、动态高度

**面试准备建议：**
1. 深入理解微前端架构
2. 掌握构建工具原理
3. 熟悉 React 最新特性
4. 注重性能优化
5. 保持对新技术的关注
6. 理解请求优化策略
7. 掌握虚拟列表实现原理
4. 注重代码质量和可维护性