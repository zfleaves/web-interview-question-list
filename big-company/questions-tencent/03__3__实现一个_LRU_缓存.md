# 3. 实现一个 LRU 缓存

**答案：**

```javascript
// 使用 Map 实现 O(1) 时间复杂度
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    // 重新设置以更新访问顺序
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    
    return value;
  }
  
  put(key, value) {
    if (this.cache.has(key)) {
      // 更新现有 key
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // 删除最久未使用的（第一个）
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
  }
}

// 使用
const lru = new LRUCache(2);
lru.put(1, 'a');
lru.put(2, 'b');
console.log(lru.get(1)); // 'a'
lru.put(3, 'c'); // 删除 key 2
console.log(lru.get(2)); // -1

// 扩展：实现带过期时间的 LRU
class LRUCacheWithTTL {
  constructor(capacity, ttl = 60000) {
    this.capacity = capacity;
    this.ttl = ttl;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    const item = this.cache.get(key);
    
    // 检查是否过期
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return -1;
    }
    
    // 更新访问时间和顺序
    this.cache.delete(key);
    this.cache.set(key, { ...item, timestamp: Date.now() });
    
    return item.value;
  }
  
  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, {
      value,
      timestamp: Date.now(),
    });
  }
  
  // 清理过期项
  cleanExpired() {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
  }
}
```

**场景应用：**

```javascript
// 前端图片缓存
class ImageCache {
  constructor(maxSize = 20, ttl = 3600000) { // 1小时
    this.cache = new LRUCacheWithTTL(maxSize, ttl);
  }
  
  async loadImage(url) {
    // 检查缓存
    const cached = this.cache.get(url);
    if (cached !== -1) {
      return cached;
    }
    
    // 加载图片
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        this.cache.put(url, img.src);
        resolve(img.src);
      };
      img.onerror = reject;
      img.src = url;
    });
  }
}

// API 响应缓存
class APICache {
  constructor(maxSize = 50, ttl = 300000) { // 5分钟
    this.cache = new LRUCacheWithTTL(maxSize, ttl);
  }
  
  async fetch(url, options = {}) {
    const cacheKey = `${url}_${JSON.stringify(options)}`;
    
    // 检查缓存
    const cached = this.cache.get(cacheKey);
    if (cached !== -1) {
      return cached;
    }
    
    // 发起请求
    const response = await fetch(url, options);
    const data = await response.json();
    
    // 缓存结果
    this.cache.put(cacheKey, data);
    
    return data;
  }
}
```

---
