# 10. 如何实现移动端上拉加载和下拉刷新？

**答案：**

移动端上拉加载和下拉刷新是提升用户体验的重要功能。

**下拉刷新实现：**

**方案 1：使用 Touch 事件**
```javascript
function PullToRefresh(container, onRefresh) {
  let startY = 0;
  let currentY = 0;
  let isDragging = false;
  const threshold = 60; // 触发刷新的阈值
  
  const indicator = document.createElement('div');
  indicator.className = 'pull-indicator';
  indicator.innerHTML = '<span>↓ 下拉刷新</span>';
  container.prepend(indicator);
  
  container.addEventListener('touchstart', (e) => {
    if (container.scrollTop === 0) {
      startY = e.touches[0].clientY;
      isDragging = true;
    }
  }, { passive: true });
  
  container.addEventListener('touchmove', (e) => {
    if (!isDragging) return;
    
    currentY = e.touches[0].clientY;
    const diff = currentY - startY;
    
    if (diff > 0 && container.scrollTop === 0) {
      indicator.style.transform = `translateY(${Math.min(diff, 100)}px)`;
      indicator.style.opacity = Math.min(diff / threshold, 1);
      
      if (diff >= threshold) {
        indicator.querySelector('span').textContent = '↑ 释放刷新';
      } else {
        indicator.querySelector('span').textContent = '↓ 下拉刷新';
      }
    }
  }, { passive: true });
  
  container.addEventListener('touchend', async () => {
    if (!isDragging) return;
    isDragging = false;
    
    const diff = currentY - startY;
    
    if (diff >= threshold) {
      indicator.querySelector('span').textContent = '刷新中...';
      indicator.classList.add('loading');
      
      await onRefresh();
      
      indicator.classList.remove('loading');
      indicator.style.transform = 'translateY(0)';
      indicator.style.opacity = '0';
    } else {
      indicator.style.transform = 'translateY(0)';
      indicator.style.opacity = '0';
    }
  });
}

// 使用
PullToRefresh(document.getElementById('list-container'), async () => {
  await fetchData();
});
```

**方案 2：使用 Intersection Observer**
```javascript
function InfiniteScroll(container, onLoadMore) {
  const sentinel = document.createElement('div');
  sentinel.className = 'scroll-sentinel';
  container.appendChild(sentinel);
  
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        onLoadMore();
      }
    });
  }, {
    rootMargin: '100px'
  });
  
  observer.observe(sentinel);
  
  return () => observer.disconnect();
}

// 使用
function List() {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [page, setPage] = useState(1);
  
  const loadMore = async () => {
    if (loading) return;
    
    setLoading(true);
    const newItems = await fetchItems(page + 1);
    setItems(prev => [...prev, ...newItems]);
    setPage(page + 1);
    setLoading(false);
  };
  
  useEffect(() => {
    const cleanup = InfiniteScroll(
      document.getElementById('list-container'),
      loadMore
    );
    return cleanup;
  }, []);
  
  return (
    <div id="list-container">
      {items.map(item => <div key={item.id}>{item.name}</div>)}
      {loading && <div>加载中...</div>}
    </div>
  );
}
```

**方案 3：使用 React Hook**
```javascript
import { useState, useEffect, useCallback } from 'react';

function usePullToRefresh(onRefresh) {
  const [isPulling, setIsPulling] = useState(false);
  const [pullDistance, setPullDistance] = useState(0);
  const startY = useRef(0);
  
  const handleTouchStart = useCallback((e) => {
    startY.current = e.touches[0].clientY;
  }, []);
  
  const handleTouchMove = useCallback((e) => {
    const currentY = e.touches[0].clientY;
    const distance = currentY - startY.current;
    
    if (distance > 0) {
      setPullDistance(Math.min(distance, 100));
      setIsPulling(distance >= 60);
    }
  }, []);
  
  const handleTouchEnd = useCallback(async () => {
    if (isPulling) {
      await onRefresh();
    }
    setPullDistance(0);
    setIsPulling(false);
  }, [isPulling, onRefresh]);
  
  return {
    pullDistance,
    isPulling,
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd
  };
}

// 使用
function RefreshList() {
  const [items, setItems] = useState([]);
  const [refreshing, setRefreshing] = useState(false);
  
  const handleRefresh = async () => {
    setRefreshing(true);
    const newItems = await fetchItems();
    setItems(newItems);
    setRefreshing(false);
  };
  
  const {
    pullDistance,
    isPulling,
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd
  } = usePullToRefresh(handleRefresh);
  
  return (
    <div
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
      style={{ position: 'relative', minHeight: '100vh' }}
    >
      {/* 下拉指示器 */}
      <div
        style={{
          position: 'absolute',
          top: `${-50 + pullDistance}px`,
          left: 0,
          right: 0,
          height: '50px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: '#f0f0f0',
          opacity: pullDistance / 100
        }}
      >
        {isPulling ? '↑ 释放刷新' : '↓ 下拉刷新'}
      </div>
      
      {/* 列表内容 */}
      <div>
        {refreshing ? '刷新中...' : items.map(item => (
          <div key={item.id}>{item.name}</div>
        ))}
      </div>
    </div>
  );
}
```

**方案 4：使用第三方库**
```javascript
import { PullToRefresh } from 'react-simple-pull-to-refresh';

function App() {
  const [items, setItems] = useState([]);
  
  const onRefresh = async () => {
    const newItems = await fetchItems();
    setItems(newItems);
  };
  
  return (
    <PullToRefresh onRefresh={onRefresh}>
      {items.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </PullToRefresh>
  );
}
```

**优化技巧：**

1. **防抖处理**
```javascript
const debouncedLoadMore = debounce(loadMore, 300);
```

2. **节流处理**
```javascript
const throttledHandleScroll = throttle(handleScroll, 100);
```

3. **虚拟滚动优化**
```javascript
import { FixedSizeList } from 'react-window';

function VirtualList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>{items[index].name}</div>
  );
  
  return (
    <FixedSizeList
      height={400}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

4. **预加载下一页数据**
```javascript
const [nextPage, setNextPage] = useState(null);

useEffect(() => {
  if (items.length > 0 && !nextPage) {
    prefetchNextPage(page + 1);
  }
}, [items.length, page, nextPage]);
```

---
