# 1. 谈谈你对前端性能优化的理解，有哪些优化手段？

**答案：**

**性能优化核心思路：**

1. **加载性能优化**（减少首屏时间）
2. **运行性能优化**（减少卡顿、提高响应速度）
3. **渲染性能优化**（提高 FPS、减少重排重绘）

**具体优化手段：**

```javascript
// 1. 资源加载优化

// 代码分割（Webpack）
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },
  },
};

// 动态导入
const Home = lazy(() => import('./Home'));
const About = lazy(() => import('./About'));

// 预加载关键资源
<link rel="preload" href="critical.css" as="style">
<link rel="prefetch" href="next-page.js">

// 2. 网络优化

// HTTP 缓存
app.use(express.static('public', {
  maxAge: '1y',
  etag: true,
  lastModified: true,
}));

// CDN 加速
const cdnUrl = 'https://cdn.example.com';
const script = document.createElement('script');
script.src = `${cdnUrl}/app.js`;

// 3. 渲染优化

// 虚拟列表
function VirtualList({ items, itemHeight, visibleCount }) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleCount, items.length);
  const visibleItems = items.slice(startIndex, endIndex);
  
  return (
    <div
      style={{ height: visibleCount * itemHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItems.map((item, i) => (
          <div
            key={startIndex + i}
            style={{
              position: 'absolute',
              top: (startIndex + i) * itemHeight,
              height: itemHeight,
            }}
          >
            {item}
          </div>
        ))}
      </div>
    </div>
  );
}

// 防抖和节流
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

function throttle(fn, delay) {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      fn.apply(this, args);
      lastCall = now;
    }
  };
}

// 4. 代码优化

// 避免内存泄漏
useEffect(() => {
  const timer = setInterval(() => {
    console.log('tick');
  }, 1000);
  
  return () => clearInterval(timer); // 清理定时器
}, []);

// 使用 useMemo 和 useCallback
function ExpensiveComponent({ items }) {
  const expensiveValue = useMemo(() => {
    return items.filter(item => item.active).reduce((sum, item) => sum + item.value, 0);
  }, [items]);
  
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);
  
  return <div onClick={handleClick}>{expensiveValue}</div>;
}
```

**监控指标：**

```javascript
// Core Web Vitals
function measureWebVitals() {
  // Largest Contentful Paint (LCP) - 最大内容绘制
  new PerformanceObserver((list) => {
    const entries = list.getEntries();
    const lastEntry = entries[entries.length - 1];
    console.log('LCP:', lastEntry.renderTime || lastEntry.loadTime);
  }).observe({ type: 'largest-contentful-paint', buffered: true });
  
  // First Input Delay (FID) - 首次输入延迟
  new PerformanceObserver((list) => {
    const entries = list.getEntries();
    entries.forEach(entry => {
      console.log('FID:', entry.processingStart - entry.startTime);
    });
  }).observe({ type: 'first-input', buffered: true });
  
  // Cumulative Layout Shift (CLS) - 累积布局偏移
  let clsValue = 0;
  new PerformanceObserver((list) => {
    const entries = list.getEntries();
    entries.forEach(entry => {
      if (!entry.hadRecentInput) {
        clsValue += entry.value;
      }
    });
    console.log('CLS:', clsValue);
  }).observe({ type: 'layout-shift', buffered: true });
}
```

---
