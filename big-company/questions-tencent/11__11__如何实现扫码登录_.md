# 11. 如何实现扫码登录？

**答案：**

扫码登录是现代应用常用的登录方式，提供了更好的用户体验。

**实现流程：**

**方案 1：基于 WebSocket 的实时通信**
```javascript
// 前端生成二维码
function generateQRCode() {
  const sessionId = generateSessionId();
  const qrCodeUrl = `https://api.example.com/qr-login?session=${sessionId}`;
  
  // 生成二维码图片
  const qrCode = generateQRCodeImage(qrCodeUrl);
  
  // 建立 WebSocket 连接
  const ws = new WebSocket(`wss://api.example.com/ws/login?session=${sessionId}`);
  
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    switch (data.type) {
      case 'scanned':
        showScannedStatus();
        break;
      case 'confirmed':
        handleLoginSuccess(data.token);
        break;
      case 'expired':
        showExpiredStatus();
        break;
    }
  };
  
  return { qrCode, ws };
}

// 后端实现
// 1. 生成二维码时创建 session
app.get('/qr-login', (req, res) => {
  const sessionId = generateSessionId();
  const qrCodeUrl = `https://api.example.com/qr-login?session=${sessionId}`;
  
  // 生成二维码图片
  const qrCode = generateQRCodeImage(qrCodeUrl);
  
  // 存储 session 信息
  sessions.set(sessionId, {
    status: 'waiting',
    createdAt: Date.now()
  });
  
  res.json({ qrCode, sessionId });
});

// 2. 扫码确认
app.post('/qr-login/scan', (req, res) => {
  const { sessionId, userId } = req.body;
  
  const session = sessions.get(sessionId);
  if (session && session.status === 'waiting') {
    session.status = 'scanned';
    session.userId = userId;
    
    // 通知前端
    notifyClient(sessionId, { type: 'scanned' });
    
    res.json({ success: true });
  }
});

// 3. 确认登录
app.post('/qr-login/confirm', (req, res) => {
  const { sessionId } = req.body;
  
  const session = sessions.get(sessionId);
  if (session && session.status === 'scanned') {
    // 生成 token
    const token = generateToken(session.userId);
    
    session.status = 'confirmed';
    session.token = token;
    
    // 通知前端
    notifyClient(sessionId, { type: 'confirmed', token });
    
    res.json({ success: true, token });
  }
});
```

**方案 2：基于轮询的简单实现**
```javascript
function QRCodeLogin() {
  const [sessionId, setSessionId] = useState('');
  const [status, setStatus] = useState('waiting');
  const [token, setToken] = useState('');
  
  // 生成二维码
  useEffect(() => {
    const id = generateSessionId();
    setSessionId(id);
    generateQRCode(id);
    
    // 轮询检查登录状态
    const interval = setInterval(async () => {
      try {
        const response = await fetch(`/api/qr-login/status?session=${id}`);
        const data = await response.json();
        
        setStatus(data.status);
        
        if (data.status === 'confirmed') {
          setToken(data.token);
          clearInterval(interval);
        }
      } catch (error) {
        console.error('检查登录状态失败:', error);
      }
    }, 2000);
    
    return () => clearInterval(interval);
  }, []);
  
  return (
    <div>
      <div id="qrcode"></div>
      {status === 'waiting' && <p>请使用手机扫码登录</p>}
      {status === 'scanned' && <p>已扫码，请在手机上确认</p>}
      {status === 'confirmed' && <p>登录成功！</p>}
    </div>
  );
}
```

**方案 3：移动端扫码确认**
```javascript
// 移动端扫码后显示确认页面
function ScanConfirm({ sessionId, userId }) {
  const [confirmed, setConfirmed] = useState(false);
  
  const handleConfirm = async () => {
    try {
      const response = await fetch('/api/qr-login/confirm', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sessionId, userId })
      });
      
      const data = await response.json();
      
      if (data.success) {
        setConfirmed(true);
        setTimeout(() => {
          window.close();
        }, 1000);
      }
    } catch (error) {
      console.error('确认失败:', error);
    }
  };
  
  return (
    <div>
      {confirmed ? (
        <div>确认成功，页面将自动关闭</div>
      ) : (
        <div>
          <h2>确认登录</h2>
          <p>您正在登录到：<strong>应用名称</strong></p>
          <button onClick={handleConfirm}>确认登录</button>
        </div>
      )}
    </div>
  );
}
```

**安全措施：**

1. **Session 过期**
```javascript
// 定期清理过期 session
setInterval(() => {
  const now = Date.now();
  const expiredSessions = [];
  
  sessions.forEach((session, sessionId) => {
    if (now - session.createdAt > 5 * 60 * 1000) { // 5分钟过期
      expiredSessions.push(sessionId);
    }
  });
  
  expiredSessions.forEach(sessionId => {
    sessions.delete(sessionId);
    notifyClient(sessionId, { type: 'expired' });
  });
}, 60000);
```

2. **一次性使用**
```javascript
app.post('/qr-login/confirm', (req, res) => {
  const { sessionId } = req.body;
  
  const session = sessions.get(sessionId);
  if (session && session.status === 'scanned') {
    // 检查是否已使用
    if (session.used) {
      return res.status(400).json({ error: '二维码已使用' });
    }
    
    // 标记为已使用
    session.used = true;
    
    // 生成 token
    const token = generateToken(session.userId);
    
    // ... 其他逻辑
  }
});
```

3. **防重放攻击**
```javascript
// 使用 nonce 防止重放
app.post('/qr-login/confirm', (req, res) => {
  const { sessionId, nonce, signature } = req.body;
  
  // 验证签名
  const expectedSignature = generateSignature(sessionId, nonce);
  if (signature !== expectedSignature) {
    return res.status(403).json({ error: '签名验证失败' });
  }
  
  // 检查 nonce 是否已使用
  if (usedNonces.has(nonce)) {
    return res.status(400).json({ error: '请求已处理' });
  }
  
  usedNonces.add(nonce);
  
  // ... 其他逻辑
});
```

**优化技巧：**

1. **二维码美化**
```javascript
function generateStyledQRCode(url) {
  const qr = new QRCode({
    text: url,
    width: 200,
    height: 200,
    colorDark: '#000000',
    colorLight: '#ffffff',
    correctLevel: QRCode.CorrectLevel.H
  });
  
  return qr;
}
```

2. **本地存储 token**
```javascript
function saveToken(token) {
  localStorage.setItem('auth_token', token);
  sessionStorage.setItem('auth_token', token);
}

function getToken() {
  return localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');
}
```

3. **自动刷新 token**
```javascript
function setupTokenRefresh() {
  const token = getToken();
  const decoded = decodeJWT(token);
  const expiresIn = decoded.exp - Date.now() / 1000;
  
  // 在过期前 5 分钟刷新
  setTimeout(async () => {
    const newToken = await refreshToken();
    saveToken(newToken);
    setupTokenRefresh();
  }, (expiresIn - 300) * 1000);
}
```

---

## 总结

腾讯面试题重点掌握：

### 前端基础
1. **性能优化**：加载、运行、渲染优化
2. **监控系统**：错误监控、性能监控
3. **路由系统**：Hash路由、History路由、动态路由
4. **虚拟滚动**：大数据量列表优化
5. **图片懒加载**：Intersection Observer API
6. **防抖节流**：性能优化、用户体验

### 算法题
1. **LRU 缓存**：使用 Map 实现 O(1) 时间复杂度
2. **防抖函数**：支持立即执行、取消、立即执行

### 场景题
1. **实际应用**：将算法应用到实际场景
2. **扩展性**：考虑边界情况和优化
3. **代码质量**：清晰、可维护、可测试
4. **用户体验**：进度条、下拉刷新、扫码登录
5. **性能优化**：资源加载、交互优化
6. **安全考虑**：防重放、防过期、一次性使用

**面试准备建议：**
1. 深入理解原理，不要只背答案
2. 多写代码，注重代码质量
3. 关注最新技术趋势
4. 准备项目经验，能讲清楚技术选型和难点
5. 保持学习热情和解决问题的能力

**答案：**

```javascript
// Hash 路由实现
class HashRouter {
  constructor() {
    this.routes = {};
    this.currentUrl = '';
    this.init();
  }
  
  init() {
    // 监听 hash 变化
    window.addEventListener('hashchange', this.handleHashChange.bind(this));
    window.addEventListener('load', this.handleHashChange.bind(this));
  }
  
  // 注册路由
  register(path, handler) {
    this.routes[path] = handler;
  }
  
  // 处理 hash 变化
  handleHashChange() {
    const hash = window.location.hash.slice(1) || '/';
    this.currentUrl = hash;
    this.matchRoute(hash);
  }
  
  // 路由匹配
  matchRoute(path) {
    // 精确匹配
    if (this.routes[path]) {
      this.routes[path]();
      return;
    }
    
    // 动态路由匹配
    for (const route in this.routes) {
      const params = this.matchDynamicRoute(route, path);
      if (params) {
        this.routes[route](params);
        return;
      }
    }
    
    // 404 处理
    if (this.routes['*']) {
      this.routes['*']();
    }
  }
  
  // 动态路由匹配
  matchDynamicRoute(route, path) {
    const routeParts = route.split('/');
    const pathParts = path.split('/');
    
    if (routeParts.length !== pathParts.length) {
      return null;
    }
    
    const params = {};
    
    for (let i = 0; i < routeParts.length; i++) {
      const routePart = routeParts[i];
      const pathPart = pathParts[i];
      
      if (routePart.startsWith(':')) {
        params[routePart.slice(1)] = pathPart;
      } else if (routePart !== pathPart) {
        return null;
      }
    }
    
    return params;
  }
  
  // 导航
  navigate(path) {
    window.location.hash = path;
  }
  
  // 替换
  replace(path) {
    window.location.replace(`#${path}`);
  }
  
  // 后退
  back() {
    window.history.back();
  }
  
  // 前进
  forward() {
    window.history.forward();
  }
}

// 使用
const router = new HashRouter();

router.register('/', () => {
  console.log('首页');
  renderHome();
});

router.register('/about', () => {
  console.log('关于');
  renderAbout();
});

router.register('/user/:id', (params) => {
  console.log('用户详情:', params.id);
  renderUserDetail(params.id);
});

router.register('*', () => {
  console.log('404');
  render404();
});

// History 路由实现
class HistoryRouter {
  constructor() {
    this.routes = {};
    this.init();
  }
  
  init() {
    // 监听 popstate 事件
    window.addEventListener('popstate', this.handlePopState.bind(this));
    window.addEventListener('load', this.handleLoad.bind(this));
  }
  
  register(path, handler) {
    this.routes[path] = handler;
  }
  
  handlePopState(event) {
    const path = window.location.pathname;
    this.matchRoute(path);
  }
  
  handleLoad() {
    const path = window.location.pathname;
    this.matchRoute(path);
  }
  
  matchRoute(path) {
    // 精确匹配
    if (this.routes[path]) {
      this.routes[path]();
      return;
    }
    
    // 动态路由匹配
    for (const route in this.routes) {
      const params = this.matchDynamicRoute(route, path);
      if (params) {
        this.routes[route](params);
        return;
      }
    }
    
    // 404 处理
    if (this.routes['*']) {
      this.routes['*']();
    }
  }
  
  matchDynamicRoute(route, path) {
    // 同 HashRouter 的实现
    const routeParts = route.split('/');
    const pathParts = path.split('/');
    
    if (routeParts.length !== pathParts.length) {
      return null;
    }
    
    const params = {};
    
    for (let i = 0; i < routeParts.length; i++) {
      const routePart = routeParts[i];
      const pathPart = pathParts[i];
      
      if (routePart.startsWith(':')) {
        params[routePart.slice(1)] = pathPart;
      } else if (routePart !== pathPart) {
        return null;
      }
    }
    
    return params;
  }
  
  navigate(path) {
    window.history.pushState({}, '', path);
    this.matchRoute(path);
  }
  
  replace(path) {
    window.history.replaceState({}, '', path);
    this.matchRoute(path);
  }
  
  back() {
    window.history.back();
  }
  
  forward() {
    window.history.forward();
  }
  
  // 需要服务器配置支持
  // 例如：所有路径都返回 index.html
}

// React Router 简化实现
function BrowserRouter({ children }) {
  const [location, setLocation] = useState(window.location.pathname);
  
  useEffect(() => {
    const handlePopState = () => {
      setLocation(window.location.pathname);
    };
    
    window.addEventListener('popstate', handlePopState);
    
    return () => {
      window.removeEventListener('popstate', handlePopState);
    };
  }, []);
  
  const navigate = (path) => {
    window.history.pushState({}, '', path);
    setLocation(path);
  };
  
  const routerContext = {
    location,
    navigate,
  };
  
  return (
    <RouterContext.Provider value={routerContext}>
      {children}
    </RouterContext.Provider>
  );
}

function Route({ path, component: Component }) {
  const { location } = useContext(RouterContext);
  
  const params = matchPath(path, location);
  
  if (params) {
    return <Component params={params} />;
  }
  
  return null;
}

function matchPath(routePath, currentPath) {
  const routeParts = routePath.split('/');
  const pathParts = currentPath.split('/');
  
  if (routeParts.length !== pathParts.length) {
    return null;
  }
  
  const params = {};
  
  for (let i = 0; i < routeParts.length; i++) {
    const routePart = routeParts[i];
    const pathPart = pathParts[i];
    
    if (routePart.startsWith(':')) {
      params[routePart.slice(1)] = pathPart;
    } else if (routePart !== pathPart) {
      return null;
    }
  }
  
  return params;
}

// 使用
function App() {
  return (
    <BrowserRouter>
      <Route path="/" component={Home} />
      <Route path="/about" component={About} />
      <Route path="/user/:id" component={UserDetail} />
    </BrowserRouter>
  );
}
```

---

## 总结

腾讯面试题重点掌握：

### 前端基础
1. **性能优化**：加载、运行、渲染优化
2. **监控系统**：错误监控、性能监控
3. **路由系统**：Hash路由、History路由、动态路由

### 算法题
1. **LRU 缓存**：使用 Map 实现 O(1) 时间复杂度
2. **防抖函数**：支持立即执行、取消、立即执行

### 场景题
1. **实际应用**：将算法应用到实际场景
2. **扩展性**：考虑边界情况和优化
3. **代码质量**：清晰、可维护、可测试

**面试准备建议：**
1. 深入理解原理，不要只背答案
2. 多写代码，注重代码质量
3. 关注最新技术趋势
4. 准备项目经验，能讲清楚技术选型和难点
5. 保持学习热情和解决问题的能力
