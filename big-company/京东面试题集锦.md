# 京东面试题集锦（截止 2025 年底）

## 目录
1. [前端基础](#前端基础)
2. [算法题](#算法题)
3. [场景题](#场景题)

---

## 前端基础

### 1. 如何实现一个前端路由守卫？

**答案：**

```javascript
// 路由守卫实现
class RouterGuard {
  constructor(router) {
    this.router = router;
    this.beforeHooks = [];
    this.afterHooks = [];
  }
  
  // 前置守卫
  beforeEach(guard) {
    this.beforeHooks.push(guard);
  }
  
  // 后置钩子
  afterEach(hook) {
    this.afterHooks.push(hook);
  }
  
  // 执行前置守卫
  async runBeforeHooks(to, from) {
    for (const guard of this.beforeHooks) {
      const result = await guard(to, from);
      
      if (result === false) {
        // 取消导航
        return false;
      }
      
      if (typeof result === 'string') {
        // 重定向
        this.router.push(result);
        return false;
      }
      
      if (result instanceof Promise) {
        const resolved = await result;
        if (resolved === false || typeof resolved === 'string') {
          if (typeof resolved === 'string') {
            this.router.push(resolved);
          }
          return false;
        }
      }
    }
    
    return true;
  }
  
  // 执行后置钩子
  runAfterHooks(to, from) {
    this.afterHooks.forEach(hook => {
      hook(to, from);
    });
  }
}

// 使用
const router = new HashRouter();
const guard = new RouterGuard(router);

// 权限检查
guard.beforeEach((to, from) => {
  const requiresAuth = to.meta?.requiresAuth;
  const isAuthenticated = checkAuth();
  
  if (requiresAuth && !isAuthenticated) {
    return '/login';
  }
});

// 页面标题
guard.afterEach((to, from) => {
  document.title = to.meta?.title || 'My App';
});
```

---

### 2. 如何实现一个前端日志系统？

**答案：**

```javascript
// 日志系统实现
class Logger {
  constructor(options = {}) {
    this.level = options.level || 'info';
    this.levels = {
      debug: 0,
      info: 1,
      warn: 2,
      error: 3,
    };
    this.handlers = options.handlers || [];
    this.context = options.context || {};
  }
  
  // 设置日志级别
  setLevel(level) {
    this.level = level;
  }
  
  // 添加处理器
  addHandler(handler) {
    this.handlers.push(handler);
  }
  
  // 设置上下文
  setContext(context) {
    this.context = { ...this.context, ...context };
  }
  
  // 记录日志
  log(level, message, meta = {}) {
    if (this.levels[level] < this.levels[this.level]) {
      return;
    }
    
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context: { ...this.context },
      meta,
    };
    
    this.handlers.forEach(handler => {
      handler(logEntry);
    });
  }
  
  debug(message, meta) {
    this.log('debug', message, meta);
  }
  
  info(message, meta) {
    this.log('info', message, meta);
  }
  
  warn(message, meta) {
    this.log('warn', message, meta);
  }
  
  error(message, meta) {
    this.log('error', message, meta);
  }
}

// 控制台处理器
function consoleHandler(entry) {
  const { timestamp, level, message, meta } = entry;
  const prefix = `[${timestamp}] [${level.toUpperCase()}]`;
  
  switch (level) {
    case 'debug':
      console.debug(prefix, message, meta);
      break;
    case 'info':
      console.info(prefix, message, meta);
      break;
    case 'warn':
      console.warn(prefix, message, meta);
      break;
    case 'error':
      console.error(prefix, message, meta);
      break;
  }
}

// 远程处理器
function remoteHandler(url) {
  const queue = [];
  let timer = null;
  
  return function(entry) {
    queue.push(entry);
    
    if (!timer) {
      timer = setTimeout(() => {
        fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(queue),
        }).catch(err => {
          console.error('日志上报失败:', err);
        });
        
        queue.length = 0;
        timer = null;
      }, 1000);
    }
  };
}

// 使用
const logger = new Logger({
  level: 'debug',
  handlers: [
    consoleHandler,
    remoteHandler('https://logs.example.com/api/logs'),
  ],
  context: {
    app: 'MyApp',
    version: '1.0.0',
  },
});
```

---

## 算法题

### 3. 实现一个二分查找

**答案：**

```javascript
// 二分查找
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return -1;
}

// 递归实现
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
  if (left > right) {
    return -1;
  }
  
  const mid = Math.floor((left + right) / 2);
  
  if (arr[mid] === target) {
    return mid;
  } else if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, right);
  } else {
    return binarySearchRecursive(arr, target, left, mid - 1);
  }
}

// 查找第一个等于 target 的位置
function binarySearchFirst(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = -1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      result = mid;
      right = mid - 1; // 继续向左查找
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return result;
}

// 查找最后一个等于 target 的位置
function binarySearchLast(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = -1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      result = mid;
      left = mid + 1; // 继续向右查找
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return result;
}

// 查找第一个大于等于 target 的位置
function binarySearchLowerBound(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = arr.length;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] >= target) {
      result = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  
  return result;
}

// 查找第一个大于 target 的位置
function binarySearchUpperBound(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = arr.length;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] > target) {
      result = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  
  return result;
}
```

---

### 4. 实现一个深拷贝

**答案：**

```javascript
// 深拷贝实现
function deepClone(obj, map = new WeakMap()) {
  // 处理基本类型
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理日期
  if (obj instanceof Date) {
    return new Date(obj);
  }
  
  // 处理正则表达式
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  
  // 处理 Map
  if (obj instanceof Map) {
    const cloned = new Map();
    obj.forEach((value, key) => {
      cloned.set(deepClone(key, map), deepClone(value, map));
    });
    return cloned;
  }
  
  // 处理 Set
  if (obj instanceof Set) {
    const cloned = new Set();
    obj.forEach(value => {
      cloned.add(deepClone(value, map));
    });
    return cloned;
  }
  
  // 处理数组
  if (Array.isArray(obj)) {
    return obj.map(item => deepClone(item, map));
  }
  
  // 处理循环引用
  if (map.has(obj)) {
    return map.get(obj);
  }
  
  // 处理普通对象
  const cloned = {};
  map.set(obj, cloned);
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone(obj[key], map);
    }
  }
  
  // 处理 Symbol
  const symbolKeys = Object.getOwnPropertySymbols(obj);
  for (const key of symbolKeys) {
    cloned[key] = deepClone(obj[key], map);
  }
  
  return cloned;
}
```

---

## 场景题

### 5. 如何实现一个表单验证？

**答案：**

```javascript
class FormValidator {
  constructor(rules = {}) {
    this.rules = rules;
    this.errors = {};
  }
  
  // 添加验证规则
  addRule(field, rule) {
    if (!this.rules[field]) {
      this.rules[field] = [];
    }
    this.rules[field].push(rule);
  }
  
  // 验证单个字段
  validateField(field, value) {
    const fieldRules = this.rules[field];
    if (!fieldRules) {
      return [];
    }
    
    const errors = [];
    
    for (const rule of fieldRules) {
      const result = rule.validator(value);
      if (!result.valid) {
        errors.push(rule.message);
      }
    }
    
    return errors;
  }
  
  // 验证整个表单
  validate(data) {
    this.errors = {};
    let isValid = true;
    
    for (const field in this.rules) {
      const fieldErrors = this.validateField(field, data[field]);
      if (fieldErrors.length > 0) {
        this.errors[field] = fieldErrors;
        isValid = false;
      }
    }
    
    return isValid;
  }
  
  // 获取错误信息
  getErrors() {
    return this.errors;
  }
  
  // 清除错误
  clearErrors() {
    this.errors = {};
  }
}

// 使用
const validator = new FormValidator({
  username: [
    {
      validator: (value) => ({
        valid: value && value.length >= 3,
      }),
      message: '用户名至少3个字符',
    },
    {
      validator: (value) => ({
        valid: /^[a-zA-Z0-9_]+$/.test(value),
      }),
      message: '用户名只能包含字母、数字和下划线',
    },
  ],
  email: [
    {
      validator: (value) => ({
        valid: /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
      }),
      message: '邮箱格式不正确',
    },
  ],
});

const formData = {
  username: 'ab',
  email: 'invalid-email',
};

const isValid = validator.validate(formData);
if (!isValid) {
  console.log(validator.getErrors());
  // {
  //   username: ['用户名至少3个字符'],
  //   email: ['邮箱格式不正确']
  // }
}
```

### 6. 如何实现图片懒加载？

**答案：**

图片懒加载是提升页面性能的重要手段，特别是对于图片密集型的电商网站。

**实现方案：**

**方案 1：基于 Intersection Observer API**
```javascript
class LazyImageLoader {
  constructor(options = {}) {
    this.options = {
      rootMargin: '200px', // 提前200px开始加载
      threshold: 0.01,
      ...options
    };
    
    this.observer = null;
    this.init();
  }
  
  init() {
    if ('IntersectionObserver' in window) {
      this.observer = new IntersectionObserver(
        this.handleIntersection.bind(this),
        this.options
      );
    } else {
      // 降级方案：使用 scroll 事件
      this.initFallback();
    }
  }
  
  observe(element) {
    if (this.observer) {
      this.observer.observe(element);
    }
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        this.loadImage(img);
        this.observer.unobserve(img);
      }
    });
  }
  
  loadImage(img) {
    const src = img.dataset.src;
    
    if (src) {
      // 创建新图片预加载
      const tempImg = new Image();
      
      tempImg.onload = () => {
        img.src = src;
        img.classList.add('loaded');
        img.removeAttribute('data-src');
      };
      
      tempImg.onerror = () => {
        img.classList.add('error');
        img.src = img.dataset.error || this.options.errorImage;
      };
      
      tempImg.src = src;
    }
  }
  
  initFallback() {
    let ticking = false;
    
    window.addEventListener('scroll', () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          this.checkImages();
          ticking = false;
        });
        ticking = true;
      }
    });
    
    // 初始检查
    this.checkImages();
  }
  
  checkImages() {
    const images = document.querySelectorAll('img[data-src]');
    const windowHeight = window.innerHeight;
    
    images.forEach(img => {
      const rect = img.getBoundingClientRect();
      
      if (rect.top < windowHeight + parseInt(this.options.rootMargin)) {
        this.loadImage(img);
      }
    });
  }
  
  destroy() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
}

// 使用
const lazyLoader = new LazyImageLoader({
  rootMargin: '300px',
  errorImage: '/error.png'
});

// 自动初始化所有懒加载图片
document.querySelectorAll('img[data-src]').forEach(img => {
  lazyLoader.observe(img);
});
```

**方案 2：React 组件实现**
```javascript
import { useState, useEffect, useRef } from 'react';

function LazyImage({ src, alt, placeholder, errorImage, ...props }) {
  const [loaded, setLoaded] = useState(false);
  const [error, setError] = useState(false);
  const imgRef = useRef(null);
  
  useEffect(() => {
    const img = imgRef.current;
    
    if (!img) return;
    
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            loadImage();
            observer.unobserve(entry.target);
          }
        });
      },
      {
        rootMargin: '200px',
        threshold: 0.01
      }
    );
    
    observer.observe(img);
    
    return () => observer.disconnect();
  }, [src]);
  
  const loadImage = () => {
    const tempImg = new Image();
    
    tempImg.onload = () => {
      setLoaded(true);
    };
    
    tempImg.onerror = () => {
      setError(true);
    };
    
    tempImg.src = src;
  };
  
  return (
    <img
      ref={imgRef}
      src={loaded ? src : placeholder}
      alt={alt}
      onError={(e) => {
        if (error) {
          e.target.src = errorImage;
        }
      }}
      {...props}
      style={{
        opacity: loaded ? 1 : 0.5,
        transition: 'opacity 0.3s ease',
        ...props.style
      }}
    />
  );
}

// 使用
function ProductList({ products }) {
  return (
    <div>
      {products.map(product => (
        <div key={product.id}>
          <LazyImage
            src={product.image}
            alt={product.name}
            placeholder="/placeholder.png"
            errorImage="/error.png"
            width={200}
            height={200}
          />
          <h3>{product.name}</h3>
        </div>
      ))}
    </div>
  );
}
```

**方案 3：Vue 指令实现**
```javascript
// lazy-image.js
export default {
  mounted(el, binding) {
    const src = binding.value;
    const placeholder = el.getAttribute('data-placeholder') || '';
    const errorImage = el.getAttribute('data-error') || '';
    
    el.src = placeholder;
    
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = new Image();
            
            img.onload = () => {
              el.src = src;
              el.classList.add('loaded');
            };
            
            img.onerror = () => {
              el.src = errorImage;
              el.classList.add('error');
            };
            
            img.src = src;
            observer.unobserve(entry.target);
          }
        });
      },
      {
        rootMargin: '200px',
        threshold: 0.01
      }
    );
    
    observer.observe(el);
    
    // 保存 observer 以便销毁
    el._lazyObserver = observer;
  },
  
  unmounted(el) {
    if (el._lazyObserver) {
      el._lazyObserver.disconnect();
    }
  }
};

// main.js
import { createApp } from 'vue';
import LazyImage from './directives/lazy-image';

const app = createApp(App);
app.directive('lazy', LazyImage);

// 使用
<template>
  <img v-lazy="product.image" :data-placeholder="placeholder" :data-error="errorImage" />
</template>
```

**方案 4：响应式图片懒加载**
```javascript
class ResponsiveLazyImage {
  constructor(element, options = {}) {
    this.element = element;
    this.options = {
      breakpoints: {
        mobile: '(max-width: 767px)',
        tablet: '(min-width: 768px) and (max-width: 1023px)',
        desktop: '(min-width: 1024px)'
      },
      ...options
    };
    
    this.init();
  }
  
  init() {
    // 根据屏幕尺寸选择合适的图片
    const src = this.selectImage();
    
    if (src) {
      this.loadImage(src);
    }
  }
  
  selectImage() {
    const { breakpoints } = this.options;
    const width = window.innerWidth;
    
    if (window.matchMedia(breakpoints.mobile).matches) {
      return this.element.dataset.srcMobile;
    } else if (window.matchMedia(breakpoints.tablet).matches) {
      return this.element.dataset.srcTablet;
    } else {
      return this.element.dataset.srcDesktop;
    }
  }
  
  loadImage(src) {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = new Image();
            
            img.onload = () => {
              this.element.src = src;
              this.element.classList.add('loaded');
            };
            
            img.onerror = () => {
              this.element.src = this.element.dataset.error;
              this.element.classList.add('error');
            };
            
            img.src = src;
            observer.unobserve(entry.target);
          }
        });
      },
      {
        rootMargin: '200px'
      }
    );
    
    observer.observe(this.element);
  }
}

// 使用
<img
  data-src-mobile="/image-mobile.jpg"
  data-src-tablet="/image-tablet.jpg"
  data-src-desktop="/image-desktop.jpg"
  data-error="/error.jpg"
  class="lazy-image"
  alt="Product"
/>
```

**优化技巧：**

1. **使用 WebP 格式**
```javascript
function getOptimalImage(src) {
  // 检查浏览器是否支持 WebP
  if (supportsWebP()) {
    return src.replace(/\.(jpg|jpeg|png)$/i, '.webp');
  }
  return src;
}

function supportsWebP() {
  return document.createElement('canvas')
    .toDataURL('image/webp')
    .indexOf('data:image/webp') === 0;
}
```

2. **预加载关键图片**
```javascript
// 预加载首屏图片
function preloadCriticalImages() {
  const criticalImages = document.querySelectorAll('.critical-image');
  
  criticalImages.forEach(img => {
    const src = img.dataset.src;
    if (src) {
      const tempImg = new Image();
      tempImg.src = src;
    }
  });
}
```

3. **使用占位图**
```javascript
// 生成 SVG 占位图
function generatePlaceholder(width, height, color = '#f0f0f0') {
  return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(`
    <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">
      <rect width="100%" height="100%" fill="${color}"/>
    </svg>
  `)}`;
}
```

---

### 7. 如何实现一个电商购物车系统？

**答案：**

电商购物车系统需要考虑商品管理、价格计算、库存检查等多个方面。

**方案设计：**

**方案 1：基于 Redux 的购物车**
```javascript
// 购物车状态管理
const initialState = {
  items: [],
  total: 0,
  count: 0,
  loading: false,
  error: null
};

// Action Types
const ADD_TO_CART = 'ADD_TO_CART';
const REMOVE_FROM_CART = 'REMOVE_FROM_CART';
const UPDATE_QUANTITY = 'UPDATE_QUANTITY';
const CLEAR_CART = 'CLEAR_CART';
const APPLY_COUPON = 'APPLY_COUPON';

// Action Creators
export const addToCart = (product, quantity = 1) => ({
  type: ADD_TO_CART,
  payload: { product, quantity }
});

export const removeFromCart = (productId) => ({
  type: REMOVE_FROM_CART,
  payload: { productId }
});

export const updateQuantity = (productId, quantity) => ({
  type: UPDATE_QUANTITY,
  payload: { productId, quantity }
});

export const clearCart = () => ({
  type: CLEAR_CART
});

export const applyCoupon = (couponCode) => ({
  type: APPLY_COUPON,
  payload: { couponCode }
});

// Reducer
export default function cartReducer(state = initialState, action) {
  switch (action.type) {
    case ADD_TO_CART: {
      const { product, quantity } = action.payload;
      const existingItem = state.items.find(item => item.id === product.id);
      
      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =>
            item.id === product.id
              ? { ...item, quantity: item.quantity + quantity }
              : item
          ),
          ...calculateTotals(
            state.items.map(item =>
              item.id === product.id
                ? { ...item, quantity: item.quantity + quantity }
                : item
            )
          )
        };
      }
      
      return {
        ...state,
        items: [...state.items, { ...product, quantity }],
        ...calculateTotals([...state.items, { ...product, quantity }])
      };
    }
    
    case REMOVE_FROM_CART: {
      const { productId } = action.payload;
      const newItems = state.items.filter(item => item.id !== productId);
      
      return {
        ...state,
        items: newItems,
        ...calculateTotals(newItems)
      };
    }
    
    case UPDATE_QUANTITY: {
      const { productId, quantity } = action.payload;
      
      if (quantity <= 0) {
        const newItems = state.items.filter(item => item.id !== productId);
        return {
          ...state,
          items: newItems,
          ...calculateTotals(newItems)
        };
      }
      
      const newItems = state.items.map(item =>
        item.id === productId ? { ...item, quantity } : item
      );
      
      return {
        ...state,
        items: newItems,
        ...calculateTotals(newItems)
      };
    }
    
    case CLEAR_CART: {
      return initialState;
    }
    
    default:
      return state;
  }
}

// 计算总价和数量
function calculateTotals(items) {
  const total = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  const count = items.reduce((sum, item) => sum + item.quantity, 0);
  
  return { total, count };
}

// 选择器
export const selectCartItems = state => state.cart.items;
export const selectCartTotal = state => state.cart.total;
export const selectCartCount = state => state.cart.count;
```

**方案 2：React Hooks 实现**
```javascript
import { useState, useEffect, useMemo } from 'react';

function useShoppingCart() {
  const [cart, setCart] = useState({
    items: [],
    coupon: null
  });
  
  // 计算总价
  const total = useMemo(() => {
    return cart.items.reduce((sum, item) => {
      return sum + item.price * item.quantity;
    }, 0);
  }, [cart.items]);
  
  // 计算折扣
  const discount = useMemo(() => {
    if (!cart.coupon) return 0;
    
    switch (cart.coupon.type) {
      case 'percentage':
        return total * (cart.coupon.value / 100);
      case 'fixed':
        return cart.coupon.value;
      default:
        return 0;
    }
  }, [total, cart.coupon]);
  
  // 最终价格
  const finalTotal = total - discount;
  
  // 添加商品
  const addToCart = (product, quantity = 1) => {
    setCart(prevCart => {
      const existingItem = prevCart.items.find(item => item.id === product.id);
      
      if (existingItem) {
        return {
          ...prevCart,
          items: prevCart.items.map(item =>
            item.id === product.id
              ? { ...item, quantity: item.quantity + quantity }
              : item
          )
        };
      }
      
      return {
        ...prevCart,
        items: [...prevCart.items, { ...product, quantity }]
      };
    });
  };
  
  // 移除商品
  const removeFromCart = (productId) => {
    setCart(prevCart => ({
      ...prevCart,
      items: prevCart.items.filter(item => item.id !== productId)
    }));
  };
  
  // 更新数量
  const updateQuantity = (productId, quantity) => {
    if (quantity <= 0) {
      removeFromCart(productId);
      return;
    }
    
    setCart(prevCart => ({
      ...prevCart,
      items: prevCart.items.map(item =>
        item.id === productId ? { ...item, quantity } : item
      )
    }));
  };
  
  // 应用优惠券
  const applyCoupon = (coupon) => {
    setCart(prevCart => ({
      ...prevCart,
      coupon
    }));
  };
  
  // 清空购物车
  const clearCart = () => {
    setCart({
      items: [],
      coupon: null
    });
  };
  
  // 持久化到 localStorage
  useEffect(() => {
    localStorage.setItem('cart', JSON.stringify(cart));
  }, [cart]);
  
  return {
    cart,
    total,
    discount,
    finalTotal,
    addToCart,
    removeFromCart,
    updateQuantity,
    applyCoupon,
    clearCart
  };
}

// 使用
function ShoppingCart() {
  const {
    cart,
    total,
    discount,
    finalTotal,
    addToCart,
    removeFromCart,
    updateQuantity,
    applyCoupon,
    clearCart
  } = useShoppingCart();
  
  return (
    <div>
      <h2>购物车</h2>
      
      {cart.items.map(item => (
        <div key={item.id}>
          <h3>{item.name}</h3>
          <p>价格: ¥{item.price}</p>
          <p>数量: {item.quantity}</p>
          <button onClick={() => updateQuantity(item.id, item.quantity - 1)}>-</button>
          <button onClick={() => updateQuantity(item.id, item.quantity + 1)}>+</button>
          <button onClick={() => removeFromCart(item.id)}>删除</button>
        </div>
      ))}
      
      <div>
        <p>小计: ¥{total}</p>
        {discount > 0 && <p>折扣: -¥{discount}</p>}
        <p>总计: ¥{finalTotal}</p>
      </div>
      
      <button onClick={clearCart}>清空购物车</button>
    </div>
  );
}
```

**方案 3：Vue 3 Composition API 实现**
```javascript
import { ref, computed, watch } from 'vue';

export function useShoppingCart() {
  const cart = ref({
    items: [],
    coupon: null
  });
  
  // 计算总价
  const total = computed(() => {
    return cart.value.items.reduce((sum, item) => {
      return sum + item.price * item.quantity;
    }, 0);
  });
  
  // 计算折扣
  const discount = computed(() => {
    if (!cart.value.coupon) return 0;
    
    switch (cart.value.coupon.type) {
      case 'percentage':
        return total.value * (cart.value.coupon.value / 100);
      case 'fixed':
        return cart.value.coupon.value;
      default:
        return 0;
    }
  });
  
  // 最终价格
  const finalTotal = computed(() => total.value - discount.value);
  
  // 添加商品
  const addToCart = (product, quantity = 1) => {
    const existingItem = cart.value.items.find(item => item.id === product.id);
    
    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      cart.value.items.push({ ...product, quantity });
    }
  };
  
  // 移除商品
  const removeFromCart = (productId) => {
    cart.value.items = cart.value.items.filter(item => item.id !== productId);
  };
  
  // 更新数量
  const updateQuantity = (productId, quantity) => {
    if (quantity <= 0) {
      removeFromCart(productId);
      return;
    }
    
    const item = cart.value.items.find(item => item.id === productId);
    if (item) {
      item.quantity = quantity;
    }
  };
  
  // 应用优惠券
  const applyCoupon = (coupon) => {
    cart.value.coupon = coupon;
  };
  
  // 清空购物车
  const clearCart = () => {
    cart.value = {
      items: [],
      coupon: null
    };
  };
  
  // 持久化到 localStorage
  watch(
    cart,
    (newCart) => {
      localStorage.setItem('cart', JSON.stringify(newCart));
    },
    { deep: true }
  );
  
  return {
    cart,
    total,
    discount,
    finalTotal,
    addToCart,
    removeFromCart,
    updateQuantity,
    applyCoupon,
    clearCart
  };
}
```

**方案 4：库存管理**
```javascript
class InventoryManager {
  constructor() {
    this.inventory = new Map();
    this.reserved = new Map();
  }
  
  // 初始化库存
  initializeInventory(products) {
    products.forEach(product => {
      this.inventory.set(product.id, product.stock);
      this.reserved.set(product.id, 0);
    });
  }
  
  // 检查库存
  checkStock(productId, quantity) {
    const stock = this.inventory.get(productId) || 0;
    const reserved = this.reserved.get(productId) || 0;
    return stock - reserved >= quantity;
  }
  
  // 预留库存
  reserveStock(productId, quantity) {
    if (!this.checkStock(productId, quantity)) {
      return false;
    }
    
    const currentReserved = this.reserved.get(productId) || 0;
    this.reserved.set(productId, currentReserved + quantity);
    return true;
  }
  
  // 释放预留库存
  releaseReservedStock(productId, quantity) {
    const currentReserved = this.reserved.get(productId) || 0;
    const newReserved = Math.max(0, currentReserved - quantity);
    this.reserved.set(productId, newReserved);
  }
  
  // 扣减库存
  deductStock(productId, quantity) {
    const currentReserved = this.reserved.get(productId) || 0;
    this.reserved.set(productId, Math.max(0, currentReserved - quantity));
    
    const currentStock = this.inventory.get(productId) || 0;
    this.inventory.set(productId, Math.max(0, currentStock - quantity));
  }
  
  // 获取可用库存
  getAvailableStock(productId) {
    const stock = this.inventory.get(productId) || 0;
    const reserved = this.reserved.get(productId) || 0;
    return stock - reserved;
  }
}
```

---

## 总结

京东面试题重点掌握：

### 前端基础
1. **路由守卫**：权限控制、重定向、钩子
2. **日志系统**：日志级别、处理器、远程上报
3. **表单验证**：规则配置、错误处理
4. **图片懒加载**：Intersection Observer、性能优化
5. **购物车系统**：状态管理、价格计算、库存管理

### 算法题
1. **二分查找**：多种变体实现
2. **深拷贝**：考虑循环引用

### 场景题
1. **表单验证**：规则配置、错误处理
2. **图片懒加载**：多种实现方式、响应式图片
3. **购物车系统**：Redux、React Hooks、Vue Composition API
4. **库存管理**：预留库存、库存检查

**面试准备建议：**
1. 深入理解路由和权限控制
2. 掌握常见算法和数据结构
3. 熟悉表单验证最佳实践
4. 注重代码质量和可维护性
5. 了解电商场景的特殊需求
6. 掌握性能优化技巧