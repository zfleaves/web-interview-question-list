# 6. 如何实现图片懒加载？

**答案：**

图片懒加载是提升页面性能的重要手段，特别是对于图片密集型的电商网站。

**实现方案：**

**方案 1：基于 Intersection Observer API**
```javascript
class LazyImageLoader {
  constructor(options = {}) {
    this.options = {
      rootMargin: '200px', // 提前200px开始加载
      threshold: 0.01,
      ...options
    };
    
    this.observer = null;
    this.init();
  }
  
  init() {
    if ('IntersectionObserver' in window) {
      this.observer = new IntersectionObserver(
        this.handleIntersection.bind(this),
        this.options
      );
    } else {
      // 降级方案：使用 scroll 事件
      this.initFallback();
    }
  }
  
  observe(element) {
    if (this.observer) {
      this.observer.observe(element);
    }
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        this.loadImage(img);
        this.observer.unobserve(img);
      }
    });
  }
  
  loadImage(img) {
    const src = img.dataset.src;
    
    if (src) {
      // 创建新图片预加载
      const tempImg = new Image();
      
      tempImg.onload = () => {
        img.src = src;
        img.classList.add('loaded');
        img.removeAttribute('data-src');
      };
      
      tempImg.onerror = () => {
        img.classList.add('error');
        img.src = img.dataset.error || this.options.errorImage;
      };
      
      tempImg.src = src;
    }
  }
  
  initFallback() {
    let ticking = false;
    
    window.addEventListener('scroll', () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          this.checkImages();
          ticking = false;
        });
        ticking = true;
      }
    });
    
    // 初始检查
    this.checkImages();
  }
  
  checkImages() {
    const images = document.querySelectorAll('img[data-src]');
    const windowHeight = window.innerHeight;
    
    images.forEach(img => {
      const rect = img.getBoundingClientRect();
      
      if (rect.top < windowHeight + parseInt(this.options.rootMargin)) {
        this.loadImage(img);
      }
    });
  }
  
  destroy() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
}

// 使用
const lazyLoader = new LazyImageLoader({
  rootMargin: '300px',
  errorImage: '/error.png'
});

// 自动初始化所有懒加载图片
document.querySelectorAll('img[data-src]').forEach(img => {
  lazyLoader.observe(img);
});
```

**方案 2：React 组件实现**
```javascript
import { useState, useEffect, useRef } from 'react';

function LazyImage({ src, alt, placeholder, errorImage, ...props }) {
  const [loaded, setLoaded] = useState(false);
  const [error, setError] = useState(false);
  const imgRef = useRef(null);
  
  useEffect(() => {
    const img = imgRef.current;
    
    if (!img) return;
    
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            loadImage();
            observer.unobserve(entry.target);
          }
        });
      },
      {
        rootMargin: '200px',
        threshold: 0.01
      }
    );
    
    observer.observe(img);
    
    return () => observer.disconnect();
  }, [src]);
  
  const loadImage = () => {
    const tempImg = new Image();
    
    tempImg.onload = () => {
      setLoaded(true);
    };
    
    tempImg.onerror = () => {
      setError(true);
    };
    
    tempImg.src = src;
  };
  
  return (
    <img
      ref={imgRef}
      src={loaded ? src : placeholder}
      alt={alt}
      onError={(e) => {
        if (error) {
          e.target.src = errorImage;
        }
      }}
      {...props}
      style={{
        opacity: loaded ? 1 : 0.5,
        transition: 'opacity 0.3s ease',
        ...props.style
      }}
    />
  );
}

// 使用
function ProductList({ products }) {
  return (
    <div>
      {products.map(product => (
        <div key={product.id}>
          <LazyImage
            src={product.image}
            alt={product.name}
            placeholder="/placeholder.png"
            errorImage="/error.png"
            width={200}
            height={200}
          />
          <h3>{product.name}</h3>
        </div>
      ))}
    </div>
  );
}
```

**方案 3：Vue 指令实现**
```javascript
// lazy-image.js
export default {
  mounted(el, binding) {
    const src = binding.value;
    const placeholder = el.getAttribute('data-placeholder') || '';
    const errorImage = el.getAttribute('data-error') || '';
    
    el.src = placeholder;
    
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = new Image();
            
            img.onload = () => {
              el.src = src;
              el.classList.add('loaded');
            };
            
            img.onerror = () => {
              el.src = errorImage;
              el.classList.add('error');
            };
            
            img.src = src;
            observer.unobserve(entry.target);
          }
        });
      },
      {
        rootMargin: '200px',
        threshold: 0.01
      }
    );
    
    observer.observe(el);
    
    // 保存 observer 以便销毁
    el._lazyObserver = observer;
  },
  
  unmounted(el) {
    if (el._lazyObserver) {
      el._lazyObserver.disconnect();
    }
  }
};

// main.js
import { createApp } from 'vue';
import LazyImage from './directives/lazy-image';

const app = createApp(App);
app.directive('lazy', LazyImage);

// 使用
<template>
  <img v-lazy="product.image" :data-placeholder="placeholder" :data-error="errorImage" />
</template>
```

**方案 4：响应式图片懒加载**
```javascript
class ResponsiveLazyImage {
  constructor(element, options = {}) {
    this.element = element;
    this.options = {
      breakpoints: {
        mobile: '(max-width: 767px)',
        tablet: '(min-width: 768px) and (max-width: 1023px)',
        desktop: '(min-width: 1024px)'
      },
      ...options
    };
    
    this.init();
  }
  
  init() {
    // 根据屏幕尺寸选择合适的图片
    const src = this.selectImage();
    
    if (src) {
      this.loadImage(src);
    }
  }
  
  selectImage() {
    const { breakpoints } = this.options;
    const width = window.innerWidth;
    
    if (window.matchMedia(breakpoints.mobile).matches) {
      return this.element.dataset.srcMobile;
    } else if (window.matchMedia(breakpoints.tablet).matches) {
      return this.element.dataset.srcTablet;
    } else {
      return this.element.dataset.srcDesktop;
    }
  }
  
  loadImage(src) {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = new Image();
            
            img.onload = () => {
              this.element.src = src;
              this.element.classList.add('loaded');
            };
            
            img.onerror = () => {
              this.element.src = this.element.dataset.error;
              this.element.classList.add('error');
            };
            
            img.src = src;
            observer.unobserve(entry.target);
          }
        });
      },
      {
        rootMargin: '200px'
      }
    );
    
    observer.observe(this.element);
  }
}

// 使用
<img
  data-src-mobile="/image-mobile.jpg"
  data-src-tablet="/image-tablet.jpg"
  data-src-desktop="/image-desktop.jpg"
  data-error="/error.jpg"
  class="lazy-image"
  alt="Product"
/>
```

**优化技巧：**

1. **使用 WebP 格式**
```javascript
function getOptimalImage(src) {
  // 检查浏览器是否支持 WebP
  if (supportsWebP()) {
    return src.replace(/\.(jpg|jpeg|png)$/i, '.webp');
  }
  return src;
}

function supportsWebP() {
  return document.createElement('canvas')
    .toDataURL('image/webp')
    .indexOf('data:image/webp') === 0;
}
```

2. **预加载关键图片**
```javascript
// 预加载首屏图片
function preloadCriticalImages() {
  const criticalImages = document.querySelectorAll('.critical-image');
  
  criticalImages.forEach(img => {
    const src = img.dataset.src;
    if (src) {
      const tempImg = new Image();
      tempImg.src = src;
    }
  });
}
```

3. **使用占位图**
```javascript
// 生成 SVG 占位图
function generatePlaceholder(width, height, color = '#f0f0f0') {
  return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(`
    <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">
      <rect width="100%" height="100%" fill="${color}"/>
    </svg>
  `)}`;
}
```

---
