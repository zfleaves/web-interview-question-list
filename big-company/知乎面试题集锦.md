# çŸ¥ä¹é¢è¯•é¢˜é›†é”¦ï¼ˆæˆªæ­¢ 2025 å¹´åº•ï¼‰

## ç›®å½•
1. [å‰ç«¯åŸºç¡€](#å‰ç«¯åŸºç¡€)
2. [ç®—æ³•é¢˜](#ç®—æ³•é¢˜)
3. [åœºæ™¯é¢˜](#åœºæ™¯é¢˜)

---

## å‰ç«¯åŸºç¡€

### 1. å¦‚ä½•å®ç°ä¸€ä¸ªå‰ç«¯å¯Œæ–‡æœ¬ç¼–è¾‘å™¨ï¼Ÿ

**ç­”æ¡ˆï¼š**

```javascript
// å¯Œæ–‡æœ¬ç¼–è¾‘å™¨å®ç°
class RichTextEditor {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      toolbar: true,
      placeholder: 'è¯·è¾“å…¥å†…å®¹...',
      ...options,
    };
    
    this.init();
  }
  
  init() {
    // åˆ›å»ºç¼–è¾‘å™¨å®¹å™¨
    this.editor = document.createElement('div');
    this.editor.contentEditable = true;
    this.editor.className = 'rich-text-editor';
    this.editor.setAttribute('data-placeholder', this.options.placeholder);
    
    // åˆ›å»ºå·¥å…·æ 
    if (this.options.toolbar) {
      this.toolbar = this.createToolbar();
      this.container.appendChild(this.toolbar);
    }
    
    this.container.appendChild(this.editor);
    
    // ç»‘å®šäº‹ä»¶
    this.bindEvents();
  }
  
  createToolbar() {
    const toolbar = document.createElement('div');
    toolbar.className = 'rich-text-toolbar';
    
    const buttons = [
      { command: 'bold', icon: 'B', title: 'åŠ ç²—' },
      { command: 'italic', icon: 'I', title: 'æ–œä½“' },
      { command: 'underline', icon: 'U', title: 'ä¸‹åˆ’çº¿' },
      { command: 'strikeThrough', icon: 'S', title: 'åˆ é™¤çº¿' },
      { divider: true },
      { command: 'justifyLeft', icon: 'â†', title: 'å·¦å¯¹é½' },
      { command: 'justifyCenter', icon: 'â†”', title: 'å±…ä¸­' },
      { command: 'justifyRight', icon: 'â†’', title: 'å³å¯¹é½' },
      { divider: true },
      { command: 'insertUnorderedList', icon: 'â€¢', title: 'æ— åºåˆ—è¡¨' },
      { command: 'insertOrderedList', icon: '1.', title: 'æœ‰åºåˆ—è¡¨' },
      { divider: true },
      { command: 'createLink', icon: 'ğŸ”—', title: 'æ’å…¥é“¾æ¥' },
      { command: 'insertImage', icon: 'ğŸ–¼ï¸', title: 'æ’å…¥å›¾ç‰‡' },
    ];
    
    buttons.forEach(btn => {
      if (btn.divider) {
        const divider = document.createElement('span');
        divider.className = 'toolbar-divider';
        toolbar.appendChild(divider);
      } else {
        const button = document.createElement('button');
        button.className = 'toolbar-button';
        button.textContent = btn.icon;
        button.title = btn.title;
        button.addEventListener('click', () => this.executeCommand(btn.command));
        toolbar.appendChild(button);
      }
    });
    
    return toolbar;
  }
  
  bindEvents() {
    // ç›‘å¬è¾“å…¥äº‹ä»¶
    this.editor.addEventListener('input', () => {
      this.onInput();
    });
    
    // ç›‘å¬é€‰æ‹©å˜åŒ–
    document.addEventListener('selectionchange', () => {
      this.onSelectionChange();
    });
    
    // ç›‘å¬ç²˜è´´äº‹ä»¶
    this.editor.addEventListener('paste', (e) => {
      this.onPaste(e);
    });
  }
  
  executeCommand(command, value = null) {
    document.execCommand(command, false, value);
    this.editor.focus();
  }
  
  onInput() {
    if (this.options.onInput) {
      this.options.onInput(this.getHTML());
    }
  }
  
  onSelectionChange() {
    // æ›´æ–°å·¥å…·æ çŠ¶æ€
    const commands = ['bold', 'italic', 'underline', 'strikeThrough'];
    commands.forEach(command => {
      const isActive = document.queryCommandState(command);
      this.updateToolbarButton(command, isActive);
    });
  }
  
  updateToolbarButton(command, isActive) {
    const button = this.toolbar.querySelector(`[data-command="${command}"]`);
    if (button) {
      button.classList.toggle('active', isActive);
    }
  }
  
  onPaste(e) {
    e.preventDefault();
    
    // è·å–çº¯æ–‡æœ¬
    const text = e.clipboardData.getData('text/plain');
    document.execCommand('insertText', false, text);
  }
  
  getHTML() {
    return this.editor.innerHTML;
  }
  
  setHTML(html) {
    this.editor.innerHTML = html;
  }
  
  getText() {
    return this.editor.textContent;
  }
  
  focus() {
    this.editor.focus();
  }
  
  blur() {
    this.editor.blur();
  }
}
```

---

### 2. å¦‚ä½•å®ç°ä¸€ä¸ªå‰ç«¯å›¾ç‰‡å‹ç¼©ï¼Ÿ

**ç­”æ¡ˆï¼š**

```javascript
// å›¾ç‰‡å‹ç¼©å®ç°
class ImageCompressor {
  constructor(options = {}) {
    this.options = {
      quality: 0.8,
      maxWidth: 1920,
      maxHeight: 1080,
      mimeType: 'image/jpeg',
      ...options,
    };
  }
  
  async compress(file) {
    return new Promise((resolve, reject) => {
      // æ£€æŸ¥æ–‡ä»¶ç±»å‹
      if (!file.type.startsWith('image/')) {
        reject(new Error('æ–‡ä»¶å¿…é¡»æ˜¯å›¾ç‰‡'));
        return;
      }
      
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const img = new Image();
        
        img.onload = () => {
          const compressedFile = this._compressImage(img);
          resolve(compressedFile);
        };
        
        img.onerror = () => {
          reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
        };
        
        img.src = e.target.result;
      };
      
      reader.onerror = () => {
        reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
      };
      
      reader.readAsDataURL(file);
    });
  }
  
  _compressImage(img) {
    // è®¡ç®—æ–°å°ºå¯¸
    const { width, height } = this._calculateSize(img.width, img.height);
    
    // åˆ›å»º Canvas
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    
    // ç»˜åˆ¶å›¾ç‰‡
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, width, height);
    
    // å‹ç¼©
    const compressedDataUrl = canvas.toDataURL(this.options.mimeType, this.options.quality);
    
    // è½¬æ¢ä¸º File
    const compressedFile = this._dataURLToFile(compressedDataUrl, this.options.mimeType);
    
    return {
      file: compressedFile,
      dataUrl: compressedDataUrl,
      originalSize: img.width * img.height,
      compressedSize: width * height,
      originalFile: img.src,
    };
  }
  
  _calculateSize(width, height) {
    const { maxWidth, maxHeight } = this.options;
    
    let newWidth = width;
    let newHeight = height;
    
    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
    const ratio = Math.min(maxWidth / width, maxHeight / height);
    
    if (ratio < 1) {
      newWidth = Math.round(width * ratio);
      newHeight = Math.round(height * ratio);
    }
    
    return { width: newWidth, height: newHeight };
  }
  
  _dataURLToFile(dataURL, mimeType) {
    const arr = dataURL.split(',');
    const match = arr[0].match(/:(.*?);/);
    const mime = match ? match[1] : mimeType;
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    
    return new File([u8arr], 'compressed.jpg', { type: mime });
  }
  
  async compressMultiple(files) {
    const results = [];
    
    for (const file of files) {
      try {
        const compressed = await this.compress(file);
        results.push(compressed);
      } catch (error) {
        results.push({ error, file });
      }
    }
    
    return results;
  }
}
```

---

## ç®—æ³•é¢˜

### 3. å®ç°ä¸€ä¸ªå¸ƒéš†è¿‡æ»¤å™¨

**ç­”æ¡ˆï¼š**

```javascript
// å¸ƒéš†è¿‡æ»¤å™¨å®ç°
class BloomFilter {
  constructor(size = 1000, hashFunctions = []) {
    this.size = size;
    this.bitArray = new Array(size).fill(false);
    this.hashFunctions = hashFunctions.length > 0 
      ? hashFunctions 
      : [
          this._hash1,
          this._hash2,
          this._hash3,
        ];
  }
  
  // æ·»åŠ å…ƒç´ 
  add(element) {
    for (const hashFn of this.hashFunctions) {
      const index = hashFn.call(this, element) % this.size;
      this.bitArray[index] = true;
    }
  }
  
  // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
  contains(element) {
    for (const hashFn of this.hashFunctions) {
      const index = hashFn.call(this, element) % this.size;
      if (!this.bitArray[index]) {
        return false;
      }
    }
    return true;
  }
  
  // å“ˆå¸Œå‡½æ•° 1
  _hash1(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  
  // å“ˆå¸Œå‡½æ•° 2
  _hash2(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return Math.abs(hash);
  }
  
  // å“ˆå¸Œå‡½æ•° 3
  _hash3(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash ^ (hash >> 16);
    }
    return Math.abs(hash);
  }
}
```

---

### 4. å®ç°ä¸€ä¸ªä¸€è‡´æ€§å“ˆå¸Œ

**ç­”æ¡ˆï¼š**

```javascript
// ä¸€è‡´æ€§å“ˆå¸Œå®ç°
class ConsistentHash {
  constructor(virtualNodes = 150) {
    this.virtualNodes = virtualNodes;
    this.ring = new Map();
    this.sortedKeys = [];
  }
  
  // æ·»åŠ èŠ‚ç‚¹
  addNode(node) {
    for (let i = 0; i < this.virtualNodes; i++) {
      const virtualNodeKey = `${node}:${i}`;
      const hash = this._hash(virtualNodeKey);
      this.ring.set(hash, node);
      this.sortedKeys.push(hash);
    }
    
    this.sortedKeys.sort((a, b) => a - b);
  }
  
  // ç§»é™¤èŠ‚ç‚¹
  removeNode(node) {
    for (let i = 0; i < this.virtualNodes; i++) {
      const virtualNodeKey = `${node}:${i}`;
      const hash = this._hash(virtualNodeKey);
      this.ring.delete(hash);
      
      const index = this.sortedKeys.indexOf(hash);
      if (index > -1) {
        this.sortedKeys.splice(index, 1);
      }
    }
  }
  
  // è·å–èŠ‚ç‚¹
  getNode(key) {
    if (this.sortedKeys.length === 0) {
      return null;
    }
    
    const hash = this._hash(key);
    
    // äºŒåˆ†æŸ¥æ‰¾
    let left = 0;
    let right = this.sortedKeys.length - 1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      
      if (this.sortedKeys[mid] === hash) {
        return this.ring.get(hash);
      } else if (this.sortedKeys[mid] < hash) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œè¿”å›ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆç¯å½¢ï¼‰
    if (left >= this.sortedKeys.length) {
      return this.ring.get(this.sortedKeys[0]);
    }
    
    return this.ring.get(this.sortedKeys[left]);
  }
  
  // å“ˆå¸Œå‡½æ•°
  _hash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}
```

---

## åœºæ™¯é¢˜

### 5. å¦‚ä½•å®ç°ä¸€ä¸ªæ‹–æ‹½ä¸Šä¼ ç»„ä»¶ï¼Ÿ

**ç­”æ¡ˆï¼š**

```javascript
class DragUpload extends React.Component {
  state = {
    isDragging: false,
    files: []
  };
  
  handleDragEnter = (e) => {
    e.preventDefault();
    e.stopPropagation();
    this.setState({ isDragging: true });
  };
  
  handleDragLeave = (e) => {
    e.preventDefault();
    e.stopPropagation();
    this.setState({ isDragging: false });
  };
  
  handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  
  handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    this.setState({ isDragging: false });
    
    const files = Array.from(e.dataTransfer.files);
    this.handleFiles(files);
  };
  
  handleFiles = (files) => {
    this.setState(prevState => ({
      files: [...prevState.files, ...files]
    }));
    
    // ä¸Šä¼ æ–‡ä»¶
    files.forEach(file => this.uploadFile(file));
  };
  
  uploadFile = async (file) => {
    const formData = new FormData();
    formData.append('file', file);
    
    try {
      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });
      const data = await response.json();
      console.log('ä¸Šä¼ æˆåŠŸ:', data);
    } catch (error) {
      console.error('ä¸Šä¼ å¤±è´¥:', error);
    }
  };
  
  render() {
    const { isDragging, files } = this.state;
    
    return (
      <div>
        <div
          onDragEnter={this.handleDragEnter}
          onDragLeave={this.handleDragLeave}
          onDragOver={this.handleDragOver}
          onDrop={this.handleDrop}
          style={{
            border: `2px dashed ${isDragging ? '#1890ff' : '#d9d9d9'}`,
            padding: '40px',
            textAlign: 'center',
            backgroundColor: isDragging ? '#f0f9ff' : '#fafafa'
          }}
        >
          {isDragging ? 'é‡Šæ”¾æ–‡ä»¶ä»¥ä¸Šä¼ ' : 'æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„'}
        </div>
        
        <ul>
          {files.map((file, index) => (
            <li key={index}>{file.name}</li>
          ))}
        </ul>
      </div>
    );
  }
}
```

---

### 6. å¦‚ä½•å®ç°ä¸€ä¸ªå¯Œæ–‡æœ¬ç¼–è¾‘å™¨ï¼Ÿ

**ç­”æ¡ˆï¼š**

```javascript
class RichTextEditor extends React.Component {
  constructor(props) {
    super(props);
    this.editorRef = React.createRef();
    this.state = {
      content: ''
    };
  }
  
  componentDidMount() {
    if (this.editorRef.current) {
      this.editorRef.current.contentEditable = true;
      this.editorRef.current.addEventListener('input', this.handleInput);
    }
  }
  
  componentWillUnmount() {
    if (this.editorRef.current) {
      this.editorRef.current.removeEventListener('input', this.handleInput);
    }
  }
  
  handleInput = (e) => {
    this.setState({ content: e.target.innerHTML });
    if (this.props.onChange) {
      this.props.onChange(e.target.innerHTML);
    }
  };
  
  // æ‰§è¡Œå‘½ä»¤
  execCommand(command, value = null) {
    document.execCommand(command, false, value);
    this.editorRef.current.focus();
  };
  
  // åŠ ç²—
  bold = () => this.execCommand('bold');
  
  // æ–œä½“
  italic = () => this.execCommand('italic');
  
  // ä¸‹åˆ’çº¿
  underline = () => this.execCommand('underline');
  
  // æ ‡é¢˜
  setHeading = (level) => this.execCommand('formatBlock', `h${level}`);
  
  // åˆ—è¡¨
  insertList = (type) => this.execCommand(type === 'ul' ? 'insertUnorderedList' : 'insertOrderedList');
  
  // æ’å…¥é“¾æ¥
  insertLink = () => {
    const url = prompt('è¯·è¾“å…¥é“¾æ¥åœ°å€ï¼š');
    if (url) {
      this.execCommand('createLink', url);
    }
  };
  
  // æ’å…¥å›¾ç‰‡
  insertImage = () => {
    const url = prompt('è¯·è¾“å…¥å›¾ç‰‡åœ°å€ï¼š');
    if (url) {
      this.execCommand('insertImage', url);
    }
  };
  
  render() {
    return (
      <div className="rich-text-editor">
        <div className="toolbar">
          <button onClick={this.bold}>åŠ ç²—</button>
          <button onClick={this.italic}>æ–œä½“</button>
          <button onClick={this.underline}>ä¸‹åˆ’çº¿</button>
          <select onChange={(e) => this.setHeading(e.target.value)}>
            <option value="p">æ®µè½</option>
            <option value="h1">æ ‡é¢˜1</option>
            <option value="h2">æ ‡é¢˜2</option>
            <option value="h3">æ ‡é¢˜3</option>
          </select>
          <button onClick={() => this.insertList('ul')}>æ— åºåˆ—è¡¨</button>
          <button onClick={() => this.insertList('ol')}>æœ‰åºåˆ—è¡¨</button>
          <button onClick={this.insertLink}>æ’å…¥é“¾æ¥</button>
          <button onClick={this.insertImage}>æ’å…¥å›¾ç‰‡</button>
        </div>
        <div
          ref={this.editorRef}
          className="editor-content"
          contentEditable={true}
          dangerouslySetInnerHTML={{ __html: this.state.content }}
        />
      </div>
    );
  }
}
```

---

### 7. å¦‚ä½•å®ç°ä¸€ä¸ªå›¾ç‰‡å‹ç¼©åŠŸèƒ½ï¼Ÿ

**ç­”æ¡ˆï¼š**

```javascript
// å›¾ç‰‡å‹ç¼©å‡½æ•°
function compressImage(file, options = {}) {
  const {
    quality = 0.8,
    maxWidth = 1920,
    maxHeight = 1080,
    outputType = 'image/jpeg'
  } = options;
  
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      const img = new Image();
      
      img.onload = () => {
        // è®¡ç®—å‹ç¼©åçš„å°ºå¯¸
        let width = img.width;
        let height = img.height;
        
        if (width > maxWidth) {
          height = (maxWidth / width) * height;
          width = maxWidth;
        }
        
        if (height > maxHeight) {
          width = (maxHeight / height) * width;
          height = maxHeight;
        }
        
        // åˆ›å»º canvas
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        // å‹ç¼©å¹¶å¯¼å‡º
        canvas.toBlob(
          (blob) => {
            resolve(new File([blob], file.name, {
              type: outputType,
              lastModified: Date.now()
            }));
          },
          outputType,
          quality
        );
      };
      
      img.onerror = reject;
      img.src = e.target.result;
    };
    
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

// ä½¿ç”¨
async function handleFileUpload(file) {
  try {
    const compressedFile = await compressImage(file, {
      quality: 0.7,
      maxWidth: 1280,
      maxHeight: 720
    });
    
    console.log('åŸå§‹å¤§å°:', file.size);
    console.log('å‹ç¼©åå¤§å°:', compressedFile.size);
    console.log('å‹ç¼©ç‡:', ((1 - compressedFile.size / file.size) * 100).toFixed(2) + '%');
    
    // ä¸Šä¼ å‹ç¼©åçš„æ–‡ä»¶
    const formData = new FormData();
    formData.append('file', compressedFile);
    
    const response = await fetch('/api/upload', {
      method: 'POST',
      body: formData
    });
    
    const data = await response.json();
    console.log('ä¸Šä¼ æˆåŠŸ:', data);
  } catch (error) {
    console.error('å‹ç¼©æˆ–ä¸Šä¼ å¤±è´¥:', error);
  }
}
```

---

### 8. å¦‚ä½•å®ç°ä¸€ä¸ªå‰ç«¯ç¼“å­˜ç­–ç•¥ï¼Ÿ

**ç­”æ¡ˆï¼š**

```javascript
class CacheStrategy {
  constructor(options = {}) {
    this.options = {
      memory: true,
      localStorage: true,
      sessionStorage: false,
      indexedDB: false,
      ...options
    };
    
    this.memoryCache = new Map();
    this.init();
  }
  
  init() {
    // åˆå§‹åŒ– IndexedDB
    if (this.options.indexedDB) {
      this.initIndexedDB();
    }
  }
  
  // è®¾ç½®ç¼“å­˜
  async set(key, value, options = {}) {
    const {
      ttl = 3600000, // 1å°æ—¶
      strategy = 'all' // all, memory, localStorage, sessionStorage, indexedDB
    } = options;
    
    const item = {
      value,
      expire: Date.now() + ttl
    };
    
    // å†…å­˜ç¼“å­˜
    if (this.options.memory && (strategy === 'all' || strategy === 'memory')) {
      this.memoryCache.set(key, item);
    }
    
    // LocalStorage
    if (this.options.localStorage && (strategy === 'all' || strategy === 'localStorage')) {
      try {
        localStorage.setItem(key, JSON.stringify(item));
      } catch (e) {
        console.error('LocalStorage quota exceeded:', e);
      }
    }
    
    // SessionStorage
    if (this.options.sessionStorage && (strategy === 'all' || strategy === 'sessionStorage')) {
      try {
        sessionStorage.setItem(key, JSON.stringify(item));
      } catch (e) {
        console.error('SessionStorage quota exceeded:', e);
      }
    }
    
    // IndexedDB
    if (this.options.indexedDB && (strategy === 'all' || strategy === 'indexedDB')) {
      await this.setIndexedDB(key, item);
    }
  }
  
  // è·å–ç¼“å­˜
  async get(key, strategy = 'all') {
    let item = null;
    
    // ä¼˜å…ˆä»å†…å­˜è·å–
    if (this.options.memory && (strategy === 'all' || strategy === 'memory')) {
      item = this.memoryCache.get(key);
    }
    
    // ä» LocalStorage è·å–
    if (!item && this.options.localStorage && (strategy === 'all' || strategy === 'localStorage')) {
      try {
        const data = localStorage.getItem(key);
        item = data ? JSON.parse(data) : null;
      } catch (e) {
        console.error('Failed to get from LocalStorage:', e);
      }
    }
    
    // ä» SessionStorage è·å–
    if (!item && this.options.sessionStorage && (strategy === 'all' || strategy === 'sessionStorage')) {
      try {
        const data = sessionStorage.getItem(key);
        item = data ? JSON.parse(data) : null;
      } catch (e) {
        console.error('Failed to get from SessionStorage:', e);
      }
    }
    
    // ä» IndexedDB è·å–
    if (!item && this.options.indexedDB && (strategy === 'all' || strategy === 'indexedDB')) {
      item = await this.getIndexedDB(key);
    }
    
    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (item && item.expire < Date.now()) {
      this.delete(key, strategy);
      return null;
    }
    
    return item ? item.value : null;
  }
  
  // åˆ é™¤ç¼“å­˜
  async delete(key, strategy = 'all') {
    if (this.options.memory && (strategy === 'all' || strategy === 'memory')) {
      this.memoryCache.delete(key);
    }
    
    if (this.options.localStorage && (strategy === 'all' || strategy === 'localStorage')) {
      localStorage.removeItem(key);
    }
    
    if (this.options.sessionStorage && (strategy === 'all' || strategy === 'sessionStorage')) {
      sessionStorage.removeItem(key);
    }
    
    if (this.options.indexedDB && (strategy === 'all' || strategy === 'indexedDB')) {
      await this.deleteIndexedDB(key);
    }
  }
  
  // æ¸…ç©ºç¼“å­˜
  async clear(strategy = 'all') {
    if (this.options.memory && (strategy === 'all' || strategy === 'memory')) {
      this.memoryCache.clear();
    }
    
    if (this.options.localStorage && (strategy === 'all' || strategy === 'localStorage')) {
      localStorage.clear();
    }
    
    if (this.options.sessionStorage && (strategy === 'all' || strategy === 'sessionStorage')) {
      sessionStorage.clear();
    }
    
    if (this.options.indexedDB && (strategy === 'all' || strategy === 'indexedDB')) {
      await this.clearIndexedDB();
    }
  }
  
  // IndexedDB ç›¸å…³æ–¹æ³•
  initIndexedDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('cacheDB', 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('cache')) {
          db.createObjectStore('cache');
        }
      };
    });
  }
  
  async setIndexedDB(key, item) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['cache'], 'readwrite');
      const store = transaction.objectStore('cache');
      const request = store.put(item, key);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  async getIndexedDB(key) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['cache'], 'readonly');
      const store = transaction.objectStore('cache');
      const request = store.get(key);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async deleteIndexedDB(key) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['cache'], 'readwrite');
      const store = transaction.objectStore('cache');
      const request = store.delete(key);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  async clearIndexedDB() {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['cache'], 'readwrite');
      const store = transaction.objectStore('cache');
      const request = store.clear();
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
}
```

---

### 9. å¦‚ä½•åˆ¤æ–­ç”¨æˆ·è®¾å¤‡ï¼Ÿ

**ç­”æ¡ˆï¼š**

åˆ¤æ–­ç”¨æˆ·è®¾å¤‡æ˜¯å‰ç«¯å¼€å‘ä¸­çš„å¸¸è§éœ€æ±‚ï¼Œç”¨äºå®ç°å“åº”å¼è®¾è®¡ã€è®¾å¤‡é€‚é…ç­‰åŠŸèƒ½ã€‚

**å®ç°æ–¹æ¡ˆï¼š**

**æ–¹æ¡ˆ 1ï¼šåŸºäº User-Agent åˆ¤æ–­**
```javascript
class DeviceDetector {
  constructor() {
    this.userAgent = navigator.userAgent;
    this.device = this.detectDevice();
    this.os = this.detectOS();
    this.browser = this.detectBrowser();
  }
  
  detectDevice() {
    const ua = this.userAgent;
    
    // ç§»åŠ¨è®¾å¤‡
    if (/Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Silk-Accelerated/.test(ua)) {
      return 'mobile';
    }
    
    // å¹³æ¿è®¾å¤‡
    if (/Tablet|iPad/i.test(ua)) {
      return 'tablet';
    }
    
    // æ¡Œé¢è®¾å¤‡
    return 'desktop';
  }
  
  detectOS() {
    const ua = this.userAgent;
    
    if (/Windows/i.test(ua)) {
      return 'windows';
    }
    
    if (/Mac OS|Macintosh/i.test(ua)) {
      return 'macos';
    }
    
    if (/Linux/i.test(ua)) {
      return 'linux';
    }
    
    if (/Android/i.test(ua)) {
      return 'android';
    }
    
    if (/iOS|iPhone|iPad|iPod/i.test(ua)) {
      return 'ios';
    }
    
    return 'unknown';
  }
  
  detectBrowser() {
    const ua = this.userAgent;
    
    if (/Chrome/i.test(ua) && !/Edge|OPR/i.test(ua)) {
      return 'chrome';
    }
    
    if (/Safari/i.test(ua) && !/Chrome/i.test(ua)) {
      return 'safari';
    }
    
    if (/Firefox/i.test(ua)) {
      return 'firefox';
    }
    
    if (/Edge/i.test(ua)) {
      return 'edge';
    }
    
    if (/MSIE|Trident/i.test(ua)) {
      return 'ie';
    }
    
    return 'unknown';
  }
  
  isMobile() {
    return this.device === 'mobile';
  }
  
  isTablet() {
    return this.device === 'tablet';
  }
  
  isDesktop() {
    return this.device === 'desktop';
  }
  
  isIOS() {
    return this.os === 'ios';
  }
  
  isAndroid() {
    return this.os === 'android';
  }
}

// ä½¿ç”¨
const detector = new DeviceDetector();

console.log('è®¾å¤‡ç±»å‹:', detector.device);
console.log('æ“ä½œç³»ç»Ÿ:', detector.os);
console.log('æµè§ˆå™¨:', detector.browser);

if (detector.isMobile()) {
  // ç§»åŠ¨ç«¯é€»è¾‘
  console.log('å½“å‰æ˜¯ç§»åŠ¨è®¾å¤‡');
}
```

**æ–¹æ¡ˆ 2ï¼šåŸºäºå±å¹•å°ºå¯¸åˆ¤æ–­**
```javascript
class ResponsiveDetector {
  constructor() {
    this.breakpoints = {
      mobile: 768,
      tablet: 1024,
      desktop: 1440
    };
    
    this.currentBreakpoint = this.getCurrentBreakpoint();
    this.init();
  }
  
  getCurrentBreakpoint() {
    const width = window.innerWidth;
    
    if (width < this.breakpoints.mobile) {
      return 'mobile';
    } else if (width < this.breakpoints.tablet) {
      return 'tablet';
    } else if (width < this.breakpoints.desktop) {
      return 'desktop';
    } else {
      return 'large';
    }
  }
  
  init() {
    window.addEventListener('resize', this.handleResize.bind(this));
  }
  
  handleResize() {
    const newBreakpoint = this.getCurrentBreakpoint();
    
    if (newBreakpoint !== this.currentBreakpoint) {
      const oldBreakpoint = this.currentBreakpoint;
      this.currentBreakpoint = newBreakpoint;
      
      // è§¦å‘æ–­ç‚¹å˜åŒ–äº‹ä»¶
      this.onBreakpointChange(oldBreakpoint, newBreakpoint);
    }
  }
  
  onBreakpointChange(oldBreakpoint, newBreakpoint) {
    console.log(`æ–­ç‚¹ä» ${oldBreakpoint} å˜ä¸º ${newBreakpoint}`);
    
    // å¯ä»¥åœ¨è¿™é‡Œæ‰§è¡Œç›¸åº”çš„é€»è¾‘
    if (newBreakpoint === 'mobile') {
      // ç§»åŠ¨ç«¯é€»è¾‘
    }
  }
  
  destroy() {
    window.removeEventListener('resize', this.handleResize.bind(this));
  }
}

// ä½¿ç”¨
const responsiveDetector = new ResponsiveDetector();
```

**æ–¹æ¡ˆ 3ï¼šåŸºäºåª’ä½“æŸ¥è¯¢åˆ¤æ–­**
```javascript
class MediaQueryDetector {
  constructor() {
    this.queries = {
      mobile: window.matchMedia('(max-width: 767px)'),
      tablet: window.matchMedia('(min-width: 768px) and (max-width: 1023px)'),
      desktop: window.matchMedia('(min-width: 1024px)'),
      portrait: window.matchMedia('(orientation: portrait)'),
      landscape: window.matchMedia('(orientation: landscape)'),
      darkMode: window.matchMedia('(prefers-color-scheme: dark)'),
      highDPI: window.matchMedia('(min-resolution: 2dppx)')
    };
    
    this.init();
  }
  
  init() {
    Object.keys(this.queries).forEach(key => {
      const query = this.queries[key];
      
      // åˆå§‹æ£€æŸ¥
      this.updateQueryStatus(key, query);
      
      // ç›‘å¬å˜åŒ–
      query.addEventListener('change', (e) => {
        this.updateQueryStatus(key, e);
      });
    });
  }
  
  updateQueryStatus(key, query) {
    this[key] = query.matches;
    console.log(`${key}: ${query.matches}`);
  }
  
  isMobile() {
    return this.mobile;
  }
  
  isTablet() {
    return this.tablet;
  }
  
  isDesktop() {
    return this.desktop;
  }
  
  isPortrait() {
    return this.portrait;
  }
  
  isLandscape() {
    return this.landscape;
  }
  
  isDarkMode() {
    return this.darkMode;
  }
  
  isHighDPI() {
    return this.highDPI;
  }
}

// ä½¿ç”¨
const mediaQueryDetector = new MediaQueryDetector();

if (mediaQueryDetector.isMobile()) {
  console.log('å½“å‰æ˜¯ç§»åŠ¨è®¾å¤‡');
}

if (mediaQueryDetector.isDarkMode()) {
  console.log('å½“å‰æ˜¯æ·±è‰²æ¨¡å¼');
}
```

**æ–¹æ¡ˆ 4ï¼šä½¿ç”¨ Modernizr æ£€æµ‹åŠŸèƒ½æ”¯æŒ**
```javascript
class FeatureDetector {
  constructor() {
    this.features = {
      touch: this.detectTouch(),
      webGL: this.detectWebGL(),
      webWorker: this.detectWebWorker(),
      localStorage: this.detectLocalStorage(),
      sessionStorage: this.detectSessionStorage(),
      serviceWorker: this.detectServiceWorker(),
      webSocket: this.detectWebSocket(),
      geolocation: this.detectGeolocation(),
      camera: this.detectCamera(),
      microphone: this.detectMicrophone()
    };
  }
  
  detectTouch() {
    return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  }
  
  detectWebGL() {
    try {
      const canvas = document.createElement('canvas');
      return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
    } catch (e) {
      return false;
    }
  }
  
  detectWebWorker() {
    return 'Worker' in window;
  }
  
  detectLocalStorage() {
    try {
      localStorage.setItem('test', 'test');
      localStorage.removeItem('test');
      return true;
    } catch (e) {
      return false;
    }
  }
  
  detectSessionStorage() {
    try {
      sessionStorage.setItem('test', 'test');
      sessionStorage.removeItem('test');
      return true;
    } catch (e) {
      return false;
    }
  }
  
  async detectServiceWorker() {
    return 'serviceWorker' in navigator;
  }
  
  detectWebSocket() {
    return 'WebSocket' in window;
  }
  
  detectGeolocation() {
    return 'geolocation' in navigator;
  }
  
  async detectCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      stream.getTracks().forEach(track => track.stop());
      return true;
    } catch (e) {
      return false;
    }
  }
  
  async detectMicrophone() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      stream.getTracks().forEach(track => track.stop());
      return true;
    } catch (e) {
      return false;
    }
  }
  
  hasFeature(feature) {
    return this.features[feature];
  }
}

// ä½¿ç”¨
const featureDetector = new FeatureDetector();

if (featureDetector.hasFeature('touch')) {
  console.log('æ”¯æŒè§¦æ‘¸');
}

if (featureDetector.hasFeature('webGL')) {
  console.log('æ”¯æŒ WebGL');
}
```

---

### 10. å¦‚ä½•å®ç°é€€å‡ºæµè§ˆå™¨ä¹‹å‰å‘é€ç§¯å‹çš„åŸ‹ç‚¹æ•°æ®è¯·æ±‚ï¼Ÿ

**ç­”æ¡ˆï¼š**

åœ¨é¡µé¢å…³é—­å‰å‘é€ç§¯å‹çš„åŸ‹ç‚¹æ•°æ®æ˜¯ä¸€ä¸ªå¸¸è§éœ€æ±‚ï¼Œéœ€è¦ä½¿ç”¨ç‰¹æ®Šçš„ API æ¥ç¡®ä¿æ•°æ®èƒ½å¤Ÿå‘é€æˆåŠŸã€‚

**å®ç°æ–¹æ¡ˆï¼š**

**æ–¹æ¡ˆ 1ï¼šä½¿ç”¨ navigator.sendBeacon**
```javascript
class BeaconSender {
  constructor(options = {}) {
    this.options = {
      endpoint: '/api/analytics',
      maxRetries: 3,
      retryDelay: 1000,
      ...options
    };
    
    this.queue = [];
    this.sending = false;
    this.init();
  }
  
  init() {
    // é¡µé¢å¸è½½å‰å‘é€
    window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
    window.addEventListener('pagehide', this.handlePageHide.bind(this));
    
    // å®šæœŸå‘é€
    setInterval(() => this.flush(), 30000);
  }
  
  add(data) {
    this.queue.push({
      data,
      timestamp: Date.now()
    });
    
    // å¦‚æœé˜Ÿåˆ—è¶…è¿‡é˜ˆå€¼ï¼Œç«‹å³å‘é€
    if (this.queue.length >= 10) {
      this.flush();
    }
  }
  
  async flush() {
    if (this.sending || this.queue.length === 0) {
      return;
    }
    
    this.sending = true;
    
    const dataToSend = [...this.queue];
    this.queue = [];
    
    try {
      const success = await this.sendWithRetry(dataToSend);
      
      if (!success) {
        // å‘é€å¤±è´¥ï¼Œé‡æ–°åŠ å…¥é˜Ÿåˆ—
        this.queue.unshift(...dataToSend);
      }
    } catch (error) {
      console.error('å‘é€åŸ‹ç‚¹æ•°æ®å¤±è´¥:', error);
      this.queue.unshift(...dataToSend);
    } finally {
      this.sending = false;
    }
  }
  
  sendWithRetry(data, retryCount = 0) {
    return new Promise((resolve) => {
      const success = this.sendData(data);
      
      if (success) {
        resolve(true);
      } else if (retryCount < this.options.maxRetries) {
        setTimeout(() => {
          this.sendWithRetry(data, retryCount + 1).then(resolve);
        }, this.options.retryDelay);
      } else {
        resolve(false);
      }
    });
  }
  
  sendData(data) {
    try {
      const blob = new Blob([JSON.stringify(data)], {
        type: 'application/json'
      });
      
      return navigator.sendBeacon(this.options.endpoint, blob);
    } catch (error) {
      console.error('sendBeacon å¤±è´¥:', error);
      return false;
    }
  }
  
  handleBeforeUnload() {
    // é¡µé¢å¸è½½å‰å‘é€
    if (this.queue.length > 0) {
      this.flush();
    }
  }
  
  handlePageHide() {
    // é¡µé¢éšè—æ—¶å‘é€ï¼ˆåŒ…æ‹¬é¡µé¢å…³é—­ï¼‰
    if (this.queue.length > 0) {
      this.flush();
    }
  }
}

// ä½¿ç”¨
const beaconSender = new BeaconSender({
  endpoint: '/api/analytics'
});

// æ·»åŠ åŸ‹ç‚¹æ•°æ®
beaconSender.add({
  event: 'page_view',
  page: window.location.pathname,
  timestamp: Date.now()
});

beaconSender.add({
  event: 'click',
  element: 'button',
  timestamp: Date.now()
});
```

**æ–¹æ¡ˆ 2ï¼šä½¿ç”¨ XMLHttpRequest åŒæ­¥è¯·æ±‚**
```javascript
class SyncSender {
  constructor(options = {}) {
    this.options = {
      endpoint: '/api/analytics',
      ...options
    };
    
    this.queue = [];
    this.init();
  }
  
  init() {
    window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
    window.addEventListener('pagehide', this.handlePageHide.bind(this));
  }
  
  add(data) {
    this.queue.push({
      data,
      timestamp: Date.now()
    });
  }
  
  handleBeforeUnload() {
    if (this.queue.length > 0) {
      this.sendSync();
    }
  }
  
  handlePageHide() {
    if (this.queue.length > 0) {
      this.sendSync();
    }
  }
  
  sendSync() {
    try {
      const xhr = new XMLHttpRequest();
      xhr.open('POST', this.options.endpoint, false); // åŒæ­¥è¯·æ±‚
      xhr.setRequestHeader('Content-Type', 'application/json');
      xhr.send(JSON.stringify(this.queue));
      
      // æ¸…ç©ºé˜Ÿåˆ—
      this.queue = [];
    } catch (error) {
      console.error('åŒæ­¥å‘é€åŸ‹ç‚¹æ•°æ®å¤±è´¥:', error);
      
      // å¤±è´¥æ—¶å°è¯•ä½¿ç”¨ sendBeacon
      this.sendWithBeacon();
    }
  }
  
  sendWithBeacon() {
    try {
      const blob = new Blob([JSON.stringify(this.queue)], {
        type: 'application/json'
      });
      
      const success = navigator.sendBeacon(this.options.endpoint, blob);
      
      if (success) {
        this.queue = [];
      }
    } catch (error) {
      console.error('sendBeacon å¤±è´¥:', error);
    }
  }
}

// ä½¿ç”¨
const syncSender = new SyncSender();

syncSender.add({
  event: 'page_view',
  page: window.location.pathname
});
```

**æ–¹æ¡ˆ 3ï¼šä½¿ç”¨ Visibility API**
```javascript
class VisibilitySender {
  constructor(options = {}) {
    this.options = {
      endpoint: '/api/analytics',
      ...options
    };
    
    this.queue = [];
    this.init();
  }
  
  init() {
    document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
  }
  
  add(data) {
    this.queue.push({
      data,
      timestamp: Date.now()
    });
  }
  
  handleVisibilityChange() {
    if (document.visibilityState === 'hidden') {
      // é¡µé¢éšè—æ—¶å‘é€
      this.flush();
    }
  }
  
  async flush() {
    if (this.queue.length === 0) {
      return;
    }
    
    const dataToSend = [...this.queue];
    this.queue = [];
    
    try {
      const response = await fetch(this.options.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(dataToSend),
        keepalive: true // ä½¿ç”¨ keepalive æ¨¡å¼
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      console.error('å‘é€åŸ‹ç‚¹æ•°æ®å¤±è´¥:', error);
      
      // å¤±è´¥æ—¶å°è¯•ä½¿ç”¨ sendBeacon
      this.sendWithBeacon(dataToSend);
    }
  }
  
  sendWithBeacon(data) {
    try {
      const blob = new Blob([JSON.stringify(data)], {
        type: 'application/json'
      });
      
      const success = navigator.sendBeacon(this.options.endpoint, blob);
      
      if (!success) {
        // sendBeacon å¤±è´¥ï¼Œé‡æ–°åŠ å…¥é˜Ÿåˆ—
        this.queue.unshift(...data);
      }
    } catch (error) {
      console.error('sendBeacon å¤±è´¥:', error);
      this.queue.unshift(...data);
    }
  }
}

// ä½¿ç”¨
const visibilitySender = new VisibilitySender();

visibilitySender.add({
  event: 'page_view',
  page: window.location.pathname
});
```

**æ–¹æ¡ˆ 4ï¼šä½¿ç”¨ IndexedDB æŒä¹…åŒ–**
```javascript
class PersistentSender {
  constructor(options = {}) {
    this.options = {
      endpoint: '/api/analytics',
      dbName: 'analyticsDB',
      storeName: 'events',
      ...options
    };
    
    this.db = null;
    this.init();
  }
  
  async init() {
    this.db = await this.openDB();
    
    // é¡µé¢åŠ è½½æ—¶å‘é€ç§¯å‹çš„æ•°æ®
    this.flushPendingEvents();
    
    // é¡µé¢å…³é—­å‰å‘é€
    window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
    window.addEventListener('pagehide', this.handlePageHide.bind(this));
  }
  
  async openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.options.dbName, 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.options.storeName)) {
          const store = db.createObjectStore(this.options.storeName, {
            keyPath: 'id',
            autoIncrement: true
          });
          store.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }
  
  async add(data) {
    const transaction = this.db.transaction([this.options.storeName], 'readwrite');
    const store = transaction.objectStore(this.options.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.add({
        data,
        timestamp: Date.now(),
        sent: false
      });
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async flushPendingEvents() {
    const transaction = this.db.transaction([this.options.storeName], 'readonly');
    const store = transaction.objectStore(this.options.storeName);
    const index = store.index('timestamp');
    
    const events = await new Promise((resolve, reject) => {
      const request = index.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
    
    // å‘é€æœªå‘é€çš„äº‹ä»¶
    const pendingEvents = events.filter(event => !event.sent);
    
    for (const event of pendingEvents) {
      await this.sendEvent(event);
    }
  }
  
  async sendEvent(event) {
    try {
      const response = await fetch(this.options.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(event.data),
        keepalive: true
      });
      
      if (response.ok) {
        // å‘é€æˆåŠŸï¼Œæ ‡è®°ä¸ºå·²å‘é€
        await this.markAsSent(event.id);
      }
    } catch (error) {
      console.error('å‘é€äº‹ä»¶å¤±è´¥:', error);
    }
  }
  
  async markAsSent(id) {
    const transaction = this.db.transaction([this.options.storeName], 'readwrite');
    const store = transaction.objectStore(this.options.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.get(id);
      
      request.onsuccess = () => {
        const event = request.result;
        event.sent = true;
        
        const updateRequest = store.put(event);
        updateRequest.onsuccess = () => resolve();
        updateRequest.onerror = () => reject(updateRequest.error);
      };
      
      request.onerror = () => reject(request.error);
    });
  }
  
  handleBeforeUnload() {
    // é¡µé¢å…³é—­å‰ä½¿ç”¨ sendBeacon å‘é€
    this.flushWithBeacon();
  }
  
  handlePageHide() {
    // é¡µé¢éšè—æ—¶ä½¿ç”¨ sendBeacon å‘é€
    this.flushWithBeacon();
  }
  
  async flushWithBeacon() {
    const transaction = this.db.transaction([this.options.storeName], 'readonly');
    const store = transaction.objectStore(this.options.storeName);
    const index = store.index('timestamp');
    
    const events = await new Promise((resolve, reject) => {
      const request = index.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
    
    const pendingEvents = events.filter(event => !event.sent);
    
    if (pendingEvents.length > 0) {
      try {
        const blob = new Blob([JSON.stringify(pendingEvents.map(e => e.data))], {
          type: 'application/json'
        });
        
        const success = navigator.sendBeacon(this.options.endpoint, blob);
        
        if (success) {
          // æ ‡è®°æ‰€æœ‰äº‹ä»¶ä¸ºå·²å‘é€
          for (const event of pendingEvents) {
            await this.markAsSent(event.id);
          }
        }
      } catch (error) {
        console.error('sendBeacon å¤±è´¥:', error);
      }
    }
  }
}

// ä½¿ç”¨
const persistentSender = new PersistentSender();

persistentSender.add({
  event: 'page_view',
  page: window.location.pathname
});
```

---

## æ€»ç»“

çŸ¥ä¹é¢è¯•é¢˜é‡ç‚¹æŒæ¡ï¼š

### å‰ç«¯åŸºç¡€
1. **è·¯ç”±ç³»ç»Ÿ**ï¼šHashè·¯ç”±ã€Historyè·¯ç”±ã€åŠ¨æ€è·¯ç”±
2. **å¯Œæ–‡æœ¬ç¼–è¾‘å™¨**ï¼šcontentEditableã€execCommand
3. **å›¾ç‰‡å‹ç¼©**ï¼šCanvasã€toBlobã€å‹ç¼©ç®—æ³•
4. **ç¼“å­˜ç­–ç•¥**ï¼šå†…å­˜ã€LocalStorageã€IndexedDB
5. **è®¾å¤‡æ£€æµ‹**ï¼šUser-Agentã€åª’ä½“æŸ¥è¯¢ã€åŠŸèƒ½æ£€æµ‹
6. **æ•°æ®å‘é€**ï¼šsendBeaconã€åŒæ­¥è¯·æ±‚ã€Visibility API

### ç®—æ³•é¢˜
1. **å¸ƒéš†è¿‡æ»¤å™¨**ï¼šæµ·é‡æ•°æ®å»é‡ã€é»‘åå•
2. **ä¸€è‡´æ€§å“ˆå¸Œ**ï¼šåˆ†å¸ƒå¼ç¼“å­˜ã€è´Ÿè½½å‡è¡¡

### åœºæ™¯é¢˜
1. **æ‹–æ‹½ä¸Šä¼ **ï¼šæ‹–æ‹½äº‹ä»¶ã€æ–‡ä»¶ä¸Šä¼ ã€è¿›åº¦æ˜¾ç¤º
2. **è®¾å¤‡æ£€æµ‹**ï¼šå“åº”å¼è®¾è®¡ã€è®¾å¤‡é€‚é…
3. **æ•°æ®å‘é€**ï¼šé¡µé¢å…³é—­å‰å‘é€ã€åŸ‹ç‚¹æ•°æ®

**é¢è¯•å‡†å¤‡å»ºè®®ï¼š**
1. æ·±å…¥ç†è§£è·¯ç”±ç³»ç»Ÿ
2. æŒæ¡å¯Œæ–‡æœ¬ç¼–è¾‘å™¨åŸç†
3. ç†Ÿæ‚‰å›¾ç‰‡å¤„ç†æŠ€æœ¯
4. äº†è§£ç¼“å­˜ç­–ç•¥å’Œå®ç°
5. æ³¨é‡ä»£ç è´¨é‡å’Œå¯ç»´æŠ¤æ€§
6. æŒæ¡è®¾å¤‡æ£€æµ‹æŠ€æœ¯
7. ç†è§£æ•°æ®å‘é€ç­–ç•¥