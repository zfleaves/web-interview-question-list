# 7. 箭头函数的异同点

**答案：**

**箭头函数与普通函数的区别：**

**1. this 指向不同**

```javascript
// 普通函数
function normalFn() {
  console.log(this); // 指向全局对象
}

const obj = { name: '测试' };
obj.fn = normalFn;
obj.fn(); // 输出全局对象 window
```

// 箭头函数
const arrowFn = () => {
  console.log(this); // 指向定义时作用域的 this
};

const obj2 = { name: '测试2' };
obj2.fn = arrowFn;
obj2.fn(); // 输出 undefined（在严格模式下）
```

**2. arguments 对象**

```javascript
// 普通函数
function normalFn(a, b) {
  console.log(arguments); // Arguments 对象
}

normalFn(1, 2); // [1, 2]

// 箭头函数
const arrowFn = (a, b) => {
  console.log(arguments); // 箭头函数没有 arguments 对象
};

arrowFn(1, 2); // ReferenceError: arguments is not defined
```

**3. 不能作为构造函数**

```javascript
// 普通函数
function Person(name) {
  this.name = name;
}

const person = new Person('张三'); // 正常

// 箭头函数
const Person = (name) => {
  this.name = name;
};

const person = new Person('李四'); // TypeError: Person is not a constructor
```

**4. 不能使用 call、apply、bind**

```javascript
// 普通函数
function fn(a, b) {
  console.log(a, b);
}

fn.call(obj, 1, 2); // this 指向 obj，a=1, b=2

// 箭头函数
const arrowFn = (a, b) => {
  console.log(a, b);
};

arrowFn.call(obj, 1, 2); // TypeError: arrowFn is not a function
```

**高途特色考点：**
- 高频考察箭头函数的特性限制
- 结合实际项目说明箭头函数的使用场景
- 考察对 ES6 新特性的理解

---
