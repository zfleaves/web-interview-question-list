# 2. 如何实现一个前端微前端架构？

**答案：**

```javascript
// 微前端架构实现

// 1. 基座应用（主应用）
class MicroApp {
  constructor(options) {
    this.apps = new Map();
    this.activeApp = null;
    this.container = options.container;
  }
  
  // 注册子应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      ...config,
      status: 'unmounted',
    });
  }
  
  // 启动应用
  async start() {
    // 启动默认应用
    const defaultApp = Array.from(this.apps.values())[0];
    if (defaultApp) {
      await this.loadApp(defaultApp.name);
    }
  }
  
  // 加载应用
  async loadApp(name) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    // 卸载当前应用
    if (this.activeApp && this.activeApp.name !== name) {
      await this.unloadApp(this.activeApp.name);
    }
    
    // 加载新应用
    app.status = 'loading';
    
    try {
      // 动态加载应用资源
      await this.loadResources(app);
      
      // 挂载应用
      await this.mountApp(app);
      
      app.status = 'mounted';
      this.activeApp = app;
    } catch (error) {
      app.status = 'error';
      console.error(`Failed to load app ${name}:`, error);
    }
  }
  
  // 加载资源
  async loadResources(app) {
    // 加载 JS
    if (app.js) {
      await this.loadScript(app.js);
    }
    
    // 加载 CSS
    if (app.css) {
      await this.loadStylesheet(app.css);
    }
  }
  
  // 加载脚本
  loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  
  // 加载样式
  loadStylesheet(url) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      link.onload = resolve;
      link.onerror = reject;
      document.head.appendChild(link);
    });
  }
  
  // 挂载应用
  async mountApp(app) {
    const { mount, container = this.container } = app;
    
    if (mount && typeof mount === 'function') {
      await mount(container);
    } else if (window[app.name]) {
      // 全局变量方式
      await window[app.name].mount(container);
    }
  }
  
  // 卸载应用
  async unloadApp(name) {
    const app = this.apps.get(name);
    if (!app || app.status !== 'mounted') {
      return;
    }
    
    app.status = 'unmounting';
    
    try {
      const { unmount } = app;
      
      if (unmount && typeof unmount === 'function') {
        await unmount();
      } else if (window[name]) {
        await window[name].unmount();
      }
      
      // 清理资源
      this.cleanupResources(app);
      
      app.status = 'unmounted';
    } catch (error) {
      app.status = 'error';
      console.error(`Failed to unload app ${name}:`, error);
    }
  }
  
  // 清理资源
  cleanupResources(app) {
    // 移除样式
    if (app.css) {
      const links = document.querySelectorAll(`link[href="${app.css}"]`);
      links.forEach(link => link.remove());
    }
    
    // 清空容器
    if (this.container) {
      this.container.innerHTML = '';
    }
  }
}

// 使用
const microApp = new MicroApp({
  container: document.getElementById('app'),
});

// 注册子应用
microApp.registerApp('app1', {
  name: 'app1',
  js: 'https://cdn.example.com/app1.js',
  css: 'https://cdn.example.com/app1.css',
  mount: (container) => {
    // 挂载逻辑
    container.innerHTML = '<div>App 1</div>';
  },
  unmount: () => {
    // 卸载逻辑
  },
});

// 启动
microApp.start();

// 切换应用
microApp.loadApp('app2');
```

---

## 算法题
