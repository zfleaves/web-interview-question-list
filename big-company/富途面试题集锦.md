# 富途面试题集锦（截止 2025 年底）

## 目录
1. [前端基础](#前端基础)
2. [算法题](#算法题)
3. [场景题](#场景题)

---

## 前端基础

### 1. 请简述 JavaScript 的事件循环机制

**答案：**

**事件循环（Event Loop）是 JavaScript 实现异步非阻塞 I/O 的机制。**

**执行顺序：**

```
1. 执行同步代码
2. 执行微任务队列
3. 执行宏任务队列
4. 重复 2-3
```

**示例：**

```javascript
console.log('script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

async function async1() {
  console.log('async1 start');
  await Promise.resolve().then(() => {
    console.log('promise1');
  });
  console.log('async1 end');
}

async1();

console.log('script end');

// 输出：
// script start
// async1 start
// script end
// promise1
// async1 end
// setTimeout
```

**宏任务：**
- setTimeout
- setInterval
- I/O
- UI 渲染

**微任务：**
- Promise.then
- queueMicrotask
- MutationObserver
- async/await

**富途特色考点：**
- 富途高频考察事件循环的执行顺序
- 结合实际业务场景分析异步代码执行流程
- 考察对微任务与宏任务的理解深度

---

### 2. 请简述 JSBridge 的实现原理

**答案：**

**JSBridge 是 Native 代码与 JS 代码的通信桥梁。**

**实现原理：**

```
H5触发 url scheme -> Native 捕获 url scheme -> 原生分析,执行 -> 原生调用h5
```

**示例：**

```javascript
// H5 调用 Native
iframe.src = 'weixin://dl/scan?k1=v1&k2=v2&callback=invoke_scan_callback';

// 定义回调函数
window.invoke_scan_callback = function(result) {
  console.log('扫描结果:', result);
};
```

**Schema 协议：**
- 前端和客户端通讯的约定
- 格式：`scheme://host?params`

**富途特色考点：**
- 富途高频考察混合开发中 Native 与 H5 通信
- 结合实际项目说明 JSBridge 的应用场景
- 考察对移动端开发的理解

---

### 3. 请简述埋点收集的原理

**答案：**

**埋点收集是指收集用户在网站上的行为数据。**

**收集内容：**
- 用户行为（打开网页、点击按钮、加入购物车等）
- 行为附加数据（订单金额、停留时间等）

**实现原理：**

```javascript
// 1. 定义埋点函数
function track(event, data) {
  const timestamp = Date.now();
  const userInfo = {
    userId: '123456',
    sessionId: 'session_abc'
  };
  
  const payload = {
    event,
    data,
    timestamp,
    userInfo
  };
  
  // 2. 上报到后端
  fetch('/api/track', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(payload)
  });
}

// 3. 使用埋点
document.querySelector('#buy-button').addEventListener('click', () => {
  track('buy_click', {
    productId: '123',
    price: 99.99
  });
});
```

**富途特色考点：**
- 富途高频考察数据埋点的实现方式
- 结合金融业务说明数据收集的重要性
- 考察对数据分析的理解

---

### 4. 请简述错误信息收集的方案

**答案：**

**错误信息收集包括即时运行错误和资源加载错误的捕获。**

**即时运行错误捕获：**

```javascript
// 1. try...catch
try {
  // 可能出错的代码
  JSON.parse(invalidJson);
} catch (error) {
  reportError(error);
}

// 2. window.onerror
window.onerror = function(message, source, lineno, colno, error) {
  reportError({
    message,
    source,
    lineno,
    colno,
    error
  });
};

// 3. Vue 组件 errorCaptured
export default {
  errorCaptured(err, vm, info) {
    reportError({
      error: err,
      component: vm.$options.name,
      info
    });
  }
};
```

**资源加载错误捕获：**

```javascript
// 1. object.onerror 事件
const img = new Image();
img.onerror = function() {
  reportError({
    type: 'image_load_error',
    src: this.src
  });
};
img.src = 'image.jpg';

// 2. performance.getEntries()
const entries = performance.getEntries();
entries.forEach(entry => {
  if (entry.duration === 0 && entry.transferSize === 0) {
    reportError({
      type: 'resource_load_error',
      name: entry.name
    });
  }
});

// 3. Error 事件捕获
window.addEventListener('error', function(e) {
  if (e.target !== window) {
    reportError({
      type: 'resource_error',
      target: e.target.tagName,
      src: e.target.src
    });
  }
}, true);
```

**错误上报方式：**

```javascript
// 1. Ajax 上报
function reportError(error) {
  fetch('/api/error', {
    method: 'POST',
    body: JSON.stringify(error)
  });
}

// 2. Image 对象上报
function reportError(error) {
  const img = new Image();
  img.src = `http://api.example.com/error?data=${encodeURIComponent(JSON.stringify(error))}`;
}

// 3. 使用 Sentry
import * as Sentry from '@sentry/browser';

Sentry.init({
  dsn: 'your-dsn'
});

Sentry.captureException(error);
```

**富途特色考点：**
- 富途高频考察错误监控和上报方案
- 结合金融业务说明错误收集的重要性
- 考察对 Sentry 等监控工具的使用经验

---

### 5. 请简述跨域问题及解决方案

**答案：**

**跨域是指浏览器限制从一个域名的网页去请求另一个域名的资源。**

**为什么要有同源策略？**
- 防止恶意网站读取其他网站的敏感信息
- 保护用户隐私和安全
- 防止 CSRF 攻击

**解决方案：**

**1. JSONP**

```javascript
function jsonp(url, callbackName) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = `${url}?callback=${callbackName}`;
    
    window[callbackName] = function(data) {
      resolve(data);
      delete window[callbackName];
      document.body.removeChild(script);
    };
    
    script.onerror = () => {
      reject(new Error('JSONP request failed'));
    };
    
    document.body.appendChild(script);
  });
}

// 使用
jsonp('http://api.example.com/data', 'callback')
  .then(data => console.log(data));
```

**2. CORS（跨域资源共享）**

```javascript
// 前端
fetch('http://api.example.com/data', {
  method: 'GET',
  headers: {
    'Content-Type': 'application/json'
  },
  credentials: 'include' // 携带 cookie
})
  .then(res => res.json())
  .then(data => console.log(data));

// 后端（Node.js）
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  next();
});
```

**3. postMessage**

```javascript
// 窗口 A
const iframe = document.getElementById('iframe');
iframe.contentWindow.postMessage('Hello from A', 'http://b.com');

// 窗口 B
window.addEventListener('message', function(e) {
  if (e.origin === 'http://a.com') {
    console.log('收到消息:', e.data);
  }
});
```

**4. WebSocket**

```javascript
const ws = new WebSocket('ws://api.example.com');

ws.onopen = function() {
  console.log('连接已建立');
};

ws.onmessage = function(e) {
  console.log('收到消息:', e.data);
};

ws.send('Hello from client');
```

**5. 代理服务器**

```javascript
// webpack.config.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
};
```

**富途特色考点：**
- 富途高频考察跨域问题的理解和解决方案
- 结合实际项目说明跨域场景的处理
- 考察对浏览器安全机制的理解

---

### 6. 请简述浏览器加载网页的主要步骤及性能优化

**答案：**

**浏览器加载网页的主要步骤：**

```
1. DNS 解析
2. TCP 连接
3. HTTP 请求
4. 服务器响应
5. 渲染树构建
6. 布局
7. 绘制
8. 合成
```

**性能优化方案：**

**1. DNS 解析优化**

```javascript
// DNS 预解析
<link rel="dns-prefetch" href="https://api.example.com">

// DNS 预连接
<link rel="preconnect" href="https://api.example.com">
```

**2. 资源加载优化**

```javascript
// 预加载关键资源
<link rel="preload" href="critical.css" as="style">
<link rel="preload" href="main.js" as="script">

// 预获取可能用到的资源
<link rel="prefetch" href="next-page.js">

// 懒加载非关键资源
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy">
```

**3. 代码分割**

```javascript
// 动态导入
const Home = lazy(() => import('./Home'));
const About = lazy(() => import('./About'));

// Webpack 配置
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },
  },
};
```

**4. 缓存优化**

```javascript
// 强制缓存
Cache-Control: max-age=31536000

// 协商缓存
ETag: "abc123"
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
```

**5. 渲染优化**

```javascript
// 避免布局抖动
const element = document.getElementById('element');
element.style.width = '100px';
element.style.height = '100px';

// 批量 DOM 操作
const fragment = document.createDocumentFragment();
items.forEach(item => {
  const node = document.createElement('div');
  node.textContent = item.text;
  fragment.appendChild(node);
});
document.body.appendChild(fragment);

// 使用 CSS3 动画
.element {
  transition: transform 0.3s;
  will-change: transform;
}
```

**富途特色考点：**
- 富途高频考察性能优化的全链路思维
- 结合金融业务场景说明优化方案
- 考察对性能监控工具的使用经验

---

### 7. 请简述 Vue 的响应式原理及数组方法 hack

**答案：**

**Vue 2 使用 Object.defineProperty 实现响应式。**

**响应式原理：**

```javascript
function defineReactive(obj, key, val) {
  const dep = new Dep();
  
  Object.defineProperty(obj, key, {
    get() {
      dep.depend();
      return val;
    },
    set(newVal) {
      if (newVal !== val) {
        val = newVal;
        dep.notify();
      }
    }
  });
}

class Dep {
  constructor() {
    this.subs = [];
  }
  
  depend() {
    if (Dep.target) {
      this.subs.push(Dep.target);
    }
  }
  
  notify() {
    this.subs.forEach(sub => sub.update());
  }
}
```

**数组方法 hack：**

```javascript
// Vue 2 对数组方法进行 hack
const arrayMethods = Object.create(Array.prototype);
const methods = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

methods.forEach(method => {
  arrayMethods[method] = function(...args) {
    const result = Array.prototype[method].apply(this, args);
    
    // 触发响应式更新
    const ob = this.__ob__;
    let inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    ob.dep.notify();
    
    return result;
  };
});
```

**使用示例：**

```javascript
// Vue 2
const vm = new Vue({
  data: {
    items: [1, 2, 3]
  }
});

// 这些方法会触发响应式更新
vm.items.push(4);
vm.items.pop();
vm.items.splice(0, 1);
vm.items.sort((a, b) => a - b);

// 直接修改索引不会触发更新
vm.items[0] = 100; // 不会触发更新

// 使用 Vue.set 或 this.$set 触发更新
Vue.set(vm.items, 0, 100);
vm.$set(vm.items, 0, 100);
```

**富途特色考点：**
- 富途高频考察 Vue 响应式原理
- 结合实际项目说明数组 hack 的应用场景
- 考察对 Vue 2/3 响应式系统差异的理解

---

### 8. 请简述 Vue.$nextTick 的实现原理

**答案：**

**Vue.$nextTick 用于在 DOM 更新完成后执行回调。**

**实现原理：**

```javascript
let callbacks = [];
let pending = false;

function flushCallbacks() {
  pending = false;
  const copies = callbacks.slice(0);
  callbacks.length = 0;
  for (let i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

let timerFunc;

if (typeof Promise !== 'undefined') {
  const p = Promise.resolve();
  timerFunc = () => {
    p.then(flushCallbacks);
  };
} else if (typeof MutationObserver !== 'undefined') {
  const observer = new MutationObserver(flushCallbacks);
  const textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = () => {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
} else {
  timerFunc = () => {
    setTimeout(flushCallbacks, 0);
  };
}

export function nextTick(cb) {
  callbacks.push(() => {
    if (cb) {
      cb();
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
}
```

**使用示例：**

```javascript
// Vue 2
new Vue({
  data: {
    message: 'Hello'
  },
  methods: {
    updateMessage() {
      this.message = 'Hello World';
      
      // DOM 还没有更新
      console.log(this.$el.textContent); // 'Hello'
      
      // 使用 nextTick 等待 DOM 更新
      this.$nextTick(() => {
        console.log(this.$el.textContent); // 'Hello World'
      });
    }
  }
});

// Vue 3
import { nextTick } from 'vue';

const { message } = toRefs(props);

function updateMessage() {
  message.value = 'Hello World';
  
  nextTick(() => {
    console.log('DOM 已更新');
  });
}
```

**为什么使用异步更新？**
- 避免频繁触发 DOM 更新
- 提高性能，批量处理更新
- 保证数据变更和 DOM 更新的顺序

**富途特色考点：**
- 富途高频考察 Vue 的异步更新机制
- 结合实际项目说明 nextTick 的应用场景
- 考察对浏览器事件循环的理解

---

## 算法题

### 9. 实现斐波那契数列（带缓存）

**答案：**

```javascript
// 方法一：使用闭包缓存
function fibonacci() {
  const cache = {};
  
  return function(n) {
    if (n in cache) {
      return cache[n];
    }
    
    if (n <= 1) {
      return n;
    }
    
    const result = fibonacci(n - 1) + fibonacci(n - 2);
    cache[n] = result;
    return result;
  };
}

const fib = fibonacci();
console.log(fib(10)); // 55

// 方法二：使用函数原型缓存
function fibonacciWithProto(n) {
  if (n <= 1) {
    return n;
  }
  
  if (!fibonacciWithProto.cache) {
    fibonacciWithProto.cache = {};
  }
  
  if (n in fibonacciWithProto.cache) {
    return fibonacciWithProto.cache[n];
  }
  
  const result = fibonacciWithProto(n - 1) + fibonacciWithProto(n - 2);
  fibonacciWithProto.cache[n] = result;
  return result;
}

console.log(fibonacciWithProto(10)); // 55

// 方法三：使用 Map 缓存
function fibonacciWithMap(n, cache = new Map()) {
  if (n <= 1) {
    return n;
  }
  
  if (cache.has(n)) {
    return cache.get(n);
  }
  
  const result = fibonacciWithMap(n - 1, cache) + fibonacciWithMap(n - 2, cache);
  cache.set(n, result);
  return result;
}

console.log(fibonacciWithMap(10)); // 55
```

**时间复杂度分析：**
- 不带缓存：O(2^n)
- 带缓存：O(n)

**富途特色考点：**
- 富途高频考察递归和缓存优化
- 结合实际场景说明缓存的重要性
- 考察对时间复杂度的理解

---

### 10. 判断括号是否匹配

**答案：**

```javascript
function isMatch(str) {
  const stack = [];
  const map = {
    '(': ')',
    '[': ']',
    '{': '}'
  };
  
  for (const char of str) {
    if (char in map) {
      stack.push(char);
    } else {
      const top = stack.pop();
      if (!top || map[top] !== char) {
        return false;
      }
    }
  }
  
  return stack.length === 0;
}

// 测试
console.log(isMatch('()')); // true
console.log(isMatch('()[]{}')); // true
console.log(isMatch('(]')); // false
console.log(isMatch('([)]')); // false
console.log(isMatch('{[]}')); // true
```

**时间复杂度：** O(n)
**空间复杂度：** O(n)

**富途特色考点：**
- 富途高频考察栈的使用
- 结合实际场景说明括号匹配的应用
- 考察对数据结构的熟练使用

---

### 11. 股票最佳买卖时机（最多两笔交易）

**答案：**

```javascript
function maxProfit(prices) {
  if (prices.length === 0) return 0;
  
  // 初始化状态变量
  let buy1 = -prices[0];  // 第一次买入后的最大利润
  let sell1 = 0;          // 第一次卖出后的最大利润
  let buy2 = -prices[0];  // 第二次买入后的最大利润
  let sell2 = 0;          // 第二次卖出后的最大利润
  
  for (let i = 1; i < prices.length; i++) {
    // 更新第一次买入和卖出的状态
    buy1 = Math.max(buy1, -prices[i]);
    sell1 = Math.max(sell1, buy1 + prices[i]);
    
    // 更新第二次买入和卖出的状态
    buy2 = Math.max(buy2, sell1 - prices[i]);
    sell2 = Math.max(sell2, buy2 + prices[i]);
  }
  
  return sell2;
}

// 测试
console.log(maxProfit([3, 3, 5, 0, 0, 3, 1, 4])); // 6
console.log(maxProfit([1, 2, 3, 4, 5])); // 4
console.log(maxProfit([7, 6, 4, 3, 1])); // 0
```

**扩展：最多 k 笔交易**

```javascript
function maxProfitK(prices, k) {
  if (prices.length === 0 || k === 0) return 0;
  
  if (k >= prices.length / 2) {
    // 无限次交易
    let profit = 0;
    for (let i = 1; i < prices.length; i++) {
      if (prices[i] > prices[i - 1]) {
        profit += prices[i] - prices[i - 1];
      }
    }
    return profit;
  }
  
  // k 笔交易
  const dp = new Array(k + 1).fill(0).map(() => ({
    buy: -Infinity,
    sell: 0
  }));
  
  for (const price of prices) {
    for (let j = 1; j <= k; j++) {
      dp[j].buy = Math.max(dp[j].buy, dp[j - 1].sell - price);
      dp[j].sell = Math.max(dp[j].sell, dp[j].buy + price);
    }
  }
  
  return dp[k].sell;
}
```

**时间复杂度：** O(n × k)
**空间复杂度：** O(k)

**富途特色考点：**
- 富途高频考察动态规划问题
- 结合金融业务说明股票交易场景
- 考察对算法优化的理解

---

## 场景题

### 12. 实现 async 和 Promise 红绿灯交替

**答案：**

```javascript
// 定义灯的状态
const RED = 'red';
const GREEN = 'green';
const YELLOW = 'yellow';

// 当前灯的状态
let currentState = RED;

// 灯的容器
const lightContainer = document.getElementById('light-container');

// 更新灯的状态
function updateLight(state) {
  // 清除所有灯的亮状态
  lightContainer.querySelectorAll('.light').forEach(light => {
    light.classList.remove('active');
  });
  
  // 根据状态点亮对应的灯
  const lightElement = lightContainer.querySelector(`.${state}`);
  if (lightElement) {
    lightElement.classList.add('active');
  }
}

// 创建一个延迟的 Promise
function delay(time) {
  return new Promise(resolve => {
    setTimeout(resolve, time);
  });
}

// 切换灯的状态
async function switchLight() {
  while (true) {
    updateLight(RED);
    await delay(3000); // 红灯亮 3 秒
    
    updateLight(GREEN);
    await delay(2000); // 绿灯亮 2 秒
    
    updateLight(YELLOW);
    await delay(1000); // 黄灯亮 1 秒
  }
}

// 初始化
switchLight();
```

**HTML 和 CSS：**

```html
<div id="light-container">
  <div class="light red"></div>
  <div class="light yellow"></div>
  <div class="light green"></div>
</div>

<style>
#light-container {
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: center;
}

.light {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background-color: #333;
  transition: background-color 0.3s;
}

.light.active.red {
  background-color: red;
}

.light.active.yellow {
  background-color: yellow;
}

.light.active.green {
  background-color: green;
}
</style>
```

**扩展功能：**

```javascript
// 添加暂停和继续功能
let isPaused = false;

function togglePause() {
  isPaused = !isPaused;
}

async function switchLightWithPause() {
  while (true) {
    if (isPaused) {
      await delay(100);
      continue;
    }
    
    updateLight(RED);
    await delay(3000);
    
    updateLight(GREEN);
    await delay(2000);
    
    updateLight(YELLOW);
    await delay(1000);
  }
}

// 动态调整灯的亮灭时间
const lightConfig = {
  [RED]: 3000,
  [GREEN]: 2000,
  [YELLOW]: 1000
};

async function switchLightWithConfig() {
  while (true) {
    for (const [state, duration] of Object.entries(lightConfig)) {
      updateLight(state);
      await delay(duration);
    }
  }
}
```

**富途特色考点：**
- 富途高频考察 async/await 的使用
- 结合实际场景说明异步编程的应用
- 考察对 Promise 的理解

---

### 13. 实现图片懒加载

**答案：**

```javascript
class LazyImage {
  constructor(options = {}) {
    this.options = {
      rootMargin: '100px',
      threshold: 0.1,
      ...options
    };
    
    this.observer = new IntersectionObserver(
      this.handleIntersect.bind(this),
      this.options
    );
  }
  
  observe(element) {
    this.observer.observe(element);
  }
  
  handleIntersect(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        const src = img.dataset.src;
        
        if (src) {
          img.src = src;
          img.onload = () => {
            img.classList.add('loaded');
          };
          img.onerror = () => {
            img.classList.add('error');
          };
        }
        
        this.observer.unobserve(img);
      }
    });
  }
}

// 使用
const lazyImage = new LazyImage({
  rootMargin: '100px',
  threshold: 0.1
});

document.querySelectorAll('img[data-src]').forEach(img => {
  lazyImage.observe(img);
});
```

**HTML：**

```html
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy" alt="图片">

<style>
img {
  opacity: 0;
  transition: opacity 0.3s;
}

img.loaded {
  opacity: 1;
}

img.error {
  opacity: 0.5;
}
</style>
```

**富途特色考点：**
- 富途高频考察性能优化技术
- 结合实际项目说明懒加载的应用场景
- 考察对 IntersectionObserver API 的使用

---

### 14. 实现防抖函数

**答案：**

```javascript
function debounce(func, wait = 300) {
  let timeout = null;
  
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(this, args);
    }, wait);
  };
}

// 使用
const searchInput = debounce((keyword) => {
  console.log('搜索:', keyword);
  fetch(`/api/search?keyword=${keyword}`)
    .then(res => res.json())
    .then(data => console.log(data));
}, 500);

// 搜索框输入
const input = document.querySelector('input');
input.addEventListener('input', (e) => {
  searchInput(e.target.value);
});
```

**带立即执行选项的防抖：**

```javascript
function debounceWithImmediate(func, wait = 300, immediate = false) {
  let timeout = null;
  
  return function(...args) {
    const callNow = immediate && !timeout;
    
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      timeout = null;
      if (!immediate) {
        func.apply(this, args);
      }
    }, wait);
    
    if (callNow) {
      func.apply(this, args);
    }
  };
}

// 使用
const resizeHandler = debounceWithImmediate(
  () => console.log('窗口大小改变'),
  300,
  true
);

window.addEventListener('resize', resizeHandler);
```

**富途特色考点：**
- 富途高频考察函数节流和防抖
- 结合实际场景说明性能优化的应用
- 考察对异步控制的理解

---

### 15. 如何实现股票 K 线图的实时数据推送和渲染？

**答案：**

股票 K 线图是金融应用中的核心功能，需要实现实时数据推送和高效渲染。

**方案 1：使用 WebSocket 实现实时数据推送**

```javascript
class StockWebSocket {
  constructor(options = {}) {
    this.options = {
      url: 'wss://api.example.com/stocks',
      reconnectInterval: 5000,
      heartbeatInterval: 30000,
      ...options
    };
    
    this.ws = null;
    this.reconnectTimer = null;
    this.heartbeatTimer = null;
    this.listeners = new Map();
    this.isConnected = false;
  }
  
  connect() {
    this.ws = new WebSocket(this.options.url);
    
    this.ws.onopen = () => {
      console.log('WebSocket 连接已建立');
      this.isConnected = true;
      this.startHeartbeat();
      this.emit('connected');
    };
    
    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.handleMessage(data);
      } catch (error) {
        console.error('解析消息失败:', error);
      }
    };
    
    this.ws.onerror = (error) => {
      console.error('WebSocket 错误:', error);
      this.emit('error', error);
    };
    
    this.ws.onclose = () => {
      console.log('WebSocket 连接已关闭');
      this.isConnected = false;
      this.stopHeartbeat();
      this.emit('disconnected');
      this.reconnect();
    };
  }
  
  handleMessage(data) {
    switch (data.type) {
      case 'tick':
        this.emit('tick', data);
        break;
      case 'kline':
        this.emit('kline', data);
        break;
      case 'heartbeat':
        // 心跳响应
        break;
      default:
        console.warn('未知消息类型:', data.type);
    }
  }
  
  startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.isConnected) {
        this.send({ type: 'heartbeat' });
      }
    }, this.options.heartbeatInterval);
  }
  
  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  
  reconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }
    
    this.reconnectTimer = setTimeout(() => {
      console.log('尝试重新连接...');
      this.connect();
    }, this.options.reconnectInterval);
  }
  
  send(data) {
    if (this.isConnected && this.ws) {
      this.ws.send(JSON.stringify(data));
    } else {
      console.warn('WebSocket 未连接，无法发送消息');
    }
  }
  
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }
  
  off(event, callback) {
    if (this.listeners.has(event)) {
      const callbacks = this.listeners.get(event);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }
  
  emit(event, data) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(callback => {
        callback(data);
      });
    }
  }
  
  disconnect() {
    this.stopHeartbeat();
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.isConnected = false;
  }
}

// 使用
const stockWebSocket = new StockWebSocket({
  url: 'wss://api.example.com/stocks'
});

// 监听 K 线数据
stockWebSocket.on('kline', (data) => {
  console.log('收到 K 线数据:', data);
  updateKlineChart(data);
});

// 监听连接状态
stockWebSocket.on('connected', () => {
  console.log('已连接到服务器');
  // 订阅股票数据
  stockWebSocket.send({
    type: 'subscribe',
    symbols: ['AAPL', 'GOOGL', 'MSFT']
  });
});

stockWebSocket.on('disconnected', () => {
  console.log('与服务器断开连接');
});

// 连接
stockWebSocket.connect();
```

**方案 2：使用 Canvas 实现高性能 K 线图渲染**

```javascript
class KlineChart {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.options = {
      width: 800,
      height: 400,
      padding: 40,
      candleWidth: 10,
      candleGap: 2,
      ...options
    };
    
    this.data = [];
    this.init();
  }
  
  init() {
    // 设置 canvas 尺寸
    this.canvas.width = this.options.width * window.devicePixelRatio;
    this.canvas.height = this.options.height * window.devicePixelRatio;
    this.canvas.style.width = `${this.options.width}px`;
    this.canvas.style.height = `${this.options.height}px`;
    
    // 缩放上下文
    this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    
    // 监听鼠标事件
    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
    this.canvas.addEventListener('mouseleave', this.handleMouseLeave.bind(this));
  }
  
  setData(data) {
    this.data = data;
    this.render();
  }
  
  render() {
    const { width, height, padding, candleWidth, candleGap } = this.options;
    
    // 清空画布
    this.ctx.clearRect(0, 0, width, height);
    
    // 计算价格范围
    const prices = this.data.map(d => [d.high, d.low]).flat();
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    const priceRange = maxPrice - minPrice;
    
    // 绘制价格轴
    this.drawPriceAxis(minPrice, maxPrice);
    
    // 绘制 K 线
    this.data.forEach((item, index) => {
      const x = padding + index * (candleWidth + candleGap);
      
      // 计算价格对应的 Y 坐标
      const openY = height - padding - ((item.open - minPrice) / priceRange) * (height - 2 * padding);
      const closeY = height - padding - ((item.close - minPrice) / priceRange) * (height - 2 * padding);
      const highY = height - padding - ((item.high - minPrice) / priceRange) * (height - 2 * padding);
      const lowY = height - padding - ((item.low - minPrice) / priceRange) * (height - 2 * padding);
      
      // 判断涨跌
      const isUp = item.close >= item.open;
      const color = isUp ? '#26a69a' : '#ef5350';
      
      // 绘制影线
      this.ctx.strokeStyle = color;
      this.ctx.lineWidth = 1;
      this.ctx.beginPath();
      this.ctx.moveTo(x + candleWidth / 2, highY);
      this.ctx.lineTo(x + candleWidth / 2, lowY);
      this.ctx.stroke();
      
      // 绘制实体
      this.ctx.fillStyle = color;
      const bodyTop = Math.min(openY, closeY);
      const bodyHeight = Math.abs(closeY - openY) || 1; // 至少 1px
      
      if (isUp) {
        this.ctx.fillRect(x, bodyTop, candleWidth, bodyHeight);
      } else {
        this.ctx.fillRect(x, bodyTop, candleWidth, bodyHeight);
      }
    });
  }
  
  drawPriceAxis(minPrice, maxPrice) {
    const { height, padding } = this.options;
    
    // 绘制价格标签
    const priceStep = (maxPrice - minPrice) / 5;
    
    this.ctx.fillStyle = '#666';
    this.ctx.font = '12px Arial';
    this.ctx.textAlign = 'right';
    
    for (let i = 0; i <= 5; i++) {
      const price = minPrice + i * priceStep;
      const y = height - padding - (i / 5) * (height - 2 * padding);
      
      this.ctx.fillText(price.toFixed(2), padding - 5, y + 4);
      
      // 绘制水平线
      this.ctx.strokeStyle = '#e0e0e0';
      this.ctx.beginPath();
      this.ctx.moveTo(padding, y);
      this.ctx.lineTo(this.options.width - padding, y);
      this.ctx.stroke();
    }
  }
  
  handleMouseMove(event) {
    const rect = this.canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    // 计算鼠标对应的 K 线索引
    const { padding, candleWidth, candleGap } = this.options;
    const index = Math.floor((x - padding) / (candleWidth + candleGap));
    
    if (index >= 0 && index < this.data.length) {
      const item = this.data[index];
      this.showTooltip(event.clientX, event.clientY, item);
    }
  }
  
  handleMouseLeave() {
    this.hideTooltip();
  }
  
  showTooltip(x, y, item) {
    // 显示提示信息
    console.log('K 线信息:', item);
  }
  
  hideTooltip() {
    // 隐藏提示信息
  }
}

// 使用
const canvas = document.getElementById('kline-chart');
const klineChart = new KlineChart(canvas);

// 模拟数据
const klineData = [
  { time: '09:30', open: 100, close: 105, high: 108, low: 98 },
  { time: '09:35', open: 105, close: 103, high: 106, low: 102 },
  { time: '09:40', open: 103, close: 108, high: 110, low: 102 },
  { time: '09:45', open: 108, close: 106, high: 109, low: 105 },
  { time: '09:50', open: 106, close: 110, high: 112, low: 105 },
];

klineChart.setData(klineData);

// 监听 WebSocket 数据
stockWebSocket.on('kline', (data) => {
  // 更新 K 线数据
  klineData.push(data);
  if (klineData.length > 100) {
    klineData.shift();
  }
  klineChart.setData(klineData);
});
```

**方案 3：使用虚拟滚动处理大量 K 线数据**

```javascript
class VirtualKlineChart extends KlineChart {
  constructor(canvas, options = {}) {
    super(canvas, options);
    this.visibleRange = { start: 0, end: 100 };
    this.scrollOffset = 0;
  }
  
  setData(data) {
    this.data = data;
    this.updateVisibleRange();
    this.render();
  }
  
  updateVisibleRange() {
    const { width, padding, candleWidth, candleGap } = this.options;
    const visibleCount = Math.floor((width - 2 * padding) / (candleWidth + candleGap));
    
    this.visibleRange.start = Math.max(0, this.scrollOffset);
    this.visibleRange.end = Math.min(this.data.length, this.scrollOffset + visibleCount);
  }
  
  render() {
    const { width, height, padding, candleWidth, candleGap } = this.options;
    
    // 清空画布
    this.ctx.clearRect(0, 0, width, height);
    
    // 只渲染可见范围内的 K 线
    const visibleData = this.data.slice(this.visibleRange.start, this.visibleRange.end);
    
    // 计算价格范围
    const prices = visibleData.map(d => [d.high, d.low]).flat();
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    const priceRange = maxPrice - minPrice;
    
    // 绘制价格轴
    this.drawPriceAxis(minPrice, maxPrice);
    
    // 绘制 K 线
    visibleData.forEach((item, index) => {
      const globalIndex = this.visibleRange.start + index;
      const x = padding + index * (candleWidth + candleGap);
      
      // 计算价格对应的 Y 坐标
      const openY = height - padding - ((item.open - minPrice) / priceRange) * (height - 2 * padding);
      const closeY = height - padding - ((item.close - minPrice) / priceRange) * (height - 2 * padding);
      const highY = height - padding - ((item.high - minPrice) / priceRange) * (height - 2 * padding);
      const lowY = height - padding - ((item.low - minPrice) / priceRange) * (height - 2 * padding);
      
      // 判断涨跌
      const isUp = item.close >= item.open;
      const color = isUp ? '#26a69a' : '#ef5350';
      
      // 绘制影线
      this.ctx.strokeStyle = color;
      this.ctx.lineWidth = 1;
      this.ctx.beginPath();
      this.ctx.moveTo(x + candleWidth / 2, highY);
      this.ctx.lineTo(x + candleWidth / 2, lowY);
      this.ctx.stroke();
      
      // 绘制实体
      this.ctx.fillStyle = color;
      const bodyTop = Math.min(openY, closeY);
      const bodyHeight = Math.abs(closeY - openY) || 1;
      
      if (isUp) {
        this.ctx.fillRect(x, bodyTop, candleWidth, bodyHeight);
      } else {
        this.ctx.fillRect(x, bodyTop, candleWidth, bodyHeight);
      }
    });
  }
  
  handleWheel(event) {
    const delta = event.deltaY > 0 ? 1 : -1;
    this.scrollOffset = Math.max(0, this.scrollOffset + delta);
    this.updateVisibleRange();
    this.render();
  }
}
```

**富途特色考点：**
- 富途高频考察金融业务场景的实现
- 结合股票交易说明实时数据推送和渲染
- 考察对 WebSocket 和 Canvas 的熟练使用
- 关注性能优化（虚拟滚动、数据缓存）

---

### 16. 如何优化 JSBridge 的通信性能？

**答案：**

JSBridge 是 Native 与 H5 通信的核心，优化通信性能对混合应用至关重要。

**优化方案 1：使用消息队列和批量处理**

```javascript
class JSBridge {
  constructor() {
    this.queue = [];
    this.isProcessing = false;
    this.maxBatchSize = 10;
    this.batchTimeout = 100;
  }
  
  call(method, params = {}) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        method,
        params,
        resolve,
        reject,
        timestamp: Date.now()
      });
      
      this.processQueue();
    });
  }
  
  async processQueue() {
    if (this.isProcessing || this.queue.length === 0) {
      return;
    }
    
    this.isProcessing = true;
    
    // 批量处理
    const batch = this.queue.splice(0, this.maxBatchSize);
    
    try {
      const results = await this.executeBatch(batch);
      
      batch.forEach((item, index) => {
        item.resolve(results[index]);
      });
    } catch (error) {
      batch.forEach(item => item.reject(error));
    } finally {
      this.isProcessing = false;
      
      // 继续处理剩余队列
      if (this.queue.length > 0) {
        setTimeout(() => this.processQueue(), this.batchTimeout);
      }
    }
  }
  
  async executeBatch(batch) {
    // 实现 Native 调用
    const url = `jsbridge://batch?methods=${encodeURIComponent(JSON.stringify(batch.map(item => item.method)))}&params=${encodeURIComponent(JSON.stringify(batch.map(item => item.params)))}`;
    
    return new Promise((resolve, reject) => {
      const iframe = document.createElement('iframe');
      iframe.style.display = 'none';
      
      window.jsbridgeCallback = (result) => {
        document.body.removeChild(iframe);
        resolve(JSON.parse(result));
      };
      
      iframe.src = url;
      document.body.appendChild(iframe);
      
      setTimeout(() => {
        reject(new Error('JSBridge 调用超时'));
      }, 5000);
    });
  }
}

// 使用
const jsBridge = new JSBridge();

// 批量调用
const results = await Promise.all([
  jsBridge.call('getUserInfo'),
  jsBridge.call('getDeviceInfo'),
  jsBridge.call('getLocation')
]);
```

**优化方案 2：使用 WebView 注入 JavaScript**

```javascript
class OptimizedJSBridge {
  constructor() {
    this.nativeReady = false;
    this.pendingCalls = [];
    this.init();
  }
  
  init() {
    // 检查 Native 是否注入了 JavaScript
    if (window.JSBridge && window.JSBridge.call) {
      this.nativeReady = true;
      this.processPendingCalls();
    } else {
      // 等待 Native 注入
      document.addEventListener('JSBridgeReady', () => {
        this.nativeReady = true;
        this.processPendingCalls();
      });
    }
  }
  
  call(method, params = {}) {
    return new Promise((resolve, reject) => {
      const call = {
        method,
        params,
        resolve,
        reject,
        timestamp: Date.now()
      };
      
      if (this.nativeReady) {
        this.executeCall(call);
      } else {
        this.pendingCalls.push(call);
      }
    });
  }
  
  processPendingCalls() {
    while (this.pendingCalls.length > 0) {
      const call = this.pendingCalls.shift();
      this.executeCall(call);
    }
  }
  
  executeCall(call) {
    try {
      const result = window.JSBridge.call(call.method, call.params);
      call.resolve(result);
    } catch (error) {
      call.reject(error);
    }
  }
}

// 使用
const optimizedBridge = new OptimizedJSBridge();

const userInfo = await optimizedBridge.call('getUserInfo');
```

**优化方案 3：使用 WebView 协议优化**

```javascript
class ProtocolJSBridge {
  constructor() {
    this.messageId = 0;
    this.callbacks = new Map();
    this.init();
  }
  
  init() {
    // 监听 Native 消息
    window.addEventListener('message', this.handleMessage.bind(this));
  }
  
  handleMessage(event) {
    const { type, messageId, result, error } = event.data;
    
    if (type === 'jsbridge_response') {
      const callback = this.callbacks.get(messageId);
      
      if (callback) {
        if (error) {
          callback.reject(error);
        } else {
          callback.resolve(result);
        }
        
        this.callbacks.delete(messageId);
      }
    }
  }
  
  call(method, params = {}) {
    return new Promise((resolve, reject) => {
      const messageId = ++this.messageId;
      
      this.callbacks.set(messageId, { resolve, reject });
      
      // 发送消息到 Native
      window.postMessage({
        type: 'jsbridge_call',
        messageId,
        method,
        params
      }, '*');
      
      // 超时处理
      setTimeout(() => {
        const callback = this.callbacks.get(messageId);
        if (callback) {
          callback.reject(new Error('JSBridge 调用超时'));
          this.callbacks.delete(messageId);
        }
      }, 5000);
    });
  }
}

// 使用
const protocolBridge = new ProtocolJSBridge();

const userInfo = await protocolBridge.call('getUserInfo');
```

**性能优化建议：**

1. **减少通信次数**：批量处理多个调用
2. **使用缓存**：缓存频繁调用的结果
3. **异步处理**：避免阻塞主线程
4. **错误重试**：实现自动重试机制
5. **性能监控**：记录调用耗时和成功率

```javascript
class MonitoredJSBridge extends ProtocolJSBridge {
  constructor() {
    super();
    this.metrics = {
      totalCalls: 0,
      successCalls: 0,
      failureCalls: 0,
      avgResponseTime: 0,
      responseTimes: []
    };
  }
  
  async call(method, params = {}) {
    const startTime = Date.now();
    this.metrics.totalCalls++;
    
    try {
      const result = await super.call(method, params);
      this.metrics.successCalls++;
      
      const responseTime = Date.now() - startTime;
      this.metrics.responseTimes.push(responseTime);
      this.updateMetrics();
      
      return result;
    } catch (error) {
      this.metrics.failureCalls++;
      throw error;
    }
  }
  
  updateMetrics() {
    if (this.metrics.responseTimes.length > 0) {
      this.metrics.avgResponseTime = this.metrics.responseTimes.reduce((a, b) => a + b, 0) / this.metrics.responseTimes.length;
    }
    
    // 清理旧数据
    if (this.metrics.responseTimes.length > 1000) {
      this.metrics.responseTimes = this.metrics.responseTimes.slice(-100);
    }
  }
  
  getMetrics() {
    return { ...this.metrics };
  }
}

// 使用
const monitoredBridge = new MonitoredJSBridge();

// 定期检查性能指标
setInterval(() => {
  const metrics = monitoredBridge.getMetrics();
  console.log('JSBridge 性能指标:', metrics);
  
  if (metrics.avgResponseTime > 1000) {
    console.warn('JSBridge 响应时间过长，需要优化');
  }
}, 60000);
```

**富途特色考点：**
- 富途高频考察混合开发性能优化
- 结合实际项目说明 JSBridge 优化方案
- 考察对 Native 与 H5 通信的深入理解
- 关注性能监控和优化

---

## 总结

富途面试题重点掌握：

### 前端基础
1. **JavaScript 核心**（占比 33.3%）：事件循环、异步机制、闭包
2. **前端工程化**（占比 26.7%）：JSBridge、埋点、错误收集
3. **浏览器与网络**（占比 20.0%）：跨域、缓存、性能优化
4. **Vue 框架**（占比 20.0%）：响应式原理、nextTick、数组 hack

### 算法题
1. **递归与缓存**：斐波那契数列、缓存优化
2. **栈应用**：括号匹配
3. **动态规划**：股票交易问题

### 场景题
1. **async/await**：红绿灯交替、异步编程
2. **性能优化**：图片懒加载、防抖节流
3. **金融业务**：股票 K 线图、实时数据推送
4. **混合开发**：JSBridge 优化、Native 与 H5 通信
5. **实际应用**：将算法应用到实际场景

**面试准备建议：**
1. 深入理解 JavaScript 核心原理（事件循环、闭包、原型链）
2. 掌握前端工程化实践（JSBridge、埋点、错误监控）
3. 熟悉 Vue 框架底层原理（响应式系统、nextTick）
4. 熟练掌握手写代码题（斐波那契、括号匹配、防抖节流）
5. 结合金融业务场景（股票交易、数据收集）说明解决方案
6. 注重代码质量和性能优化
7. 保持对新技术的关注和学习热情
8. 掌握 WebSocket 实时通信技术
9. 了解 Canvas 高性能渲染
10. 熟悉混合开发性能优化方案

**富途特色：**
- 高频考察混合开发（JSBridge、Native 与 H5 通信）
- 关注数据埋点和错误监控（金融业务数据收集）
- 考察前端性能优化（懒加载、防抖节流）
- 注重算法题（动态规划、递归优化）
- 关注 Vue 框架深度（响应式原理、nextTick）
- 考察实际项目经验和问题解决能力
- 关注金融业务场景（股票 K 线图、实时数据推送）
- 注重 WebSocket 和 Canvas 的使用
- 关注性能监控和优化