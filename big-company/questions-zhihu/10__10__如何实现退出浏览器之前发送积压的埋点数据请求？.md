# 10. 如何实现退出浏览器之前发送积压的埋点数据请求？

**答案：**

在页面关闭前发送积压的埋点数据是一个常见需求，需要使用特殊的 API 来确保数据能够发送成功。

**实现方案：**

**方案 1：使用 navigator.sendBeacon**
```javascript
class BeaconSender {
  constructor(options = {}) {
    this.options = {
      endpoint: '/api/analytics',
      maxRetries: 3,
      retryDelay: 1000,
      ...options
    };
    
    this.queue = [];
    this.sending = false;
    this.init();
  }
  
  init() {
    // 页面卸载前发送
    window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
    window.addEventListener('pagehide', this.handlePageHide.bind(this));
    
    // 定期发送
    setInterval(() => this.flush(), 30000);
  }
  
  add(data) {
    this.queue.push({
      data,
      timestamp: Date.now()
    });
    
    // 如果队列超过阈值，立即发送
    if (this.queue.length >= 10) {
      this.flush();
    }
  }
  
  async flush() {
    if (this.sending || this.queue.length === 0) {
      return;
    }
    
    this.sending = true;
    
    const dataToSend = [...this.queue];
    this.queue = [];
    
    try {
      const success = await this.sendWithRetry(dataToSend);
      
      if (!success) {
        // 发送失败，重新加入队列
        this.queue.unshift(...dataToSend);
      }
    } catch (error) {
      console.error('发送埋点数据失败:', error);
      this.queue.unshift(...dataToSend);
    } finally {
      this.sending = false;
    }
  }
  
  sendWithRetry(data, retryCount = 0) {
    return new Promise((resolve) => {
      const success = this.sendData(data);
      
      if (success) {
        resolve(true);
      } else if (retryCount < this.options.maxRetries) {
        setTimeout(() => {
          this.sendWithRetry(data, retryCount + 1).then(resolve);
        }, this.options.retryDelay);
      } else {
        resolve(false);
      }
    });
  }
  
  sendData(data) {
    try {
      const blob = new Blob([JSON.stringify(data)], {
        type: 'application/json'
      });
      
      return navigator.sendBeacon(this.options.endpoint, blob);
    } catch (error) {
      console.error('sendBeacon 失败:', error);
      return false;
    }
  }
  
  handleBeforeUnload() {
    // 页面卸载前发送
    if (this.queue.length > 0) {
      this.flush();
    }
  }
  
  handlePageHide() {
    // 页面隐藏时发送（包括页面关闭）
    if (this.queue.length > 0) {
      this.flush();
    }
  }
}

// 使用
const beaconSender = new BeaconSender({
  endpoint: '/api/analytics'
});

// 添加埋点数据
beaconSender.add({
  event: 'page_view',
  page: window.location.pathname,
  timestamp: Date.now()
});

beaconSender.add({
  event: 'click',
  element: 'button',
  timestamp: Date.now()
});
```

**方案 2：使用 XMLHttpRequest 同步请求**
```javascript
class SyncSender {
  constructor(options = {}) {
    this.options = {
      endpoint: '/api/analytics',
      ...options
    };
    
    this.queue = [];
    this.init();
  }
  
  init() {
    window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
    window.addEventListener('pagehide', this.handlePageHide.bind(this));
  }
  
  add(data) {
    this.queue.push({
      data,
      timestamp: Date.now()
    });
  }
  
  handleBeforeUnload() {
    if (this.queue.length > 0) {
      this.sendSync();
    }
  }
  
  handlePageHide() {
    if (this.queue.length > 0) {
      this.sendSync();
    }
  }
  
  sendSync() {
    try {
      const xhr = new XMLHttpRequest();
      xhr.open('POST', this.options.endpoint, false); // 同步请求
      xhr.setRequestHeader('Content-Type', 'application/json');
      xhr.send(JSON.stringify(this.queue));
      
      // 清空队列
      this.queue = [];
    } catch (error) {
      console.error('同步发送埋点数据失败:', error);
      
      // 失败时尝试使用 sendBeacon
      this.sendWithBeacon();
    }
  }
  
  sendWithBeacon() {
    try {
      const blob = new Blob([JSON.stringify(this.queue)], {
        type: 'application/json'
      });
      
      const success = navigator.sendBeacon(this.options.endpoint, blob);
      
      if (success) {
        this.queue = [];
      }
    } catch (error) {
      console.error('sendBeacon 失败:', error);
    }
  }
}

// 使用
const syncSender = new SyncSender();

syncSender.add({
  event: 'page_view',
  page: window.location.pathname
});
```

**方案 3：使用 Visibility API**
```javascript
class VisibilitySender {
  constructor(options = {}) {
    this.options = {
      endpoint: '/api/analytics',
      ...options
    };
    
    this.queue = [];
    this.init();
  }
  
  init() {
    document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
  }
  
  add(data) {
    this.queue.push({
      data,
      timestamp: Date.now()
    });
  }
  
  handleVisibilityChange() {
    if (document.visibilityState === 'hidden') {
      // 页面隐藏时发送
      this.flush();
    }
  }
  
  async flush() {
    if (this.queue.length === 0) {
      return;
    }
    
    const dataToSend = [...this.queue];
    this.queue = [];
    
    try {
      const response = await fetch(this.options.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(dataToSend),
        keepalive: true // 使用 keepalive 模式
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      console.error('发送埋点数据失败:', error);
      
      // 失败时尝试使用 sendBeacon
      this.sendWithBeacon(dataToSend);
    }
  }
  
  sendWithBeacon(data) {
    try {
      const blob = new Blob([JSON.stringify(data)], {
        type: 'application/json'
      });
      
      const success = navigator.sendBeacon(this.options.endpoint, blob);
      
      if (!success) {
        // sendBeacon 失败，重新加入队列
        this.queue.unshift(...data);
      }
    } catch (error) {
      console.error('sendBeacon 失败:', error);
      this.queue.unshift(...data);
    }
  }
}

// 使用
const visibilitySender = new VisibilitySender();

visibilitySender.add({
  event: 'page_view',
  page: window.location.pathname
});
```

**方案 4：使用 IndexedDB 持久化**
```javascript
class PersistentSender {
  constructor(options = {}) {
    this.options = {
      endpoint: '/api/analytics',
      dbName: 'analyticsDB',
      storeName: 'events',
      ...options
    };
    
    this.db = null;
    this.init();
  }
  
  async init() {
    this.db = await this.openDB();
    
    // 页面加载时发送积压的数据
    this.flushPendingEvents();
    
    // 页面关闭前发送
    window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
    window.addEventListener('pagehide', this.handlePageHide.bind(this));
  }
  
  async openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.options.dbName, 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.options.storeName)) {
          const store = db.createObjectStore(this.options.storeName, {
            keyPath: 'id',
            autoIncrement: true
          });
          store.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }
  
  async add(data) {
    const transaction = this.db.transaction([this.options.storeName], 'readwrite');
    const store = transaction.objectStore(this.options.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.add({
        data,
        timestamp: Date.now(),
        sent: false
      });
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async flushPendingEvents() {
    const transaction = this.db.transaction([this.options.storeName], 'readonly');
    const store = transaction.objectStore(this.options.storeName);
    const index = store.index('timestamp');
    
    const events = await new Promise((resolve, reject) => {
      const request = index.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
    
    // 发送未发送的事件
    const pendingEvents = events.filter(event => !event.sent);
    
    for (const event of pendingEvents) {
      await this.sendEvent(event);
    }
  }
  
  async sendEvent(event) {
    try {
      const response = await fetch(this.options.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(event.data),
        keepalive: true
      });
      
      if (response.ok) {
        // 发送成功，标记为已发送
        await this.markAsSent(event.id);
      }
    } catch (error) {
      console.error('发送事件失败:', error);
    }
  }
  
  async markAsSent(id) {
    const transaction = this.db.transaction([this.options.storeName], 'readwrite');
    const store = transaction.objectStore(this.options.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.get(id);
      
      request.onsuccess = () => {
        const event = request.result;
        event.sent = true;
        
        const updateRequest = store.put(event);
        updateRequest.onsuccess = () => resolve();
        updateRequest.onerror = () => reject(updateRequest.error);
      };
      
      request.onerror = () => reject(request.error);
    });
  }
  
  handleBeforeUnload() {
    // 页面关闭前使用 sendBeacon 发送
    this.flushWithBeacon();
  }
  
  handlePageHide() {
    // 页面隐藏时使用 sendBeacon 发送
    this.flushWithBeacon();
  }
  
  async flushWithBeacon() {
    const transaction = this.db.transaction([this.options.storeName], 'readonly');
    const store = transaction.objectStore(this.options.storeName);
    const index = store.index('timestamp');
    
    const events = await new Promise((resolve, reject) => {
      const request = index.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
    
    const pendingEvents = events.filter(event => !event.sent);
    
    if (pendingEvents.length > 0) {
      try {
        const blob = new Blob([JSON.stringify(pendingEvents.map(e => e.data))], {
          type: 'application/json'
        });
        
        const success = navigator.sendBeacon(this.options.endpoint, blob);
        
        if (success) {
          // 标记所有事件为已发送
          for (const event of pendingEvents) {
            await this.markAsSent(event.id);
          }
        }
      } catch (error) {
        console.error('sendBeacon 失败:', error);
      }
    }
  }
}

// 使用
const persistentSender = new PersistentSender();

persistentSender.add({
  event: 'page_view',
  page: window.location.pathname
});
```

---

## 总结

知乎面试题重点掌握：

### 前端基础
1. **路由系统**：Hash路由、History路由、动态路由
2. **富文本编辑器**：contentEditable、execCommand
3. **图片压缩**：Canvas、toBlob、压缩算法
4. **缓存策略**：内存、LocalStorage、IndexedDB
5. **设备检测**：User-Agent、媒体查询、功能检测
6. **数据发送**：sendBeacon、同步请求、Visibility API

### 算法题
1. **布隆过滤器**：海量数据去重、黑名单
2. **一致性哈希**：分布式缓存、负载均衡

### 场景题
1. **拖拽上传**：拖拽事件、文件上传、进度显示
2. **设备检测**：响应式设计、设备适配
3. **数据发送**：页面关闭前发送、埋点数据

**面试准备建议：**
1. 深入理解路由系统
2. 掌握富文本编辑器原理
3. 熟悉图片处理技术
4. 了解缓存策略和实现
5. 注重代码质量和可维护性
6. 掌握设备检测技术
7. 理解数据发送策略
