# 2. 如何实现一个前端图片压缩？

**答案：**

```javascript
// 图片压缩实现
class ImageCompressor {
  constructor(options = {}) {
    this.options = {
      quality: 0.8,
      maxWidth: 1920,
      maxHeight: 1080,
      mimeType: 'image/jpeg',
      ...options,
    };
  }
  
  async compress(file) {
    return new Promise((resolve, reject) => {
      // 检查文件类型
      if (!file.type.startsWith('image/')) {
        reject(new Error('文件必须是图片'));
        return;
      }
      
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const img = new Image();
        
        img.onload = () => {
          const compressedFile = this._compressImage(img);
          resolve(compressedFile);
        };
        
        img.onerror = () => {
          reject(new Error('图片加载失败'));
        };
        
        img.src = e.target.result;
      };
      
      reader.onerror = () => {
        reject(new Error('文件读取失败'));
      };
      
      reader.readAsDataURL(file);
    });
  }
  
  _compressImage(img) {
    // 计算新尺寸
    const { width, height } = this._calculateSize(img.width, img.height);
    
    // 创建 Canvas
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    
    // 绘制图片
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, width, height);
    
    // 压缩
    const compressedDataUrl = canvas.toDataURL(this.options.mimeType, this.options.quality);
    
    // 转换为 File
    const compressedFile = this._dataURLToFile(compressedDataUrl, this.options.mimeType);
    
    return {
      file: compressedFile,
      dataUrl: compressedDataUrl,
      originalSize: img.width * img.height,
      compressedSize: width * height,
      originalFile: img.src,
    };
  }
  
  _calculateSize(width, height) {
    const { maxWidth, maxHeight } = this.options;
    
    let newWidth = width;
    let newHeight = height;
    
    // 计算缩放比例
    const ratio = Math.min(maxWidth / width, maxHeight / height);
    
    if (ratio < 1) {
      newWidth = Math.round(width * ratio);
      newHeight = Math.round(height * ratio);
    }
    
    return { width: newWidth, height: newHeight };
  }
  
  _dataURLToFile(dataURL, mimeType) {
    const arr = dataURL.split(',');
    const match = arr[0].match(/:(.*?);/);
    const mime = match ? match[1] : mimeType;
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    
    return new File([u8arr], 'compressed.jpg', { type: mime });
  }
  
  async compressMultiple(files) {
    const results = [];
    
    for (const file of files) {
      try {
        const compressed = await this.compress(file);
        results.push(compressed);
      } catch (error) {
        results.push({ error, file });
      }
    }
    
    return results;
  }
}
```

---

## 算法题
