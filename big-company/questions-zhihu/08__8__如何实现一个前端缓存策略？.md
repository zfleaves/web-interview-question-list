# 8. 如何实现一个前端缓存策略？

**答案：**

```javascript
class CacheStrategy {
  constructor(options = {}) {
    this.options = {
      memory: true,
      localStorage: true,
      sessionStorage: false,
      indexedDB: false,
      ...options
    };
    
    this.memoryCache = new Map();
    this.init();
  }
  
  init() {
    // 初始化 IndexedDB
    if (this.options.indexedDB) {
      this.initIndexedDB();
    }
  }
  
  // 设置缓存
  async set(key, value, options = {}) {
    const {
      ttl = 3600000, // 1小时
      strategy = 'all' // all, memory, localStorage, sessionStorage, indexedDB
    } = options;
    
    const item = {
      value,
      expire: Date.now() + ttl
    };
    
    // 内存缓存
    if (this.options.memory && (strategy === 'all' || strategy === 'memory')) {
      this.memoryCache.set(key, item);
    }
    
    // LocalStorage
    if (this.options.localStorage && (strategy === 'all' || strategy === 'localStorage')) {
      try {
        localStorage.setItem(key, JSON.stringify(item));
      } catch (e) {
        console.error('LocalStorage quota exceeded:', e);
      }
    }
    
    // SessionStorage
    if (this.options.sessionStorage && (strategy === 'all' || strategy === 'sessionStorage')) {
      try {
        sessionStorage.setItem(key, JSON.stringify(item));
      } catch (e) {
        console.error('SessionStorage quota exceeded:', e);
      }
    }
    
    // IndexedDB
    if (this.options.indexedDB && (strategy === 'all' || strategy === 'indexedDB')) {
      await this.setIndexedDB(key, item);
    }
  }
  
  // 获取缓存
  async get(key, strategy = 'all') {
    let item = null;
    
    // 优先从内存获取
    if (this.options.memory && (strategy === 'all' || strategy === 'memory')) {
      item = this.memoryCache.get(key);
    }
    
    // 从 LocalStorage 获取
    if (!item && this.options.localStorage && (strategy === 'all' || strategy === 'localStorage')) {
      try {
        const data = localStorage.getItem(key);
        item = data ? JSON.parse(data) : null;
      } catch (e) {
        console.error('Failed to get from LocalStorage:', e);
      }
    }
    
    // 从 SessionStorage 获取
    if (!item && this.options.sessionStorage && (strategy === 'all' || strategy === 'sessionStorage')) {
      try {
        const data = sessionStorage.getItem(key);
        item = data ? JSON.parse(data) : null;
      } catch (e) {
        console.error('Failed to get from SessionStorage:', e);
      }
    }
    
    // 从 IndexedDB 获取
    if (!item && this.options.indexedDB && (strategy === 'all' || strategy === 'indexedDB')) {
      item = await this.getIndexedDB(key);
    }
    
    // 检查是否过期
    if (item && item.expire < Date.now()) {
      this.delete(key, strategy);
      return null;
    }
    
    return item ? item.value : null;
  }
  
  // 删除缓存
  async delete(key, strategy = 'all') {
    if (this.options.memory && (strategy === 'all' || strategy === 'memory')) {
      this.memoryCache.delete(key);
    }
    
    if (this.options.localStorage && (strategy === 'all' || strategy === 'localStorage')) {
      localStorage.removeItem(key);
    }
    
    if (this.options.sessionStorage && (strategy === 'all' || strategy === 'sessionStorage')) {
      sessionStorage.removeItem(key);
    }
    
    if (this.options.indexedDB && (strategy === 'all' || strategy === 'indexedDB')) {
      await this.deleteIndexedDB(key);
    }
  }
  
  // 清空缓存
  async clear(strategy = 'all') {
    if (this.options.memory && (strategy === 'all' || strategy === 'memory')) {
      this.memoryCache.clear();
    }
    
    if (this.options.localStorage && (strategy === 'all' || strategy === 'localStorage')) {
      localStorage.clear();
    }
    
    if (this.options.sessionStorage && (strategy === 'all' || strategy === 'sessionStorage')) {
      sessionStorage.clear();
    }
    
    if (this.options.indexedDB && (strategy === 'all' || strategy === 'indexedDB')) {
      await this.clearIndexedDB();
    }
  }
  
  // IndexedDB 相关方法
  initIndexedDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('cacheDB', 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('cache')) {
          db.createObjectStore('cache');
        }
      };
    });
  }
  
  async setIndexedDB(key, item) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['cache'], 'readwrite');
      const store = transaction.objectStore('cache');
      const request = store.put(item, key);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  async getIndexedDB(key) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['cache'], 'readonly');
      const store = transaction.objectStore('cache');
      const request = store.get(key);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async deleteIndexedDB(key) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['cache'], 'readwrite');
      const store = transaction.objectStore('cache');
      const request = store.delete(key);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  async clearIndexedDB() {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['cache'], 'readwrite');
      const store = transaction.objectStore('cache');
      const request = store.clear();
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
}
```

---
