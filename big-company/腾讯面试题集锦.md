# 腾讯面试题集锦（截止 2025 年底）

## 目录
1. [前端基础](#前端基础)
2. [算法题](#算法题)
3. [场景题](#场景题)

---

## 前端基础

### 1. 谈谈你对前端性能优化的理解，有哪些优化手段？

**答案：**

**性能优化核心思路：**

1. **加载性能优化**（减少首屏时间）
2. **运行性能优化**（减少卡顿、提高响应速度）
3. **渲染性能优化**（提高 FPS、减少重排重绘）

**具体优化手段：**

```javascript
// 1. 资源加载优化

// 代码分割（Webpack）
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },
  },
};

// 动态导入
const Home = lazy(() => import('./Home'));
const About = lazy(() => import('./About'));

// 预加载关键资源
<link rel="preload" href="critical.css" as="style">
<link rel="prefetch" href="next-page.js">

// 2. 网络优化

// HTTP 缓存
app.use(express.static('public', {
  maxAge: '1y',
  etag: true,
  lastModified: true,
}));

// CDN 加速
const cdnUrl = 'https://cdn.example.com';
const script = document.createElement('script');
script.src = `${cdnUrl}/app.js`;

// 3. 渲染优化

// 虚拟列表
function VirtualList({ items, itemHeight, visibleCount }) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleCount, items.length);
  const visibleItems = items.slice(startIndex, endIndex);
  
  return (
    <div
      style={{ height: visibleCount * itemHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItems.map((item, i) => (
          <div
            key={startIndex + i}
            style={{
              position: 'absolute',
              top: (startIndex + i) * itemHeight,
              height: itemHeight,
            }}
          >
            {item}
          </div>
        ))}
      </div>
    </div>
  );
}

// 防抖和节流
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

function throttle(fn, delay) {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      fn.apply(this, args);
      lastCall = now;
    }
  };
}

// 4. 代码优化

// 避免内存泄漏
useEffect(() => {
  const timer = setInterval(() => {
    console.log('tick');
  }, 1000);
  
  return () => clearInterval(timer); // 清理定时器
}, []);

// 使用 useMemo 和 useCallback
function ExpensiveComponent({ items }) {
  const expensiveValue = useMemo(() => {
    return items.filter(item => item.active).reduce((sum, item) => sum + item.value, 0);
  }, [items]);
  
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);
  
  return <div onClick={handleClick}>{expensiveValue}</div>;
}
```

**监控指标：**

```javascript
// Core Web Vitals
function measureWebVitals() {
  // Largest Contentful Paint (LCP) - 最大内容绘制
  new PerformanceObserver((list) => {
    const entries = list.getEntries();
    const lastEntry = entries[entries.length - 1];
    console.log('LCP:', lastEntry.renderTime || lastEntry.loadTime);
  }).observe({ type: 'largest-contentful-paint', buffered: true });
  
  // First Input Delay (FID) - 首次输入延迟
  new PerformanceObserver((list) => {
    const entries = list.getEntries();
    entries.forEach(entry => {
      console.log('FID:', entry.processingStart - entry.startTime);
    });
  }).observe({ type: 'first-input', buffered: true });
  
  // Cumulative Layout Shift (CLS) - 累积布局偏移
  let clsValue = 0;
  new PerformanceObserver((list) => {
    const entries = list.getEntries();
    entries.forEach(entry => {
      if (!entry.hadRecentInput) {
        clsValue += entry.value;
      }
    });
    console.log('CLS:', clsValue);
  }).observe({ type: 'layout-shift', buffered: true });
}
```

---

### 2. 如何实现一个前端监控系统？

**答案：**

**监控系统架构：**

```javascript
// 1. 错误监控
class ErrorMonitor {
  constructor(config) {
    this.config = config;
    this.init();
  }
  
  init() {
    // 捕获 JavaScript 错误
    window.addEventListener('error', this.handleError.bind(this));
    
    // 捕获 Promise 错误
    window.addEventListener('unhandledrejection', this.handlePromiseError.bind(this));
    
    // 捕获资源加载错误
    window.addEventListener('error', this.handleResourceError.bind(this), true);
    
    // 捕获 Vue 错误
    if (window.Vue) {
      Vue.config.errorHandler = this.handleVueError.bind(this);
    }
    
    // 捕获 React 错误（需要 Error Boundary）
  }
  
  handleError(event) {
    this.report({
      type: 'js_error',
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
    });
  }
  
  handlePromiseError(event) {
    this.report({
      type: 'promise_error',
      message: event.reason?.message,
      stack: event.reason?.stack,
      timestamp: Date.now(),
      url: window.location.href,
    });
  }
  
  handleResourceError(event) {
    if (event.target !== window) {
      this.report({
        type: 'resource_error',
        message: `资源加载失败: ${event.target.src || event.target.href}`,
        tagName: event.target.tagName,
        timestamp: Date.now(),
      });
    }
  }
  
  handleVueError(err, vm, info) {
    this.report({
      type: 'vue_error',
      message: err.message,
      stack: err.stack,
      component: vm?.$options?.name,
      info: info,
      timestamp: Date.now(),
    });
  }
  
  report(data) {
    // 上报到服务器
    fetch(this.config.reportUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    }).catch(err => console.error('上报失败:', err));
  }
}

// 使用
const monitor = new ErrorMonitor({
  reportUrl: 'https://monitor.example.com/api/error',
});

// 2. 性能监控
class PerformanceMonitor {
  constructor(config) {
    this.config = config;
    this.init();
  }
  
  init() {
    // 页面加载性能
    window.addEventListener('load', () => {
      setTimeout(() => this.measurePageLoad(), 0);
    });
    
    // 资源加载性能
    this.measureResources();
    
    // 用户行为监控
    this.trackUserBehavior();
  }
  
  measurePageLoad() {
    const perfData = performance.getEntriesByType('navigation')[0];
    
    const metrics = {
      // DNS 查询时间
      dns: perfData.domainLookupEnd - perfData.domainLookupStart,
      // TCP 连接时间
      tcp: perfData.connectEnd - perfData.connectStart,
      // 请求响应时间
      ttfb: perfData.responseStart - perfData.requestStart,
      // DOM 解析时间
      domParse: perfData.domComplete - perfData.domInteractive,
      // 资源加载时间
      resourceLoad: perfData.loadEventStart - perfData.domContentLoadedEventEnd,
      // 首屏时间
      firstPaint: this.getFirstPaint(),
      // 可交互时间
      tti: this.getTimeToInteractive(),
    };
    
    this.report({
      type: 'page_performance',
      metrics,
      timestamp: Date.now(),
      url: window.location.href,
    });
  }
  
  getFirstPaint() {
    const paintEntries = performance.getEntriesByType('paint');
    const firstPaint = paintEntries.find(entry => entry.name === 'first-paint');
    return firstPaint ? firstPaint.startTime : 0;
  }
  
  getTimeToInteractive() {
    // 使用 PerformanceObserver 监听 TTI
    return new Promise((resolve) => {
      if (window.PerformanceObserver) {
        const observer = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const tti = entries[0]?.startTime || 0;
          resolve(tti);
        });
        observer.observe({ type: 'longtask', buffered: true });
      } else {
        resolve(0);
      }
    });
  }
  
  measureResources() {
    const resources = performance.getEntriesByType('resource');
    
    const slowResources = resources.filter(resource => {
      return resource.duration > 1000; // 超过 1 秒的慢资源
    });
    
    if (slowResources.length > 0) {
      this.report({
        type: 'slow_resources',
        resources: slowResources.map(r => ({
          name: r.name,
          duration: r.duration,
          size: r.transferSize,
        })),
        timestamp: Date.now(),
      });
    }
  }
  
  trackUserBehavior() {
    // 点击事件
    document.addEventListener('click', (e) => {
      this.report({
        type: 'click',
        target: e.target.tagName,
        className: e.target.className,
        id: e.target.id,
        timestamp: Date.now(),
      });
    });
    
    // 页面停留时间
    const startTime = Date.now();
    window.addEventListener('beforeunload', () => {
      const duration = Date.now() - startTime;
      this.report({
        type: 'page_view_duration',
        duration,
        url: window.location.href,
      });
    });
  }
  
  report(data) {
    // 使用 sendBeacon 确保页面关闭时也能上报
    if (navigator.sendBeacon) {
      const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
      navigator.sendBeacon(this.config.reportUrl, blob);
    } else {
      fetch(this.config.reportUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
    }
  }
}

// 使用
const perfMonitor = new PerformanceMonitor({
  reportUrl: 'https://monitor.example.com/api/performance',
});
```

---

## 算法题

### 3. 实现一个 LRU 缓存

**答案：**

```javascript
// 使用 Map 实现 O(1) 时间复杂度
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    // 重新设置以更新访问顺序
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    
    return value;
  }
  
  put(key, value) {
    if (this.cache.has(key)) {
      // 更新现有 key
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // 删除最久未使用的（第一个）
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
  }
}

// 使用
const lru = new LRUCache(2);
lru.put(1, 'a');
lru.put(2, 'b');
console.log(lru.get(1)); // 'a'
lru.put(3, 'c'); // 删除 key 2
console.log(lru.get(2)); // -1

// 扩展：实现带过期时间的 LRU
class LRUCacheWithTTL {
  constructor(capacity, ttl = 60000) {
    this.capacity = capacity;
    this.ttl = ttl;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    const item = this.cache.get(key);
    
    // 检查是否过期
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return -1;
    }
    
    // 更新访问时间和顺序
    this.cache.delete(key);
    this.cache.set(key, { ...item, timestamp: Date.now() });
    
    return item.value;
  }
  
  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, {
      value,
      timestamp: Date.now(),
    });
  }
  
  // 清理过期项
  cleanExpired() {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
  }
}
```

**场景应用：**

```javascript
// 前端图片缓存
class ImageCache {
  constructor(maxSize = 20, ttl = 3600000) { // 1小时
    this.cache = new LRUCacheWithTTL(maxSize, ttl);
  }
  
  async loadImage(url) {
    // 检查缓存
    const cached = this.cache.get(url);
    if (cached !== -1) {
      return cached;
    }
    
    // 加载图片
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        this.cache.put(url, img.src);
        resolve(img.src);
      };
      img.onerror = reject;
      img.src = url;
    });
  }
}

// API 响应缓存
class APICache {
  constructor(maxSize = 50, ttl = 300000) { // 5分钟
    this.cache = new LRUCacheWithTTL(maxSize, ttl);
  }
  
  async fetch(url, options = {}) {
    const cacheKey = `${url}_${JSON.stringify(options)}`;
    
    // 检查缓存
    const cached = this.cache.get(cacheKey);
    if (cached !== -1) {
      return cached;
    }
    
    // 发起请求
    const response = await fetch(url, options);
    const data = await response.json();
    
    // 缓存结果
    this.cache.put(cacheKey, data);
    
    return data;
  }
}
```

---

### 4. 实现一个防抖函数，支持立即执行

**答案：**

```javascript
// 基础防抖
function debounce(fn, delay) {
  let timer = null;
  
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 支持立即执行的防抖
function debounce(fn, delay, immediate = false) {
  let timer = null;
  let isInvoked = false;
  
  return function(...args) {
    const context = this;
    
    const later = () => {
      timer = null;
      if (!immediate && !isInvoked) {
        fn.apply(context, args);
      }
      isInvoked = false;
    };
    
    const callNow = immediate && !timer;
    
    clearTimeout(timer);
    timer = setTimeout(later, delay);
    
    if (callNow) {
      isInvoked = true;
      fn.apply(context, args);
    }
  };
}

// 使用示例
const debouncedSearch = debounce(function(query) {
  console.log('搜索:', query);
}, 300, false);

// 立即执行版本
const debouncedSubmit = debounce(function(data) {
  console.log('提交:', data);
}, 1000, true);

// 扩展：支持取消
function debounce(fn, delay, immediate = false) {
  let timer = null;
  let isInvoked = false;
  
  const debounced = function(...args) {
    const context = this;
    
    const later = () => {
      timer = null;
      if (!immediate && !isInvoked) {
        fn.apply(context, args);
      }
      isInvoked = false;
    };
    
    const callNow = immediate && !timer;
    
    clearTimeout(timer);
    timer = setTimeout(later, delay);
    
    if (callNow) {
      isInvoked = true;
      fn.apply(context, args);
    }
  };
  
  // 取消防抖
  debounced.cancel = function() {
    clearTimeout(timer);
    timer = null;
    isInvoked = false;
  };
  
  // 立即执行
  debounced.flush = function() {
    if (timer) {
      clearTimeout(timer);
      fn.apply(this, arguments);
    }
  };
  
  return debounced;
}

// 使用
const debounced = debounce(function() {
  console.log('执行');
}, 1000);

debounced(); // 1秒后执行
debounced.cancel(); // 取消执行

debounced.flush(); // 立即执行
```

**场景应用：**

```javascript
// 搜索框防抖
class SearchBox {
  constructor() {
    this.input = document.getElementById('search-input');
    this.debouncedSearch = debounce(this.performSearch.bind(this), 300);
    
    this.input.addEventListener('input', (e) => {
      this.debouncedSearch(e.target.value);
    });
  }
  
  async performSearch(query) {
    if (!query.trim()) {
      this.clearResults();
      return;
    }
    
    try {
      const results = await fetch(`/api/search?q=${encodeURIComponent(query)}`)
        .then(res => res.json());
      this.displayResults(results);
    } catch (error) {
      console.error('搜索失败:', error);
    }
  }
  
  clearResults() {
    // 清空结果
  }
  
  displayResults(results) {
    // 显示结果
  }
}

// 窗口大小调整防抖
class ResponsiveLayout {
  constructor() {
    this.debouncedResize = debounce(this.handleResize.bind(this), 200);
    window.addEventListener('resize', this.debouncedResize);
    this.handleResize();
  }
  
  handleResize() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    // 根据屏幕大小调整布局
    if (width < 768) {
      this.setMobileLayout();
    } else {
      this.setDesktopLayout();
    }
  }
  
  setMobileLayout() {
    // 移动端布局
  }
  
  setDesktopLayout() {
    // 桌面端布局
  }
}

// 表单提交防抖
class FormSubmitter {
  constructor() {
    this.form = document.getElementById('my-form');
    this.debouncedSubmit = debounce(this.submitForm.bind(this), 1000, true);
    
    this.form.addEventListener('submit', (e) => {
      e.preventDefault();
      this.debouncedSubmit(new FormData(this.form));
    });
  }
  
  async submitForm(formData) {
    try {
      const response = await fetch('/api/submit', {
        method: 'POST',
        body: formData,
      });
      const result = await response.json();
      this.handleSuccess(result);
    } catch (error) {
      this.handleError(error);
    }
  }
  
  handleSuccess(result) {
    // 处理成功
  }
  
  handleError(error) {
    // 处理错误
  }
}
```

---

## 场景题

### 5. 如何实现一个前端路由系统？

**答案：**

```javascript
// Hash 路由实现
class HashRouter {
  constructor() {
    this.routes = {};
    this.currentUrl = '';
    this.init();
  }
  
  init() {
    // 监听 hash 变化
    window.addEventListener('hashchange', this.handleHashChange.bind(this));
    window.addEventListener('load', this.handleHashChange.bind(this));
  }
  
  // 注册路由
  register(path, handler) {
    this.routes[path] = handler;
  }
  
  // 处理 hash 变化
  handleHashChange() {
    const hash = window.location.hash.slice(1) || '/';
    this.currentUrl = hash;
    this.matchRoute(hash);
  }
  
  // 路由匹配
  matchRoute(path) {
    // 精确匹配
    if (this.routes[path]) {
      this.routes[path]();
      return;
    }
    
    // 动态路由匹配
    for (const route in this.routes) {
      const params = this.matchDynamicRoute(route, path);
      if (params) {
        this.routes[route](params);
        return;
      }
    }
    
    // 404 处理
    if (this.routes['*']) {
      this.routes['*']();
    }
  }
  
  // 动态路由匹配
  matchDynamicRoute(route, path) {
    const routeParts = route.split('/');
    const pathParts = path.split('/');
    
    if (routeParts.length !== pathParts.length) {
      return null;
    }
    
    const params = {};
    
    for (let i = 0; i < routeParts.length; i++) {
      const routePart = routeParts[i];
      const pathPart = pathParts[i];
      
      if (routePart.startsWith(':')) {
        params[routePart.slice(1)] = pathPart;
      } else if (routePart !== pathPart) {
        return null;
      }
    }
    
    return params;
  }
  
  // 导航
  navigate(path) {
    window.location.hash = path;
  }
  
  // 替换
  replace(path) {
    window.location.replace(`#${path}`);
  }
  
  // 后退
  back() {
    window.history.back();
  }
  
  // 前进
  forward() {
    window.history.forward();
  }
}
```

---

### 6. 如何实现一个虚拟滚动列表？

**答案：**

```javascript
class VirtualList extends React.Component {
  state = {
    visibleStart: 0,
    visibleEnd: 10
  };
  
  containerRef = React.createRef();
  
  componentDidMount() {
    this.containerRef.current.addEventListener('scroll', this.handleScroll);
  }
  
  componentWillUnmount() {
    this.containerRef.current.removeEventListener('scroll', this.handleScroll);
  }
  
  handleScroll = () => {
    const container = this.containerRef.current;
    const scrollTop = container.scrollTop;
    const itemHeight = 50;
    const visibleCount = Math.ceil(container.clientHeight / itemHeight);
    
    const start = Math.floor(scrollTop / itemHeight);
    const end = start + visibleCount;
    
    this.setState({
      visibleStart: start,
      visibleEnd: end
    });
  };
  
  render() {
    const { items, itemHeight = 50 } = this.props;
    const { visibleStart, visibleEnd } = this.state;
    
    const visibleItems = items.slice(visibleStart, visibleEnd);
    const totalHeight = items.length * itemHeight;
    const offsetY = visibleStart * itemHeight;
    
    return (
      <div
        ref={this.containerRef}
        style={{
          height: '500px',
          overflow: 'auto'
        }}
      >
        <div style={{ height: totalHeight, position: 'relative' }}>
          <div
            style={{
              transform: `translateY(${offsetY}px)`,
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0
            }}
          >
            {visibleItems.map((item, index) => (
              <div
                key={index}
                style={{
                  height: itemHeight,
                  boxSizing: 'border-box',
                  padding: '10px',
                  borderBottom: '1px solid #eee'
                }}
              >
                {item}
              </div>
            ))}
          </div>
        </div>
      </div>
    );
  }
}
```

---

### 7. 如何实现一个图片懒加载？

**答案：**

```javascript
// 使用 Intersection Observer API
class LazyImage extends React.Component {
  constructor(props) {
    super(props);
    this.imgRef = React.createRef();
    this.state = {
      loaded: false,
      inView: false
    };
  }
  
  componentDidMount() {
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            this.setState({ inView: true });
            this.observer.unobserve(entry.target);
          }
        });
      },
      {
        rootMargin: '100px' // 提前 100px 加载
      }
    );
    
    if (this.imgRef.current) {
      this.observer.observe(this.imgRef.current);
    }
  }
  
  componentWillUnmount() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
  
  render() {
    const { src, alt, placeholder } = this.props;
    const { loaded, inView } = this.state;
    
    return (
      <img
        ref={this.imgRef}
        src={inView && loaded ? src : placeholder}
        alt={alt}
        onLoad={() => this.setState({ loaded: true })}
        style={{
          opacity: loaded ? 1 : 0.5,
          transition: 'opacity 0.3s'
        }}
      />
    );
  }
}

// 使用
<LazyImage
  src="https://example.com/image.jpg"
  alt="图片"
  placeholder="https://example.com/placeholder.jpg"
/>
```

---

### 8. 如何实现一个防抖的搜索框？

**答案：**

```javascript
// 封装防抖函数
function debounce(func, delay) {
  let timer = null;
  
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// 使用
class SearchBox extends React.Component {
  state = {
    keyword: '',
    results: []
  };
  
  handleSearch = debounce((keyword) => {
    // 模拟 API 请求
    fetch(`/api/search?keyword=${keyword}`)
      .then(res => res.json())
      .then(data => {
        this.setState({ results: data });
      });
  }, 300);
  
  handleChange = (e) => {
    const keyword = e.target.value;
    this.setState({ keyword });
    this.handleSearch(keyword);
  };
  
  render() {
    return (
      <div>
        <input
          type="text"
          value={this.state.keyword}
          onChange={this.handleChange}
          placeholder="搜索..."
        />
        <ul>
          {this.state.results.map(item => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      </div>
    );
  }
}
```

---

## 场景题

### 9. 如何实现网页加载进度条？

**答案：**

网页加载进度条是提升用户体验的重要功能，可以让用户直观地了解页面加载进度。

**实现方案：**

**方案 1：基于 NProgress 库**
```javascript
import NProgress from 'nprogress';
import 'nprogress/nprogress.css';

// 在路由切换时显示进度条
router.beforeEach((to, from, next) => {
  NProgress.start();
  next();
});

router.afterEach(() => {
  NProgress.done();
});

// 在请求拦截器中显示进度条
axios.interceptors.request.use(config => {
  NProgress.start();
  return config;
});

axios.interceptors.response.use(response => {
  NProgress.done();
  return response;
});
```

**方案 2：基于 XMLHttpRequest 的进度监控**
```javascript
function uploadFileWithProgress(file) {
  const xhr = new XMLHttpRequest();
  const progressBar = document.getElementById('progress-bar');
  
  xhr.open('POST', '/api/upload');
  
  // 监听上传进度
  xhr.upload.onprogress = (e) => {
    if (e.lengthComputable) {
      const percentComplete = (e.loaded / e.total) * 100;
      progressBar.style.width = percentComplete + '%';
      progressBar.textContent = Math.round(percentComplete) + '%';
    }
  };
  
  xhr.onload = () => {
    progressBar.style.width = '100%';
    progressBar.textContent = '完成';
  };
  
  const formData = new FormData();
  formData.append('file', file);
  
  xhr.send(formData);
}

// 使用
uploadFileWithProgress(fileInput.files[0]);
```

**方案 3：基于 Resource Timing API 的页面加载进度**
```javascript
function trackPageLoadProgress() {
  const progressBar = document.getElementById('progress-bar');
  const progressText = document.getElementById('progress-text');
  
  // 监听资源加载
  const resources = performance.getEntriesByType('resource');
  const totalResources = resources.length;
  let loadedResources = 0;
  
  const observer = new PerformanceObserver((list) => {
    list.getEntries().forEach(entry => {
      if (entry.entryType === 'resource') {
        loadedResources++;
        const progress = (loadedResources / totalResources) * 100;
        progressBar.style.width = progress + '%';
        progressText.textContent = Math.round(progress) + '%';
        
        if (loadedResources === totalResources) {
          progressBar.style.width = '100%';
          progressText.textContent = '加载完成';
          setTimeout(() => {
            progressBar.style.opacity = '0';
          }, 500);
        }
      }
    });
  });
  
  observer.observe({ entryTypes: ['resource'] });
}

// 页面加载时启动
window.addEventListener('load', trackPageLoadProgress);
```

**方案 4：基于 Fetch API 的下载进度**
```javascript
async function downloadWithProgress(url) {
  const response = await fetch(url);
  const contentLength = response.headers.get('Content-Length');
  const total = parseInt(contentLength, 10);
  let loaded = 0;
  
  const reader = response.body.getReader();
  const progressBar = document.getElementById('progress-bar');
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    loaded += value.length;
    const progress = (loaded / total) * 100;
    
    progressBar.style.width = progress + '%';
  }
  
  progressBar.textContent = '下载完成';
}
```

**方案 5：自定义进度条组件**
```javascript
function ProgressBar({ progress, color = '#1890ff' }) {
  return (
    <div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      width: '100%',
      height: '3px',
      backgroundColor: '#f0f0f0',
      zIndex: 9999
    }}>
      <div style={{
        width: `${progress}%`,
        height: '100%',
        backgroundColor: color,
        transition: 'width 0.3s ease'
      }} />
    </div>
  );
}

// 使用
function App() {
  const [progress, setProgress] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setProgress(prev => {
        if (prev >= 100) {
          clearInterval(interval);
          return 100;
        }
        return prev + Math.random() * 10;
      });
    }, 100);
    
    return () => clearInterval(interval);
  }, []);
  
  return (
    <div>
      <ProgressBar progress={progress} />
      {/* 页面内容 */}
    </div>
  );
}
```

**优化技巧：**

1. **预加载关键资源**
```javascript
<link rel="preload" href="critical.css" as="style">
<link rel="preload" href="main.js" as="script">
```

2. **骨架屏替代进度条**
```javascript
function SkeletonScreen() {
  return (
    <div className="skeleton">
      <div className="skeleton-header" />
      <div className="skeleton-content" />
      <div className="skeleton-content" />
    </div>
  );
}
```

3. **分阶段显示进度**
```javascript
const stages = [
  { name: '加载样式', weight: 20 },
  { name: '加载脚本', weight: 30 },
  { name: '加载数据', weight: 50 }
];

function updateProgress(currentStage) {
  let progress = 0;
  for (let i = 0; i <= currentStage; i++) {
    progress += stages[i].weight;
  }
  progressBar.style.width = progress + '%';
}
```

---

### 10. 如何实现移动端上拉加载和下拉刷新？

**答案：**

移动端上拉加载和下拉刷新是提升用户体验的重要功能。

**下拉刷新实现：**

**方案 1：使用 Touch 事件**
```javascript
function PullToRefresh(container, onRefresh) {
  let startY = 0;
  let currentY = 0;
  let isDragging = false;
  const threshold = 60; // 触发刷新的阈值
  
  const indicator = document.createElement('div');
  indicator.className = 'pull-indicator';
  indicator.innerHTML = '<span>↓ 下拉刷新</span>';
  container.prepend(indicator);
  
  container.addEventListener('touchstart', (e) => {
    if (container.scrollTop === 0) {
      startY = e.touches[0].clientY;
      isDragging = true;
    }
  }, { passive: true });
  
  container.addEventListener('touchmove', (e) => {
    if (!isDragging) return;
    
    currentY = e.touches[0].clientY;
    const diff = currentY - startY;
    
    if (diff > 0 && container.scrollTop === 0) {
      indicator.style.transform = `translateY(${Math.min(diff, 100)}px)`;
      indicator.style.opacity = Math.min(diff / threshold, 1);
      
      if (diff >= threshold) {
        indicator.querySelector('span').textContent = '↑ 释放刷新';
      } else {
        indicator.querySelector('span').textContent = '↓ 下拉刷新';
      }
    }
  }, { passive: true });
  
  container.addEventListener('touchend', async () => {
    if (!isDragging) return;
    isDragging = false;
    
    const diff = currentY - startY;
    
    if (diff >= threshold) {
      indicator.querySelector('span').textContent = '刷新中...';
      indicator.classList.add('loading');
      
      await onRefresh();
      
      indicator.classList.remove('loading');
      indicator.style.transform = 'translateY(0)';
      indicator.style.opacity = '0';
    } else {
      indicator.style.transform = 'translateY(0)';
      indicator.style.opacity = '0';
    }
  });
}

// 使用
PullToRefresh(document.getElementById('list-container'), async () => {
  await fetchData();
});
```

**方案 2：使用 Intersection Observer**
```javascript
function InfiniteScroll(container, onLoadMore) {
  const sentinel = document.createElement('div');
  sentinel.className = 'scroll-sentinel';
  container.appendChild(sentinel);
  
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        onLoadMore();
      }
    });
  }, {
    rootMargin: '100px'
  });
  
  observer.observe(sentinel);
  
  return () => observer.disconnect();
}

// 使用
function List() {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [page, setPage] = useState(1);
  
  const loadMore = async () => {
    if (loading) return;
    
    setLoading(true);
    const newItems = await fetchItems(page + 1);
    setItems(prev => [...prev, ...newItems]);
    setPage(page + 1);
    setLoading(false);
  };
  
  useEffect(() => {
    const cleanup = InfiniteScroll(
      document.getElementById('list-container'),
      loadMore
    );
    return cleanup;
  }, []);
  
  return (
    <div id="list-container">
      {items.map(item => <div key={item.id}>{item.name}</div>)}
      {loading && <div>加载中...</div>}
    </div>
  );
}
```

**方案 3：使用 React Hook**
```javascript
import { useState, useEffect, useCallback } from 'react';

function usePullToRefresh(onRefresh) {
  const [isPulling, setIsPulling] = useState(false);
  const [pullDistance, setPullDistance] = useState(0);
  const startY = useRef(0);
  
  const handleTouchStart = useCallback((e) => {
    startY.current = e.touches[0].clientY;
  }, []);
  
  const handleTouchMove = useCallback((e) => {
    const currentY = e.touches[0].clientY;
    const distance = currentY - startY.current;
    
    if (distance > 0) {
      setPullDistance(Math.min(distance, 100));
      setIsPulling(distance >= 60);
    }
  }, []);
  
  const handleTouchEnd = useCallback(async () => {
    if (isPulling) {
      await onRefresh();
    }
    setPullDistance(0);
    setIsPulling(false);
  }, [isPulling, onRefresh]);
  
  return {
    pullDistance,
    isPulling,
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd
  };
}

// 使用
function RefreshList() {
  const [items, setItems] = useState([]);
  const [refreshing, setRefreshing] = useState(false);
  
  const handleRefresh = async () => {
    setRefreshing(true);
    const newItems = await fetchItems();
    setItems(newItems);
    setRefreshing(false);
  };
  
  const {
    pullDistance,
    isPulling,
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd
  } = usePullToRefresh(handleRefresh);
  
  return (
    <div
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
      style={{ position: 'relative', minHeight: '100vh' }}
    >
      {/* 下拉指示器 */}
      <div
        style={{
          position: 'absolute',
          top: `${-50 + pullDistance}px`,
          left: 0,
          right: 0,
          height: '50px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: '#f0f0f0',
          opacity: pullDistance / 100
        }}
      >
        {isPulling ? '↑ 释放刷新' : '↓ 下拉刷新'}
      </div>
      
      {/* 列表内容 */}
      <div>
        {refreshing ? '刷新中...' : items.map(item => (
          <div key={item.id}>{item.name}</div>
        ))}
      </div>
    </div>
  );
}
```

**方案 4：使用第三方库**
```javascript
import { PullToRefresh } from 'react-simple-pull-to-refresh';

function App() {
  const [items, setItems] = useState([]);
  
  const onRefresh = async () => {
    const newItems = await fetchItems();
    setItems(newItems);
  };
  
  return (
    <PullToRefresh onRefresh={onRefresh}>
      {items.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </PullToRefresh>
  );
}
```

**优化技巧：**

1. **防抖处理**
```javascript
const debouncedLoadMore = debounce(loadMore, 300);
```

2. **节流处理**
```javascript
const throttledHandleScroll = throttle(handleScroll, 100);
```

3. **虚拟滚动优化**
```javascript
import { FixedSizeList } from 'react-window';

function VirtualList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>{items[index].name}</div>
  );
  
  return (
    <FixedSizeList
      height={400}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

4. **预加载下一页数据**
```javascript
const [nextPage, setNextPage] = useState(null);

useEffect(() => {
  if (items.length > 0 && !nextPage) {
    prefetchNextPage(page + 1);
  }
}, [items.length, page, nextPage]);
```

---

### 11. 如何实现扫码登录？

**答案：**

扫码登录是现代应用常用的登录方式，提供了更好的用户体验。

**实现流程：**

**方案 1：基于 WebSocket 的实时通信**
```javascript
// 前端生成二维码
function generateQRCode() {
  const sessionId = generateSessionId();
  const qrCodeUrl = `https://api.example.com/qr-login?session=${sessionId}`;
  
  // 生成二维码图片
  const qrCode = generateQRCodeImage(qrCodeUrl);
  
  // 建立 WebSocket 连接
  const ws = new WebSocket(`wss://api.example.com/ws/login?session=${sessionId}`);
  
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    switch (data.type) {
      case 'scanned':
        showScannedStatus();
        break;
      case 'confirmed':
        handleLoginSuccess(data.token);
        break;
      case 'expired':
        showExpiredStatus();
        break;
    }
  };
  
  return { qrCode, ws };
}

// 后端实现
// 1. 生成二维码时创建 session
app.get('/qr-login', (req, res) => {
  const sessionId = generateSessionId();
  const qrCodeUrl = `https://api.example.com/qr-login?session=${sessionId}`;
  
  // 生成二维码图片
  const qrCode = generateQRCodeImage(qrCodeUrl);
  
  // 存储 session 信息
  sessions.set(sessionId, {
    status: 'waiting',
    createdAt: Date.now()
  });
  
  res.json({ qrCode, sessionId });
});

// 2. 扫码确认
app.post('/qr-login/scan', (req, res) => {
  const { sessionId, userId } = req.body;
  
  const session = sessions.get(sessionId);
  if (session && session.status === 'waiting') {
    session.status = 'scanned';
    session.userId = userId;
    
    // 通知前端
    notifyClient(sessionId, { type: 'scanned' });
    
    res.json({ success: true });
  }
});

// 3. 确认登录
app.post('/qr-login/confirm', (req, res) => {
  const { sessionId } = req.body;
  
  const session = sessions.get(sessionId);
  if (session && session.status === 'scanned') {
    // 生成 token
    const token = generateToken(session.userId);
    
    session.status = 'confirmed';
    session.token = token;
    
    // 通知前端
    notifyClient(sessionId, { type: 'confirmed', token });
    
    res.json({ success: true, token });
  }
});
```

**方案 2：基于轮询的简单实现**
```javascript
function QRCodeLogin() {
  const [sessionId, setSessionId] = useState('');
  const [status, setStatus] = useState('waiting');
  const [token, setToken] = useState('');
  
  // 生成二维码
  useEffect(() => {
    const id = generateSessionId();
    setSessionId(id);
    generateQRCode(id);
    
    // 轮询检查登录状态
    const interval = setInterval(async () => {
      try {
        const response = await fetch(`/api/qr-login/status?session=${id}`);
        const data = await response.json();
        
        setStatus(data.status);
        
        if (data.status === 'confirmed') {
          setToken(data.token);
          clearInterval(interval);
        }
      } catch (error) {
        console.error('检查登录状态失败:', error);
      }
    }, 2000);
    
    return () => clearInterval(interval);
  }, []);
  
  return (
    <div>
      <div id="qrcode"></div>
      {status === 'waiting' && <p>请使用手机扫码登录</p>}
      {status === 'scanned' && <p>已扫码，请在手机上确认</p>}
      {status === 'confirmed' && <p>登录成功！</p>}
    </div>
  );
}
```

**方案 3：移动端扫码确认**
```javascript
// 移动端扫码后显示确认页面
function ScanConfirm({ sessionId, userId }) {
  const [confirmed, setConfirmed] = useState(false);
  
  const handleConfirm = async () => {
    try {
      const response = await fetch('/api/qr-login/confirm', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sessionId, userId })
      });
      
      const data = await response.json();
      
      if (data.success) {
        setConfirmed(true);
        setTimeout(() => {
          window.close();
        }, 1000);
      }
    } catch (error) {
      console.error('确认失败:', error);
    }
  };
  
  return (
    <div>
      {confirmed ? (
        <div>确认成功，页面将自动关闭</div>
      ) : (
        <div>
          <h2>确认登录</h2>
          <p>您正在登录到：<strong>应用名称</strong></p>
          <button onClick={handleConfirm}>确认登录</button>
        </div>
      )}
    </div>
  );
}
```

**安全措施：**

1. **Session 过期**
```javascript
// 定期清理过期 session
setInterval(() => {
  const now = Date.now();
  const expiredSessions = [];
  
  sessions.forEach((session, sessionId) => {
    if (now - session.createdAt > 5 * 60 * 1000) { // 5分钟过期
      expiredSessions.push(sessionId);
    }
  });
  
  expiredSessions.forEach(sessionId => {
    sessions.delete(sessionId);
    notifyClient(sessionId, { type: 'expired' });
  });
}, 60000);
```

2. **一次性使用**
```javascript
app.post('/qr-login/confirm', (req, res) => {
  const { sessionId } = req.body;
  
  const session = sessions.get(sessionId);
  if (session && session.status === 'scanned') {
    // 检查是否已使用
    if (session.used) {
      return res.status(400).json({ error: '二维码已使用' });
    }
    
    // 标记为已使用
    session.used = true;
    
    // 生成 token
    const token = generateToken(session.userId);
    
    // ... 其他逻辑
  }
});
```

3. **防重放攻击**
```javascript
// 使用 nonce 防止重放
app.post('/qr-login/confirm', (req, res) => {
  const { sessionId, nonce, signature } = req.body;
  
  // 验证签名
  const expectedSignature = generateSignature(sessionId, nonce);
  if (signature !== expectedSignature) {
    return res.status(403).json({ error: '签名验证失败' });
  }
  
  // 检查 nonce 是否已使用
  if (usedNonces.has(nonce)) {
    return res.status(400).json({ error: '请求已处理' });
  }
  
  usedNonces.add(nonce);
  
  // ... 其他逻辑
});
```

**优化技巧：**

1. **二维码美化**
```javascript
function generateStyledQRCode(url) {
  const qr = new QRCode({
    text: url,
    width: 200,
    height: 200,
    colorDark: '#000000',
    colorLight: '#ffffff',
    correctLevel: QRCode.CorrectLevel.H
  });
  
  return qr;
}
```

2. **本地存储 token**
```javascript
function saveToken(token) {
  localStorage.setItem('auth_token', token);
  sessionStorage.setItem('auth_token', token);
}

function getToken() {
  return localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');
}
```

3. **自动刷新 token**
```javascript
function setupTokenRefresh() {
  const token = getToken();
  const decoded = decodeJWT(token);
  const expiresIn = decoded.exp - Date.now() / 1000;
  
  // 在过期前 5 分钟刷新
  setTimeout(async () => {
    const newToken = await refreshToken();
    saveToken(newToken);
    setupTokenRefresh();
  }, (expiresIn - 300) * 1000);
}
```

---

## 总结

腾讯面试题重点掌握：

### 前端基础
1. **性能优化**：加载、运行、渲染优化
2. **监控系统**：错误监控、性能监控
3. **路由系统**：Hash路由、History路由、动态路由
4. **虚拟滚动**：大数据量列表优化
5. **图片懒加载**：Intersection Observer API
6. **防抖节流**：性能优化、用户体验

### 算法题
1. **LRU 缓存**：使用 Map 实现 O(1) 时间复杂度
2. **防抖函数**：支持立即执行、取消、立即执行

### 场景题
1. **实际应用**：将算法应用到实际场景
2. **扩展性**：考虑边界情况和优化
3. **代码质量**：清晰、可维护、可测试
4. **用户体验**：进度条、下拉刷新、扫码登录
5. **性能优化**：资源加载、交互优化
6. **安全考虑**：防重放、防过期、一次性使用

**面试准备建议：**
1. 深入理解原理，不要只背答案
2. 多写代码，注重代码质量
3. 关注最新技术趋势
4. 准备项目经验，能讲清楚技术选型和难点
5. 保持学习热情和解决问题的能力

**答案：**

```javascript
// Hash 路由实现
class HashRouter {
  constructor() {
    this.routes = {};
    this.currentUrl = '';
    this.init();
  }
  
  init() {
    // 监听 hash 变化
    window.addEventListener('hashchange', this.handleHashChange.bind(this));
    window.addEventListener('load', this.handleHashChange.bind(this));
  }
  
  // 注册路由
  register(path, handler) {
    this.routes[path] = handler;
  }
  
  // 处理 hash 变化
  handleHashChange() {
    const hash = window.location.hash.slice(1) || '/';
    this.currentUrl = hash;
    this.matchRoute(hash);
  }
  
  // 路由匹配
  matchRoute(path) {
    // 精确匹配
    if (this.routes[path]) {
      this.routes[path]();
      return;
    }
    
    // 动态路由匹配
    for (const route in this.routes) {
      const params = this.matchDynamicRoute(route, path);
      if (params) {
        this.routes[route](params);
        return;
      }
    }
    
    // 404 处理
    if (this.routes['*']) {
      this.routes['*']();
    }
  }
  
  // 动态路由匹配
  matchDynamicRoute(route, path) {
    const routeParts = route.split('/');
    const pathParts = path.split('/');
    
    if (routeParts.length !== pathParts.length) {
      return null;
    }
    
    const params = {};
    
    for (let i = 0; i < routeParts.length; i++) {
      const routePart = routeParts[i];
      const pathPart = pathParts[i];
      
      if (routePart.startsWith(':')) {
        params[routePart.slice(1)] = pathPart;
      } else if (routePart !== pathPart) {
        return null;
      }
    }
    
    return params;
  }
  
  // 导航
  navigate(path) {
    window.location.hash = path;
  }
  
  // 替换
  replace(path) {
    window.location.replace(`#${path}`);
  }
  
  // 后退
  back() {
    window.history.back();
  }
  
  // 前进
  forward() {
    window.history.forward();
  }
}

// 使用
const router = new HashRouter();

router.register('/', () => {
  console.log('首页');
  renderHome();
});

router.register('/about', () => {
  console.log('关于');
  renderAbout();
});

router.register('/user/:id', (params) => {
  console.log('用户详情:', params.id);
  renderUserDetail(params.id);
});

router.register('*', () => {
  console.log('404');
  render404();
});

// History 路由实现
class HistoryRouter {
  constructor() {
    this.routes = {};
    this.init();
  }
  
  init() {
    // 监听 popstate 事件
    window.addEventListener('popstate', this.handlePopState.bind(this));
    window.addEventListener('load', this.handleLoad.bind(this));
  }
  
  register(path, handler) {
    this.routes[path] = handler;
  }
  
  handlePopState(event) {
    const path = window.location.pathname;
    this.matchRoute(path);
  }
  
  handleLoad() {
    const path = window.location.pathname;
    this.matchRoute(path);
  }
  
  matchRoute(path) {
    // 精确匹配
    if (this.routes[path]) {
      this.routes[path]();
      return;
    }
    
    // 动态路由匹配
    for (const route in this.routes) {
      const params = this.matchDynamicRoute(route, path);
      if (params) {
        this.routes[route](params);
        return;
      }
    }
    
    // 404 处理
    if (this.routes['*']) {
      this.routes['*']();
    }
  }
  
  matchDynamicRoute(route, path) {
    // 同 HashRouter 的实现
    const routeParts = route.split('/');
    const pathParts = path.split('/');
    
    if (routeParts.length !== pathParts.length) {
      return null;
    }
    
    const params = {};
    
    for (let i = 0; i < routeParts.length; i++) {
      const routePart = routeParts[i];
      const pathPart = pathParts[i];
      
      if (routePart.startsWith(':')) {
        params[routePart.slice(1)] = pathPart;
      } else if (routePart !== pathPart) {
        return null;
      }
    }
    
    return params;
  }
  
  navigate(path) {
    window.history.pushState({}, '', path);
    this.matchRoute(path);
  }
  
  replace(path) {
    window.history.replaceState({}, '', path);
    this.matchRoute(path);
  }
  
  back() {
    window.history.back();
  }
  
  forward() {
    window.history.forward();
  }
  
  // 需要服务器配置支持
  // 例如：所有路径都返回 index.html
}

// React Router 简化实现
function BrowserRouter({ children }) {
  const [location, setLocation] = useState(window.location.pathname);
  
  useEffect(() => {
    const handlePopState = () => {
      setLocation(window.location.pathname);
    };
    
    window.addEventListener('popstate', handlePopState);
    
    return () => {
      window.removeEventListener('popstate', handlePopState);
    };
  }, []);
  
  const navigate = (path) => {
    window.history.pushState({}, '', path);
    setLocation(path);
  };
  
  const routerContext = {
    location,
    navigate,
  };
  
  return (
    <RouterContext.Provider value={routerContext}>
      {children}
    </RouterContext.Provider>
  );
}

function Route({ path, component: Component }) {
  const { location } = useContext(RouterContext);
  
  const params = matchPath(path, location);
  
  if (params) {
    return <Component params={params} />;
  }
  
  return null;
}

function matchPath(routePath, currentPath) {
  const routeParts = routePath.split('/');
  const pathParts = currentPath.split('/');
  
  if (routeParts.length !== pathParts.length) {
    return null;
  }
  
  const params = {};
  
  for (let i = 0; i < routeParts.length; i++) {
    const routePart = routeParts[i];
    const pathPart = pathParts[i];
    
    if (routePart.startsWith(':')) {
      params[routePart.slice(1)] = pathPart;
    } else if (routePart !== pathPart) {
      return null;
    }
  }
  
  return params;
}

// 使用
function App() {
  return (
    <BrowserRouter>
      <Route path="/" component={Home} />
      <Route path="/about" component={About} />
      <Route path="/user/:id" component={UserDetail} />
    </BrowserRouter>
  );
}
```

---

## 总结

腾讯面试题重点掌握：

### 前端基础
1. **性能优化**：加载、运行、渲染优化
2. **监控系统**：错误监控、性能监控
3. **路由系统**：Hash路由、History路由、动态路由

### 算法题
1. **LRU 缓存**：使用 Map 实现 O(1) 时间复杂度
2. **防抖函数**：支持立即执行、取消、立即执行

### 场景题
1. **实际应用**：将算法应用到实际场景
2. **扩展性**：考虑边界情况和优化
3. **代码质量**：清晰、可维护、可测试

**面试准备建议：**
1. 深入理解原理，不要只背答案
2. 多写代码，注重代码质量
3. 关注最新技术趋势
4. 准备项目经验，能讲清楚技术选型和难点
5. 保持学习热情和解决问题的能力