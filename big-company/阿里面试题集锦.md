# 阿里面试题集锦（截止 2025 年底）

## 目录
1. [前端基础](#前端基础)
2. [算法题](#算法题)
3. [场景题](#场景题)

---

## 前端基础

### 1. 请简述 JavaScript 的事件循环机制

**答案：**

**事件循环（Event Loop）是 JavaScript 实现异步非阻塞 I/O 的机制。**

**执行顺序：**

```
1. 执行同步代码
2. 执行微任务队列
3. 执行宏任务队列
4. 重复 2-3
```

**示例：**

```javascript
console.log('1'); // 同步

setTimeout(() => console.log('2'), 0); // 宏任务

Promise.resolve().then(() => console.log('3')); // 微任务

console.log('4'); // 同步

// 输出：1 4 3 2
```

**宏任务：**
- setTimeout
- setInterval
- I/O
- UI 渲染

**微任务：**
- Promise.then
- queueMicrotask
- MutationObserver

**阿里特色考点：**
- 阿里高频考察事件循环的执行顺序
- 结合实际业务场景分析异步代码执行流程
- 考察对微任务与宏任务的理解深度

---

### 2. 请简述 Vue 2 与 Vue 3 响应式系统的差异

**答案：**

**Vue 2：Object.defineProperty**

```javascript
// Vue 2 响应式原理
function defineReactive(obj, key, val) {
  const dep = new Dep();
  
  Object.defineProperty(obj, key, {
    get() {
      dep.depend();
      return val;
    },
    set(newVal) {
      if (newVal !== val) {
        val = newVal;
        dep.notify();
      }
    }
  });
}
```

**Vue 3：Proxy**

```javascript
// Vue 3 响应式原理
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key);
      return target[key];
    },
    set(target, key, value) {
      target[key] = value;
      trigger(target, key);
      return true;
    }
  });
}
```

**差异对比：**

| 特性 | Vue 2 | Vue 3 |
|------|-------|-------|
| 实现方式 | Object.defineProperty | Proxy |
| 数组监听 | 需要特殊处理 | 原生支持 |
| 新增属性 | 无法监听 | 可以监听 |
| 删除属性 | 无法监听 | 可以监听 |
| 性能 | 较差 | 更好 |
| 兼容性 | IE9+ | IE11+ |

**阿里特色考点：**
- 阿里高频考察 Proxy 的使用场景和优势
- 结合实际项目说明响应式系统的性能优化
- 考察对 Vue 3 Composition API 的理解

---

### 3. 请简述虚拟 DOM 和 Diff 算法原理

**答案：**

**虚拟 DOM 是 React/Vue 在内存中维护的轻量级 JavaScript 对象树。**

**Diff 算法核心策略：**

1. **同层比较**：只比较同一层级的节点
2. **类型不同**：直接替换整个子树
3. **key 的作用**：通过 key 识别节点，提高 Diff 效率

**简化版 Diff 算法：**

```javascript
function diff(oldNode, newNode) {
  // 1. 节点类型不同，直接替换
  if (oldNode.type !== newNode.type) {
    return newNode;
  }
  
  // 2. 属性比较
  const props = diffProps(oldNode.props, newNode.props);
  
  // 3. 子节点比较
  const children = diffChildren(oldNode.children, newNode.children);
  
  return { ...newNode, props, children };
}

function diffChildren(oldChildren, newChildren) {
  const patches = [];
  
  // 使用 key 进行节点匹配
  oldChildren.forEach((oldChild, i) => {
    const newChild = newChildren.find(
      child => child.key === oldChild.key
    );
    
    if (newChild) {
      const patch = diff(oldChild, newChild);
      patches.push(patch);
    } else {
      patches.push({ type: 'REMOVE' });
    }
  });
  
  // 添加新节点
  newChildren.forEach((newChild, i) => {
    if (!oldChildren.find(child => child.key === newChild.key)) {
      patches.push({ type: 'ADD', node: newChild });
    }
  });
  
  return patches;
}
```

**阿里特色考点：**
- 阿里高频考察 Diff 算法的时间复杂度优化
- 结合实际项目说明虚拟 DOM 的性能优势
- 考察对 React Fiber 调度机制的理解

---

### 4. 请简述前端性能优化全链路方案

**答案：**

**性能优化核心思路：**

1. **加载性能优化**（减少首屏时间）
2. **运行性能优化**（减少卡顿、提高响应速度）
3. **渲染性能优化**（提高 FPS、减少重排重绘）

**具体优化手段：**

```javascript
// 1. 资源加载优化

// 代码分割（Webpack）
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },
  },
};

// 动态导入
const Home = lazy(() => import('./Home'));
const About = lazy(() => import('./About'));

// 预加载关键资源
<link rel="preload" href="critical.css" as="style">
<link rel="prefetch" href="next-page.js">

// 2. 运行性能优化

// 防抖和节流
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

function throttle(fn, interval) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= interval) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

// 3. 渲染性能优化

// 使用 CSS3 动画替代 JS 动画
.element {
  transition: transform 0.3s;
  will-change: transform;
}

// 批量 DOM 操作
const fragment = document.createDocumentFragment();
items.forEach(item => {
  const node = document.createElement('div');
  node.textContent = item.text;
  fragment.appendChild(node);
});
document.body.appendChild(fragment);

// 4. 网络优化

// HTTP 缓存
// 强制缓存
Cache-Control: max-age=31536000

// 协商缓存
ETag: "abc123"
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT"

// 5. 图片优化

// 图片懒加载
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy">

// 响应式图片
<picture>
  <source srcset="image-small.jpg" media="(max-width: 600px)">
  <source srcset="image-medium.jpg" media="(max-width: 1200px)">
  <img src="image-large.jpg">
</picture>
```

**阿里特色考点：**
- 阿里高频考察性能优化的全链路思维
- 结合阿里业务场景（如电商大促）说明优化方案
- 考察对性能监控工具的使用经验

---

### 5. 请简述三栏布局的实现方案

**答案：**

**三栏布局：左右固定，中间自适应**

**方案一：Flex 布局**

```css
.container {
  display: flex;
  height: 100vh;
}

.left {
  width: 200px;
  flex-shrink: 0;
}

.right {
  width: 200px;
  flex-shrink: 0;
}

.center {
  flex: 1;
  overflow: auto;
}
```

**方案二：Grid 布局**

```css
.container {
  display: grid;
  grid-template-columns: 200px 1fr 200px;
  height: 100vh;
}
```

**方案三：浮动布局**

```css
.container {
  height: 100vh;
}

.left {
  float: left;
  width: 200px;
}

.right {
  float: right;
  width: 200px;
}

.center {
  margin: 0 200px;
  height: 100%;
}
```

**方案四：绝对定位**

```css
.container {
  position: relative;
  height: 100vh;
}

.left {
  position: absolute;
  left: 0;
  width: 200px;
  height: 100%;
}

.right {
  position: absolute;
  right: 0;
  width: 200px;
  height: 100%;
}

.center {
  position: absolute;
  left: 200px;
  right: 200px;
  height: 100%;
}
```

**阿里特色考点：**
- 阿里高频考察 Flex 和 Grid 的使用场景
- 结合实际项目说明布局方案的选择依据
- 考察对 BFC（块级格式化上下文）的理解

---

### 6. 请简述 HTTP 缓存机制

**答案：**

**HTTP 缓存分类：**

**1. 强缓存（Cache-Control）**

```http
# 强制缓存 1 小时
Cache-Control: max-age=3600

# 强制缓存 1 天
Cache-Control: max-age=86400

# 不使用缓存
Cache-Control: no-cache
```

**2. 协商缓存（ETag、Last-Modified）**

```http
# ETag
ETag: "abc123"
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT

# 客户端请求
If-None-Match: "abc123"
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT

# 服务器响应
304 Not Modified
```

**3. 缓存策略对比**

| 策略 | 优点 | 缺点 |
|------|------|------|
| 强缓存 | 减少服务器请求，提高性能 | 更新不及时 |
| 协商缓存 | 数据实时更新 | 每次都需要请求服务器 |

**最佳实践：**

```http
# 静态资源：强缓存 + 协商缓存
# HTML 文件：短缓存
Cache-Control: max-age=0, must-revalidate

# CSS/JS/图片：长缓存 + 文件名哈希
Cache-Control: max-age=31536000, immutable

# API 响应：协商缓存
ETag: "abc123"
Cache-Control: max-age=0, must-revalidate
```

**阿里特色考点：**
- 阿里高频考察缓存策略的设计和选择
- 结合阿里业务（如电商商品详情页）说明缓存方案
- 考察对 CDN 缓存的理解和使用经验

---

## 算法题

### 7. 实现一个深拷贝函数

**答案：**

```javascript
function deepClone(obj, map = new WeakMap()) {
  // 处理基本类型和 null/undefined
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理 Date
  if (obj instanceof Date) {
    return new Date(obj);
  }
  
  // 处理 RegExp
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  
  // 处理 Map
  if (obj instanceof Map) {
    const cloned = new Map();
    obj.forEach((value, key) => {
      cloned.set(deepClone(key, map), deepClone(value, map));
    });
    return cloned;
  }
  
  // 处理 Set
  if (obj instanceof Set) {
    const cloned = new Set();
    obj.forEach(value => {
      cloned.add(deepClone(value, map));
    });
    return cloned;
  }
  
  // 处理循环引用
  if (map.has(obj)) {
    return map.get(obj);
  }
  
  map.set(obj, true);
  
  // 处理数组和对象
  const clone = Array.isArray(obj) ? [] : {};
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key], map);
    }
  }
  
  return clone;
}

// 测试
const obj = {
  a: 1,
  b: { c: 2 },
  d: [3, 4, { e: 5 }]
};
obj.self = obj; // 循环引用

const cloned = deepClone(obj);
console.log(cloned); // { a: 1, b: { c: 2 }, d: [3, 4, { e: 5 }], self: [Circular] }
```

**阿里特色考点：**
- 阿里高频考察深拷贝的实现细节
- 特别关注循环引用的处理
- 考察对 WeakMap 的理解和使用

---

### 8. 实现一个 LRU 缓存

**答案：**

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    // 删除并重新插入，更新访问顺序
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    
    return value;
  }
  
  put(key, value) {
    // 如果已存在，先删除
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    
    // 如果超过容量，删除最久未使用的
    if (this.cache.size >= this.capacity) {
      const oldest = this.cache.keys().next().value;
      this.cache.delete(oldest);
    }
    
    this.cache.set(key, value);
  }
}

// 测试
const cache = new LRUCache(3);

cache.put('a', 1);
cache.put('b', 2);
cache.put('c', 3);
console.log(cache.get('a')); // 1

cache.put('d', 4); // b 被淘汰
console.log(cache.get('b')); // -1

console.log(cache.get('c')); // 3
console.log(cache.get('a')); // 1
```

**阿里特色考点：**
- 阿里高频考察 LRU 缓存的应用场景
- 结合 Vue keep-alive 组件说明使用场景
- 考察对 Map 数据结构的熟练使用

---

### 9. 实现一个函数防抖

**答案：**

```javascript
function debounce(fn, delay = 300) {
  let timer = null;
  
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 使用
const searchInput = debounce((keyword) => {
  console.log('搜索:', keyword);
  fetch(`/api/search?keyword=${keyword}`)
    .then(res => res.json())
    .then(data => console.log(data));
}, 500);

// 搜索框输入
const input = document.querySelector('input');
input.addEventListener('input', (e) => {
  searchInput(e.target.value);
});
```

**阿里特色考点：**
- 阿里高频考察防抖节流的应用场景
- 结合搜索框、滚动事件说明优化效果
- 考察对异步控制的理解

---

### 10. 实现一个 Promise.all

**答案：**

```javascript
Promise.myAll = function(promises) {
  const results = [];
  let count = 0;
  
  return new Promise((resolve, reject) => {
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(res => {
          results[index] = res;
          count++;
          
          if (count === promises.length) {
            resolve(results);
          }
        })
        .catch(reject);
    });
  });
};

// 测试
Promise.myAll([
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.resolve(3)
]).then(results => {
  console.log(results); // [1, 2, 3]
});
```

**阿里特色考点：**
- 阿里高频考察 Promise 的实现原理
- 结合异步编程场景说明使用方法
- 考察对 Promise.allSettled、Promise.race 的理解

---

## 场景题

### 11. 如何实现一个虚拟滚动列表？

**答案：**

```javascript
class VirtualList {
  constructor(container, items, itemHeight = 50) {
    this.container = container;
    this.items = items;
    this.itemHeight = itemHeight;
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight);
    this.renderChunk(0);
    
    container.addEventListener('scroll', () => {
      const start = Math.floor(container.scrollTop / itemHeight);
      this.renderChunk(start);
    });
  }
  
  renderChunk(start) {
    const end = start + this.visibleCount;
    const fragment = document.createDocumentFragment();
    
    this.items.slice(start, end).forEach((item, i) => {
      const node = this.renderItem(item);
      node.style.position = 'absolute';
      node.style.top = `${(start + i) * this.itemHeight}px`;
      node.style.height = `${this.itemHeight}px`;
      fragment.appendChild(node);
    });
    
    this.container.innerHTML = '';
    this.container.appendChild(fragment);
  }
  
  renderItem(item) {
    const div = document.createElement('div');
    div.textContent = item.text;
    return div;
  }
}

// 使用
const container = document.getElementById('container');
const items = Array.from({ length: 10000 }, (_, i) => ({
  id: i,
  text: `Item ${i}`
}));

new VirtualList(container, items);
```

**阿里特色考点：**
- 阿里高频考察虚拟滚动的实现原理
- 结合电商商品列表说明优化效果
- 考察对大数据量渲染性能优化的理解

---

### 12. 如何实现一个图片懒加载？

**答案：**

```javascript
class LazyImage {
  constructor(options = {}) {
    this.options = {
      rootMargin: '100px',
      threshold: 0.1,
      ...options
    };
    
    this.observer = new IntersectionObserver(
      this.handleIntersect.bind(this),
      this.options
    );
  }
  
  observe(element) {
    this.observer.observe(element);
  }
  
  handleIntersect(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        const src = img.dataset.src;
        
        if (src) {
          img.src = src;
          img.onload = () => {
            img.classList.add('loaded');
          };
          img.onerror = () => {
            img.classList.add('error');
          };
        }
        
        this.observer.unobserve(img);
      }
    });
  }
}

// 使用
const lazyImage = new LazyImage({
  rootMargin: '100px',
  threshold: 0.1
});

document.querySelectorAll('img[data-src]').forEach(img => {
  lazyImage.observe(img);
});
```

**阿里特色考点：**
- 阿里高频考察图片懒加载的实现原理
- 结合电商图片展示说明优化效果
- 考察对 IntersectionObserver API 的熟练使用

---

### 13. 如何实现一个发布订阅模式？

**答案：**

```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  // 订阅事件
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
  }
  
  // 发布事件
  emit(event, ...args) {
    if (!this.events[event]) {
      return;
    }
    this.events[event].forEach(listener => {
      listener(...args);
    });
  }
  
  // 取消订阅
  off(event, listener) {
    if (!this.events[event]) {
      return;
    }
    this.events[event] = this.events[event].filter(fn => fn !== listener);
  }
  
  // 只订阅一次
  once(event, listener) {
    const onceListener = (...args) => {
      listener(...args);
      this.off(event, onceListener);
    };
    this.on(event, onceListener);
  }
}

// 使用
const eventBus = new EventEmitter();

// 订阅
eventBus.on('data', (data) => {
  console.log('收到数据:', data);
});

// 发布
eventBus.emit('data', { id: 1, name: 'test' });

// 取消订阅
const handler = (data) => console.log('处理数据:', data);
eventBus.on('data', handler);
eventBus.off('data', handler);
```

**阿里特色考点：**
- 阿里高频考察发布订阅模式的应用场景
- 结合跨组件通信说明使用方法
- 考察对设计模式的理解和应用能力

---

### 14. 如何实现一个带并发限制的异步调度器？

**答案：**

```javascript
class AsyncScheduler {
  constructor(max = 6) {
    this.max = max;
    this.queue = [];
    this.running = 0;
  }
  
  add(task) {
    return new Promise((resolve, reject) => {
      const execute = () => {
        this.running++;
        task()
          .then(resolve)
          .catch(reject)
          .finally(() => {
            this.running--;
            this.next();
          });
      };
      
      this.queue.push(execute);
      this.next();
    });
  }
  
  next() {
    while (this.queue.length && this.running < this.max) {
      const execute = this.queue.shift();
      execute();
    }
  }
}

// 使用
const scheduler = new AsyncScheduler(6); // 最多6个并发

// 添加任务
for (let i = 0; i < 20; i++) {
  scheduler.add(() => {
    return fetch(`/api/data/${i}`)
      .then(res => res.json())
      .then(data => {
        console.log(`任务 ${i} 完成:`, data);
      });
  });
}
```

**阿里特色考点：**
- 阿里高频考察并发控制的实现原理
- 结合浏览器并发限制（Chrome 最多6个）说明必要性
- 考察对异步编程和性能优化的理解

---

### 15. 前端如何实现截图？

**答案：**

前端截图有多种实现方案，根据需求选择合适的方法。

**方案 1：使用 html2canvas**

```javascript
import html2canvas from 'html2canvas';

async function captureElement(element) {
  try {
    const canvas = await html2canvas(element, {
      useCORS: true, // 允许跨域图片
      scale: 2, // 提高清晰度
      backgroundColor: null, // 透明背景
      logging: false, // 关闭日志
      allowTaint: true, // 允许污染的 canvas
    });
    
    return canvas.toDataURL('image/png');
  } catch (error) {
    console.error('截图失败:', error);
    throw error;
  }
}

// 使用
const element = document.getElementById('capture-area');
const dataUrl = await captureElement(element);

// 下载图片
const link = document.createElement('a');
link.download = 'screenshot.png';
link.href = dataUrl;
link.click();
```

**方案 2：使用 Canvas 手动绘制**

```javascript
class CanvasCapture {
  constructor(options = {}) {
    this.options = {
      scale: 2,
      backgroundColor: '#ffffff',
      ...options
    };
  }
  
  async capture(element) {
    const rect = element.getBoundingClientRect();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // 设置 canvas 尺寸
    canvas.width = rect.width * this.options.scale;
    canvas.height = rect.height * this.options.scale;
    
    // 设置缩放
    ctx.scale(this.options.scale, this.options.scale);
    
    // 填充背景
    if (this.options.backgroundColor) {
      ctx.fillStyle = this.options.backgroundColor;
      ctx.fillRect(0, 0, rect.width, rect.height);
    }
    
    // 绘制元素
    await this.drawElement(ctx, element, 0, 0);
    
    return canvas.toDataURL('image/png');
  }
  
  async drawElement(ctx, element, x, y) {
    const rect = element.getBoundingClientRect();
    const computedStyle = window.getComputedStyle(element);
    
    // 绘制背景
    if (computedStyle.backgroundColor !== 'rgba(0, 0, 0, 0)') {
      ctx.fillStyle = computedStyle.backgroundColor;
      ctx.fillRect(x, y, rect.width, rect.height);
    }
    
    // 绘制边框
    if (computedStyle.borderWidth !== '0px') {
      ctx.strokeStyle = computedStyle.borderColor;
      ctx.lineWidth = parseFloat(computedStyle.borderWidth);
      ctx.strokeRect(x, y, rect.width, rect.height);
    }
    
    // 绘制文本
    if (element.childNodes) {
      for (const node of element.childNodes) {
        if (node.nodeType === Node.TEXT_NODE) {
          ctx.fillStyle = computedStyle.color;
          ctx.font = `${computedStyle.fontWeight} ${computedStyle.fontSize} ${computedStyle.fontFamily}`;
          ctx.fillText(node.textContent, x + parseFloat(computedStyle.paddingLeft), y + parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.fontSize));
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          await this.drawElement(ctx, node, x, y);
        }
      }
    }
  }
}

// 使用
const capture = new CanvasCapture({ scale: 2 });
const dataUrl = await capture.capture(document.getElementById('capture-area'));
```

**方案 3：使用 SVG foreignObject**

```javascript
async function captureWithSVG(element) {
  const rect = element.getBoundingClientRect();
  const data = new XMLSerializer().serializeToString(element);
  
  // 创建 SVG
  const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="${rect.width}" height="${rect.height}">
      <foreignObject width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml">
          ${data}
        </div>
      </foreignObject>
    </svg>
  `;
  
  // 转换为 canvas
  const img = new Image();
  img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
  
  return new Promise((resolve, reject) => {
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = rect.width;
      canvas.height = rect.height;
      
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      
      resolve(canvas.toDataURL('image/png'));
    };
    
    img.onerror = reject;
  });
}

// 使用
const dataUrl = await captureWithSVG(document.getElementById('capture-area'));
```

**方案 4：使用浏览器原生截图 API**

```javascript
async function captureWithNativeAPI() {
  try {
    // 获取所有窗口
    const sources = await navigator.mediaDevices.getDisplayMedia({
      video: {
        cursor: 'never',
      },
      audio: false,
    });
    
    // 创建 video 元素
    const video = document.createElement('video');
    video.srcObject = sources;
    video.play();
    
    // 等待视频加载
    await new Promise(resolve => {
      video.onloadedmetadata = resolve;
    });
    
    // 创建 canvas
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    // 绘制到 canvas
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    
    // 停止视频流
    sources.getTracks().forEach(track => track.stop());
    
    return canvas.toDataURL('image/png');
  } catch (error) {
    console.error('原生截图失败:', error);
    throw error;
  }
}

// 使用
const dataUrl = await captureWithNativeAPI();
```

**注意事项：**
1. **跨域问题**：使用 `useCORS: true` 和 `allowTaint: true`
2. **清晰度**：通过 `scale` 参数提高清晰度
3. **性能**：大元素截图可能较慢，建议使用 Web Worker
4. **兼容性**：html2canvas 兼容性最好，原生 API 兼容性较差

---

### 16. 当 QPS 达到峰值时，该如何处理？

**答案：**

QPS（Queries Per Second）峰值处理是高并发场景下的核心问题，需要从前端和后端两个层面进行优化。

**前端优化方案：**

**1. 请求合并和批量处理**

```javascript
class RequestBatcher {
  constructor(options = {}) {
    this.options = {
      maxBatchSize: 10,
      maxWaitTime: 100,
      ...options
    };
    
    this.queue = [];
    this.timer = null;
  }
  
  add(request) {
    return new Promise((resolve, reject) => {
      this.queue.push({ request, resolve, reject });
      
      if (this.queue.length >= this.options.maxBatchSize) {
        this.flush();
      } else if (!this.timer) {
        this.timer = setTimeout(() => this.flush(), this.options.maxWaitTime);
      }
    });
  }
  
  async flush() {
    clearTimeout(this.timer);
    this.timer = null;
    
    if (this.queue.length === 0) {
      return;
    }
    
    const batch = this.queue.splice(0);
    try {
      const responses = await this.executeBatch(batch.map(item => item.request));
      
      batch.forEach((item, index) => {
        item.resolve(responses[index]);
      });
    } catch (error) {
      batch.forEach(item => item.reject(error));
    }
  }
  
  async executeBatch(requests) {
    // 批量请求实现
    const response = await fetch('/api/batch', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ requests })
    });
    
    return response.json();
  }
}

// 使用
const batcher = new RequestBatcher({
  maxBatchSize: 10,
  maxWaitTime: 100
});

// 添加请求
const result1 = await batcher.add({ url: '/api/user/1' });
const result2 = await batcher.add({ url: '/api/user/2' });
const result3 = await batcher.add({ url: '/api/user/3' });
```

**2. 请求缓存和去重**

```javascript
class RequestCache {
  constructor(options = {}) {
    this.options = {
      ttl: 60000, // 缓存时间
      ...options
    };
    
    this.cache = new Map();
    this.pending = new Map();
  }
  
  async request(key, fn) {
    // 检查缓存
    if (this.cache.has(key)) {
      const cached = this.cache.get(key);
      if (Date.now() - cached.timestamp < this.options.ttl) {
        return cached.data;
      } else {
        this.cache.delete(key);
      }
    }
    
    // 检查是否有相同的请求正在进行
    if (this.pending.has(key)) {
      return this.pending.get(key);
    }
    
    // 发起新请求
    const promise = fn().then(data => {
      this.cache.set(key, {
        data,
        timestamp: Date.now()
      });
      this.pending.delete(key);
      return data;
    }).catch(error => {
      this.pending.delete(key);
      throw error;
    });
    
    this.pending.set(key, promise);
    return promise;
  }
  
  clear() {
    this.cache.clear();
    this.pending.clear();
  }
}

// 使用
const requestCache = new RequestCache();

async function getUser(id) {
  return requestCache.request(`user_${id}`, () => {
    return fetch(`/api/user/${id}`).then(res => res.json());
  });
}

// 多次调用相同请求，只会发起一次 HTTP 请求
const user1 = await getUser(1);
const user2 = await getUser(1); // 从缓存获取
```

**3. 请求限流和节流**

```javascript
class RateLimiter {
  constructor(options = {}) {
    this.options = {
      maxRequests: 60, // 最大请求数
      period: 60000, // 时间周期（毫秒）
      ...options
    };
    
    this.requests = [];
  }
  
  async request(fn) {
    // 清理过期请求
    const now = Date.now();
    this.requests = this.requests.filter(time => now - time < this.options.period);
    
    // 检查是否超过限制
    if (this.requests.length >= this.options.maxRequests) {
      const oldestRequest = this.requests[0];
      const waitTime = this.options.period - (now - oldestRequest);
      
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
    
    // 记录请求
    this.requests.push(now);
    
    // 执行请求
    return fn();
  }
}

// 使用
const rateLimiter = new RateLimiter({
  maxRequests: 60,
  period: 60000
});

async function fetchWithRateLimit(url) {
  return rateLimiter.request(() => {
    return fetch(url).then(res => res.json());
  });
}
```

**4. 优雅降级和熔断**

```javascript
class CircuitBreaker {
  constructor(options = {}) {
    this.options = {
      failureThreshold: 5, // 失败阈值
      resetTimeout: 30000, // 重置超时
      ...options
    };
    
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = 'closed'; // closed, open, half-open
  }
  
  async request(fn) {
    // 检查熔断器状态
    if (this.state === 'open') {
      const now = Date.now();
      if (now - this.lastFailureTime >= this.options.resetTimeout) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker is open');
      }
    }
    
    try {
      const result = await fn();
      
      // 请求成功，重置失败计数
      this.failureCount = 0;
      
      if (this.state === 'half-open') {
        this.state = 'closed';
      }
      
      return result;
    } catch (error) {
      this.failureCount++;
      this.lastFailureTime = Date.now();
      
      // 检查是否需要打开熔断器
      if (this.failureCount >= this.options.failureThreshold) {
        this.state = 'open';
      }
      
      throw error;
    }
  }
}

// 使用
const circuitBreaker = new CircuitBreaker({
  failureThreshold: 5,
  resetTimeout: 30000
});

async function fetchWithCircuitBreaker(url) {
  try {
    return await circuitBreaker.request(() => {
      return fetch(url).then(res => res.json());
    });
  } catch (error) {
    // 降级处理
    console.error('请求失败，使用降级数据:', error);
    return { fallback: true };
  }
}
```

**后端优化方案：**

1. **负载均衡**：使用 Nginx、HAProxy 等进行负载均衡
2. **缓存**：使用 Redis、Memcached 进行缓存
3. **限流**：使用令牌桶、漏桶算法进行限流
4. **降级**：在高峰期关闭非核心功能
5. **扩容**：动态增加服务器实例

**监控和告警：**

```javascript
class RequestMonitor {
  constructor() {
    this.metrics = {
      totalRequests: 0,
      successRequests: 0,
      failureRequests: 0,
      avgResponseTime: 0,
      qps: 0
    };
    
    this.startTime = Date.now();
    this.responseTimes = [];
  }
  
  recordRequest(success, responseTime) {
    this.metrics.totalRequests++;
    
    if (success) {
      this.metrics.successRequests++;
    } else {
      this.metrics.failureRequests++;
    }
    
    this.responseTimes.push(responseTime);
    
    // 计算平均响应时间
    this.metrics.avgResponseTime = this.responseTimes.reduce((a, b) => a + b, 0) / this.responseTimes.length;
    
    // 计算 QPS
    const elapsed = (Date.now() - this.startTime) / 1000;
    this.metrics.qps = this.metrics.totalRequests / elapsed;
  }
  
  getMetrics() {
    return { ...this.metrics };
  }
}

// 使用
const monitor = new RequestMonitor();

async function monitoredRequest(url) {
  const startTime = Date.now();
  let success = false;
  
  try {
    const response = await fetch(url);
    success = response.ok;
    return response.json();
  } catch (error) {
    success = false;
    throw error;
  } finally {
    const responseTime = Date.now() - startTime;
    monitor.recordRequest(success, responseTime);
    
    // 检查是否需要告警
    if (monitor.metrics.qps > 1000) {
      console.warn('QPS 过高:', monitor.metrics.qps);
    }
    
    if (monitor.metrics.avgResponseTime > 1000) {
      console.warn('平均响应时间过长:', monitor.metrics.avgResponseTime);
    }
  }
}
```

---

### 17. 如何解决页面请求接口大规模并发问题？

**答案：**

大规模并发问题是前端开发中的常见挑战，需要从多个层面进行优化。

**方案 1：使用请求队列和并发控制**

```javascript
class RequestQueue {
  constructor(options = {}) {
    this.options = {
      maxConcurrent: 6, // 最大并发数
      ...options
    };
    
    this.queue = [];
    this.running = 0;
  }
  
  add(request) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        request,
        resolve,
        reject
      });
      
      this.process();
    });
  }
  
  process() {
    while (this.queue.length > 0 && this.running < this.options.maxConcurrent) {
      const task = this.queue.shift();
      this.running++;
      
      task.request()
        .then(task.resolve)
        .catch(task.reject)
        .finally(() => {
          this.running--;
          this.process();
        });
    }
  }
}

// 使用
const requestQueue = new RequestQueue({ maxConcurrent: 6 });

// 添加大量请求
const requests = [];
for (let i = 0; i < 100; i++) {
  requests.push(
    requestQueue.add(() => fetch(`/api/data/${i}`).then(res => res.json()))
  );
}

// 等待所有请求完成
const results = await Promise.all(requests);
```

**方案 2：使用请求优先级**

```javascript
class PriorityRequestQueue {
  constructor(options = {}) {
    this.options = {
      maxConcurrent: 6,
      ...options
    };
    
    this.queues = {
      high: [],
      medium: [],
      low: []
    };
    
    this.running = 0;
  }
  
  add(request, priority = 'medium') {
    return new Promise((resolve, reject) => {
      this.queues[priority].push({
        request,
        resolve,
        reject
      });
      
      this.process();
    });
  }
  
  process() {
    while (this.running < this.options.maxConcurrent) {
      // 优先处理高优先级队列
      let task = this.queues.high.shift();
      
      if (!task) {
        task = this.queues.medium.shift();
      }
      
      if (!task) {
        task = this.queues.low.shift();
      }
      
      if (!task) {
        break;
      }
      
      this.running++;
      
      task.request()
        .then(task.resolve)
        .catch(task.reject)
        .finally(() => {
          this.running--;
          this.process();
        });
    }
  }
}

// 使用
const priorityQueue = new PriorityRequestQueue({ maxConcurrent: 6 });

// 添加不同优先级的请求
const highPriorityRequest = priorityQueue.add(
  () => fetch('/api/critical').then(res => res.json()),
  'high'
);

const mediumPriorityRequest = priorityQueue.add(
  () => fetch('/api/normal').then(res => res.json()),
  'medium'
);

const lowPriorityRequest = priorityQueue.add(
  () => fetch('/api/background').then(res => res.json()),
  'low'
);
```

**方案 3：使用请求分组和批量处理**

```javascript
class BatchRequestProcessor {
  constructor(options = {}) {
    this.options = {
      maxBatchSize: 10,
      maxWaitTime: 100,
      ...options
    };
    
    this.batches = new Map();
    this.timers = new Map();
  }
  
  add(key, request) {
    return new Promise((resolve, reject) => {
      if (!this.batches.has(key)) {
        this.batches.set(key, []);
      }
      
      this.batches.get(key).push({ request, resolve, reject });
      
      const batch = this.batches.get(key);
      
      if (batch.length >= this.options.maxBatchSize) {
        this.processBatch(key);
      } else if (!this.timers.has(key)) {
        this.timers.set(
          key,
          setTimeout(() => this.processBatch(key), this.options.maxWaitTime)
        );
      }
    });
  }
  
  async processBatch(key) {
    clearTimeout(this.timers.get(key));
    this.timers.delete(key);
    
    const batch = this.batches.get(key);
    if (!batch || batch.length === 0) {
      return;
    }
    
    this.batches.delete(key);
    
    try {
      const requests = batch.map(item => item.request);
      const responses = await this.executeBatch(requests);
      
      batch.forEach((item, index) => {
        item.resolve(responses[index]);
      });
    } catch (error) {
      batch.forEach(item => item.reject(error));
    }
  }
  
  async executeBatch(requests) {
    // 实现批量请求
    const response = await fetch('/api/batch', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ requests })
    });
    
    return response.json();
  }
}

// 使用
const batchProcessor = new BatchRequestProcessor({
  maxBatchSize: 10,
  maxWaitTime: 100
});

// 添加请求到同一批次
const results = await Promise.all([
  batchProcessor.add('user', { url: '/api/user/1' }),
  batchProcessor.add('user', { url: '/api/user/2' }),
  batchProcessor.add('user', { url: '/api/user/3' })
]);
```

**方案 4：使用请求缓存和去重**

```javascript
class RequestDeduplicator {
  constructor(options = {}) {
    this.options = {
      ttl: 60000,
      ...options
    };
    
    this.cache = new Map();
    this.pending = new Map();
  }
  
  async request(key, fn) {
    // 检查缓存
    if (this.cache.has(key)) {
      const cached = this.cache.get(key);
      if (Date.now() - cached.timestamp < this.options.ttl) {
        return cached.data;
      } else {
        this.cache.delete(key);
      }
    }
    
    // 检查是否有相同的请求正在进行
    if (this.pending.has(key)) {
      return this.pending.get(key);
    }
    
    // 发起新请求
    const promise = fn().then(data => {
      this.cache.set(key, {
        data,
        timestamp: Date.now()
      });
      this.pending.delete(key);
      return data;
    }).catch(error => {
      this.pending.delete(key);
      throw error;
    });
    
    this.pending.set(key, promise);
    return promise;
  }
  
  clear() {
    this.cache.clear();
    this.pending.clear();
  }
}

// 使用
const deduplicator = new RequestDeduplicator();

async function getUser(id) {
  return deduplicator.request(`user_${id}`, () => {
    return fetch(`/api/user/${id}`).then(res => res.json());
  });
}

// 多次调用相同请求，只会发起一次 HTTP 请求
const user1 = await getUser(1);
const user2 = await getUser(1); // 从缓存获取
```

**方案 5：使用 Web Worker 处理大量请求**

```javascript
// worker.js
self.onmessage = async (e) => {
  const { requests, maxConcurrent } = e.data;
  const results = [];
  
  // 并发控制
  const chunks = [];
  for (let i = 0; i < requests.length; i += maxConcurrent) {
    chunks.push(requests.slice(i, i + maxConcurrent));
  }
  
  for (const chunk of chunks) {
    const chunkResults = await Promise.all(
      chunk.map(request => fetch(request.url).then(res => res.json()))
    );
    results.push(...chunkResults);
  }
  
  self.postMessage({ results });
};

// main.js
class WorkerRequestProcessor {
  constructor(options = {}) {
    this.options = {
      maxConcurrent: 6,
      ...options
    };
    
    this.worker = new Worker('worker.js');
  }
  
  async process(requests) {
    return new Promise((resolve, reject) => {
      this.worker.onmessage = (e) => {
        resolve(e.data.results);
      };
      
      this.worker.onerror = reject;
      
      this.worker.postMessage({
        requests,
        maxConcurrent: this.options.maxConcurrent
      });
    });
  }
}

// 使用
const workerProcessor = new WorkerRequestProcessor({ maxConcurrent: 6 });

const requests = Array.from({ length: 100 }, (_, i) => ({
  url: `/api/data/${i}`
}));

const results = await workerProcessor.process(requests);
```

---

## 总结

阿里面试题重点掌握：

### 前端基础
1. **JavaScript 核心**：事件循环、数据类型、异步机制、闭包
2. **前端框架**：Vue/React 虚拟 DOM 原理、响应式系统、Diff 算法
3. **CSS 与布局**：三栏布局、选择器优先级、BFC
4. **性能优化**：全链路性能优化方案、图片懒加载、虚拟滚动
5. **工程化与网络**：HTTP 缓存、WebSocket、TCP 优化、HTTP/2
6. **浏览器与安全**：跨域、XSS/CSRF、同源策略

### 算法题
1. **深拷贝**：处理循环引用、特殊对象
2. **LRU 缓存**：使用 Map 实现 O(1) 时间复杂度
3. **函数防抖**：搜索框输入优化
4. **Promise.all**：并发请求聚合
5. **异步调度器**：并发控制

### 场景题
1. **实际应用**：将算法应用到实际场景
2. **扩展性**：考虑边界情况和优化
3. **代码质量**：清晰、可维护、可测试
4. **高并发场景**：QPS 峰值处理、大规模并发控制
5. **截图功能**：html2canvas、Canvas、SVG、原生 API
6. **性能监控**：请求监控、告警机制

**面试准备建议：**
1. 深入理解 JavaScript 核心原理（事件循环、闭包、原型链）
2. 掌握 Vue/React 框架底层原理（虚拟 DOM、响应式系统、Diff 算法）
3. 熟悉性能优化全链路方案（加载、运行、渲染）
4. 熟练掌握手写代码题（深拷贝、防抖节流、Promise 等）
5. 结合阿里业务场景（电商、中后台系统）说明解决方案
6. 注重代码质量和可维护性
7. 保持对新技术的关注和学习热情
8. 掌握高并发场景的解决方案（限流、降级、熔断）
9. 了解前端监控和性能优化工具

**阿里特色：**
- 高频考察工程化实践（Webpack 优化、微前端）
- 关注小程序开发深度（原生组件、框架限制）
- 考察中后台系统开发经验
- 关注高并发场景解决方案
- 注重实际项目经验和问题解决能力
- 考察对性能监控和优化的理解