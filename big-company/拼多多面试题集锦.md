# 拼多多面试题集锦（截止 2025 年底）

## 目录
1. [前端基础](#前端基础)
2. [算法题](#算法题)
3. [场景题](#场景题)

---

## 前端基础

### 1. 手写一个 Promise.all

**答案：**

```javascript
// Promise.all 实现
Promise.myAll = function(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }
    
    const results = [];
    let completedCount = 0;
    const length = promises.length;
    
    if (length === 0) {
      return resolve(results);
    }
    
    promises.forEach((promise, index) => {
      // 处理非 Promise 值
      Promise.resolve(promise).then(
        value => {
          results[index] = value;
          completedCount++;
          
          if (completedCount === length) {
            resolve(results);
          }
        },
        reason => {
          reject(reason);
        }
      );
    });
  });
};

// Promise.allSettled 实现
Promise.myAllSettled = function(promises) {
  return new Promise((resolve) => {
    if (!Array.isArray(promises)) {
      return resolve([]);
    }
    
    const results = [];
    let completedCount = 0;
    const length = promises.length;
    
    if (length === 0) {
      return resolve(results);
    }
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(
        value => {
          results[index] = { status: 'fulfilled', value };
          completedCount++;
          
          if (completedCount === length) {
            resolve(results);
          }
        },
        reason => {
          results[index] = { status: 'rejected', reason };
          completedCount++;
          
          if (completedCount === length) {
            resolve(results);
          }
        }
      );
    });
  });
};

// Promise.race 实现
Promise.myRace = function(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }
    
    promises.forEach(promise => {
      Promise.resolve(promise).then(resolve, reject);
    });
  });
};

// Promise.any 实现
Promise.myAny = function(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }
    
    const errors = [];
    let rejectedCount = 0;
    const length = promises.length;
    
    if (length === 0) {
      return reject(new AggregateError([], 'All promises were rejected'));
    }
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(
        value => {
          resolve(value);
        },
        reason => {
          errors[index] = reason;
          rejectedCount++;
          
          if (rejectedCount === length) {
            reject(new AggregateError(errors, 'All promises were rejected'));
          }
        }
      );
    });
  });
};
```

---

### 2. 如何实现一个前端状态管理库（类似 Vuex）？

**答案：**

```javascript
// 简化版 Vuex
class Store {
  constructor(options) {
    this.state = options.state || {};
    this.mutations = options.mutations || {};
    this.actions = options.actions || {};
    this.getters = options.getters || {};
    this._subscribers = [];
    
    // 响应式状态
    this._reactiveState = this._makeReactive(this.state);
    
    // 计算属性
    this._computedGetters = {};
    this._setupGetters();
  }
  
  // 创建响应式对象
  _makeReactive(obj) {
    const self = this;
    
    return new Proxy(obj, {
      get(target, key) {
        if (typeof target[key] === 'object' && target[key] !== null) {
          return self._makeReactive(target[key]);
        }
        return target[key];
      },
      set(target, key, value) {
        if (target[key] !== value) {
          target[key] = value;
          self._notify();
        }
        return true;
      }
    });
  }
  
  // 设置 getters
  _setupGetters() {
    for (const key in this.getters) {
      Object.defineProperty(this._computedGetters, key, {
        get: () => this.getters[key](this.state, this.getters)
      });
    }
  }
  
  // 获取 state
  get state() {
    return this._reactiveState;
  }
  
  // 获取 getters
  get getters() {
    return this._computedGetters;
  }
  
  // 提交 mutation
  commit(type, payload) {
    const mutation = this.mutations[type];
    if (mutation) {
      mutation(this.state, payload);
    } else {
      console.error(`Unknown mutation type: ${type}`);
    }
  }
  
  // 分发 action
  dispatch(type, payload) {
    const action = this.actions[type];
    if (action) {
      return action({ commit: this.commit.bind(this), state: this.state }, payload);
    } else {
      console.error(`Unknown action type: ${type}`);
    }
  }
  
  // 订阅状态变化
  subscribe(fn) {
    this._subscribers.push(fn);
    
    // 返回取消订阅函数
    return () => {
      const index = this._subscribers.indexOf(fn);
      if (index > -1) {
        this._subscribers.splice(index, 1);
      }
    };
  }
  
  // 通知订阅者
  _notify() {
    this._subscribers.forEach(fn => fn(this.state));
  }
  
  // 替换 state
  replaceState(newState) {
    this.state = this._makeReactive(newState);
    this._notify();
  }
}
```

---

## 算法题

### 3. 实现一个二叉树的遍历（前序、中序、后序、层序）

**答案：**

```javascript
// 二叉树节点定义
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

// 前序遍历（根-左-右）
function preorderTraversal(root) {
  const result = [];
  
  function traverse(node) {
    if (!node) return;
    
    result.push(node.val);
    traverse(node.left);
    traverse(node.right);
  }
  
  traverse(root);
  return result;
}

// 中序遍历（左-根-右）
function inorderTraversal(root) {
  const result = [];
  
  function traverse(node) {
    if (!node) return;
    
    traverse(node.left);
    result.push(node.val);
    traverse(node.right);
  }
  
  traverse(root);
  return result;
}

// 后序遍历（左-右-根）
function postorderTraversal(root) {
  const result = [];
  
  function traverse(node) {
    if (!node) return;
    
    traverse(node.left);
    traverse(node.right);
    result.push(node.val);
  }
  
  traverse(root);
  return result;
}

// 层序遍历（BFS）
function levelOrder(root) {
  if (!root) return [];
  
  const result = [];
  const queue = [root];
  
  while (queue.length > 0) {
    const level = [];
    const levelSize = queue.length;
    
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      level.push(node.val);
      
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    
    result.push(level);
  }
  
  return result;
}
```

---

### 4. 实现一个发布订阅模式

**答案：**

```javascript
// 发布订阅模式
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  // 订阅事件
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    
    this.events[event].push(listener);
    
    // 返回取消订阅函数
    return () => this.off(event, listener);
  }
  
  // 取消订阅
  off(event, listener) {
    if (!this.events[event]) return;
    
    const index = this.events[event].indexOf(listener);
    if (index > -1) {
      this.events[event].splice(index, 1);
    }
  }
  
  // 发布事件
  emit(event, ...args) {
    if (!this.events[event]) return;
    
    this.events[event].forEach(listener => {
      listener(...args);
    });
  }
  
  // 只订阅一次
  once(event, listener) {
    const onceWrapper = (...args) => {
      listener(...args);
      this.off(event, onceWrapper);
    };
    
    this.on(event, onceWrapper);
  }
  
  // 清除所有事件
  clear() {
    this.events = {};
  }
  
  // 清除特定事件的所有监听器
  clearEvent(event) {
    delete this.events[event];
  }
}
```

---

## 场景题

### 5. 如何实现一个无限滚动加载？

**答案：**

```javascript
class InfiniteScroll {
  constructor() {
    this.state = {
      items: [],
      page: 1,
      loading: false,
      hasMore: true
    };
    
    this.init();
  }
  
  init() {
    this.loadItems();
    window.addEventListener('scroll', this.handleScroll);
  }
  
  loadItems = async () => {
    if (this.state.loading || !this.state.hasMore) return;
    
    this.state.loading = true;
    
    try {
      const { page } = this.state;
      const newItems = await this.fetchItems(page);
      
      this.state.items = [...this.state.items, ...newItems];
      this.state.page = page + 1;
      this.state.loading = false;
      this.state.hasMore = newItems.length >= 10;
      
      this.render();
    } catch (error) {
      console.error(error);
      this.state.loading = false;
    }
  };
  
  fetchItems = async (page) => {
    const response = await fetch(`/api/items?page=${page}`);
    const data = await response.json();
    return data;
  };
  
  handleScroll = () => {
    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
    
    // 距离底部 100px 时加载更多
    if (scrollTop + clientHeight >= scrollHeight - 100) {
      this.loadItems();
    }
  };
  
  render() {
    const container = document.getElementById('container');
    container.innerHTML = `
      <ul>
        ${this.state.items.map((item, index) => `
          <li key="${index}">${item.name}</li>
        `).join('')}
      </ul>
      ${this.state.loading ? '<div>加载中...</div>' : ''}
    `;
  }
}
```

---

### 6. 如何实现一个拖拽上传组件？

**答案：**

```javascript
class DragUpload extends React.Component {
  state = {
    isDragging: false,
    files: []
  };
  
  handleDragEnter = (e) => {
    e.preventDefault();
    e.stopPropagation();
    this.setState({ isDragging: true });
  };
  
  handleDragLeave = (e) => {
    e.preventDefault();
    e.stopPropagation();
    this.setState({ isDragging: false });
  };
  
  handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  
  handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    this.setState({ isDragging: false });
    
    const files = Array.from(e.dataTransfer.files);
    this.handleFiles(files);
  };
  
  handleFiles = (files) => {
    this.setState(prevState => ({
      files: [...prevState.files, ...files]
    }));
    
    // 上传文件
    files.forEach(file => this.uploadFile(file));
  };
  
  uploadFile = async (file) => {
    const formData = new FormData();
    formData.append('file', file);
    
    try {
      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });
      const data = await response.json();
      console.log('上传成功:', data);
    } catch (error) {
      console.error('上传失败:', error);
    }
  };
  
  render() {
    const { isDragging, files } = this.state;
    
    return (
      <div>
        <div
          onDragEnter={this.handleDragEnter}
          onDragLeave={this.handleDragLeave}
          onDragOver={this.handleDragOver}
          onDrop={this.handleDrop}
          style={{
            border: `2px dashed ${isDragging ? '#1890ff' : '#d9d9d9'}`,
            padding: '40px',
            textAlign: 'center',
            backgroundColor: isDragging ? '#f0f9ff' : '#fafafa'
          }}
        >
          {isDragging ? '释放文件以上传' : '拖拽文件到此处'}
        </div>
        
        <ul>
          {files.map((file, index) => (
            <li key={index}>{file.name}</li>
          ))}
        </ul>
      </div>
    );
  }
}
```

---

### 7. 如何实现一个表单验证？

**答案：**

```javascript
class FormValidator {
  constructor(rules = {}) {
    this.rules = rules;
    this.errors = {};
  }
  
  // 添加验证规则
  addRule(field, rule) {
    if (!this.rules[field]) {
      this.rules[field] = [];
    }
    this.rules[field].push(rule);
  }
  
  // 验证单个字段
  validateField(field, value) {
    const fieldRules = this.rules[field];
    if (!fieldRules) {
      return [];
    }
    
    const errors = [];
    
    for (const rule of fieldRules) {
      const result = rule.validator(value);
      if (!result.valid) {
        errors.push(rule.message);
      }
    }
    
    return errors;
  }
  
  // 验证整个表单
  validate(data) {
    this.errors = {};
    let isValid = true;
    
    for (const field in this.rules) {
      const fieldErrors = this.validateField(field, data[field]);
      if (fieldErrors.length > 0) {
        this.errors[field] = fieldErrors;
        isValid = false;
      }
    }
    
    return isValid;
  }
  
  // 获取错误信息
  getErrors() {
    return this.errors;
  }
  
  // 清除错误
  clearErrors() {
    this.errors = {};
  }
}

// 使用
const validator = new FormValidator({
  username: [
    {
      validator: (value) => ({
        valid: value && value.length >= 3,
      }),
      message: '用户名至少3个字符',
    },
    {
      validator: (value) => ({
        valid: /^[a-zA-Z0-9_]+$/.test(value),
      }),
      message: '用户名只能包含字母、数字和下划线',
    },
  ],
  email: [
    {
      validator: (value) => ({
        valid: /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
      }),
      message: '邮箱格式不正确',
    },
  ],
});

const formData = {
  username: 'ab',
  email: 'invalid-email',
};

const isValid = validator.validate(formData);
if (!isValid) {
  console.log(validator.getErrors());
}
```

---

### 8. 如何实现一个权限控制组件？

**答案：**

```javascript
// 权限上下文
const PermissionContext = React.createContext();

function PermissionProvider({ permissions, children }) {
  return (
    <PermissionContext.Provider value={permissions}>
      {children}
    </PermissionContext.Provider>
  );
}

// 权限检查组件
function Permission({ permission, fallback = null, children }) {
  const permissions = React.useContext(PermissionContext);
  
  const hasPermission = permissions.includes(permission);
  
  if (!hasPermission) {
    return fallback;
  }
  
  return children;
}

// 使用
function App() {
  const userPermissions = ['read', 'write', 'delete'];
  
  return (
    <PermissionProvider permissions={userPermissions}>
      <Dashboard />
    </PermissionProvider>
  );
}

function Dashboard() {
  return (
    <div>
      <Permission permission="read">
        <ReadData />
      </Permission>
      
      <Permission permission="write" fallback={<div>没有写入权限</div>}>
        <WriteData />
      </Permission>
      
      <Permission permission="delete" fallback={<div>没有删除权限</div>}>
        <DeleteData />
      </Permission>
    </div>
  );
}
```

---

## 总结

拼多多面试题重点掌握：

### 前端基础
1. **Promise**：all、allSettled、race、any 的实现
2. **状态管理**：Vuex/Redux 的实现原理
3. **无限滚动**：性能优化、防抖节流
4. **拖拽上传**：拖拽事件、文件上传、进度显示
5. **表单验证**：规则配置、错误处理
6. **权限控制**：权限上下文、权限检查组件

### 算法题
1. **二叉树遍历**：前序、中序、后序、层序
2. **设计模式**：发布订阅模式

### 场景题
1. **实际应用**：将算法应用到实际场景
2. **扩展性**：考虑边界情况和优化
3. **代码质量**：清晰、可维护、可测试

**面试准备建议：**
1. 深入理解 Promise 和异步编程
2. 掌握常见数据结构
3. 熟悉设计模式
4. 注重代码质量和可维护性

**答案：**

```javascript
class InfiniteScroll {
  constructor() {
    this.state = {
      items: [],
      page: 1,
      loading: false,
      hasMore: true
    };
    
    this.init();
  }
  
  init() {
    this.loadItems();
    window.addEventListener('scroll', this.handleScroll);
  }
  
  loadItems = async () => {
    if (this.state.loading || !this.state.hasMore) return;
    
    this.state.loading = true;
    
    try {
      const { page } = this.state;
      const newItems = await this.fetchItems(page);
      
      this.state.items = [...this.state.items, ...newItems];
      this.state.page = page + 1;
      this.state.loading = false;
      this.state.hasMore = newItems.length >= 10;
      
      this.render();
    } catch (error) {
      console.error(error);
      this.state.loading = false;
    }
  };
  
  fetchItems = async (page) => {
    const response = await fetch(`/api/items?page=${page}`);
    const data = await response.json();
    return data;
  };
  
  handleScroll = () => {
    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
    
    // 距离底部 100px 时加载更多
    if (scrollTop + clientHeight >= scrollHeight - 100) {
      this.loadItems();
    }
  };
  
  render() {
    const container = document.getElementById('container');
    container.innerHTML = `
      <ul>
        ${this.state.items.map((item, index) => `
          <li key="${index}">${item.name}</li>
        `).join('')}
      </ul>
      ${this.state.loading ? '<div>加载中...</div>' : ''}
    `;
  }
}
```

### 9. 如何优化频繁切换标签页的性能？

**答案：**

频繁切换标签页会导致页面重新渲染和资源浪费，需要进行性能优化。

**优化方案：**

**方案 1：使用 Page Visibility API**
```javascript
class TabVisibilityManager {
  constructor() {
    this.isVisible = true;
    this.hiddenHandlers = [];
    this.visibleHandlers = [];
    this.init();
  }
  
  init() {
    // 监听页面可见性变化
    document.addEventListener('visibilitychange', this.handleVisibilityChange);
    
    // 兼容旧版浏览器
    document.addEventListener('webkitvisibilitychange', this.handleVisibilityChange);
    document.addEventListener('mozvisibilitychange', this.handleVisibilityChange);
    document.addEventListener('msvisibilitychange', this.handleVisibilityChange);
  }
  
  handleVisibilityChange = () => {
    this.isVisible = !document.hidden;
    
    if (this.isVisible) {
      this.visibleHandlers.forEach(handler => handler());
    } else {
      this.hiddenHandlers.forEach(handler => handler());
    }
  };
  
  onHidden(handler) {
    this.hiddenHandlers.push(handler);
  }
  
  onVisible(handler) {
    this.visibleHandlers.push(handler);
  }
  
  destroy() {
    document.removeEventListener('visibilitychange', this.handleVisibilityChange);
    document.removeEventListener('webkitvisibilitychange', this.handleVisibilityChange);
    document.removeEventListener('mozvisibilitychange', this.handleVisibilityChange);
    document.removeEventListener('msvisibilitychange', this.handleVisibilityChange);
  }
}

// 使用
const visibilityManager = new TabVisibilityManager();

// 页面隐藏时暂停定时器
let timer;
visibilityManager.onHidden(() => {
  clearInterval(timer);
});

// 页面显示时恢复定时器
visibilityManager.onVisible(() => {
  timer = setInterval(() => {
    fetchData();
  }, 5000);
});
```

**方案 2：暂停和恢复动画**
```javascript
class AnimationManager {
  constructor() {
    this.animations = new Map();
    this.init();
  }
  
  init() {
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.pauseAll();
      } else {
        this.resumeAll();
      }
    });
  }
  
  register(id, animation) {
    this.animations.set(id, animation);
  }
  
  pauseAll() {
    this.animations.forEach(animation => {
      if (animation.pause) {
        animation.pause();
      }
    });
  }
  
  resumeAll() {
    this.animations.forEach(animation => {
      if (animation.resume) {
        animation.resume();
      }
    });
  }
}

// 使用
const animationManager = new AnimationManager();

const animation1 = new Animation();
const animation2 = new Animation();

animationManager.register('anim1', animation1);
animationManager.register('anim2', animation2);
```

**方案 3：优化数据请求**
```javascript
class RequestManager {
  constructor() {
    this.isTabActive = true;
    this.pendingRequests = new Map();
    this.init();
  }
  
  init() {
    document.addEventListener('visibilitychange', () => {
      this.isTabActive = !document.hidden;
      
      if (this.isTabActive) {
        this.resumeRequests();
      } else {
        this.abortRequests();
      }
    });
  }
  
  async fetch(url, options = {}) {
    if (!this.isTabActive) {
      return new Promise((resolve, reject) => {
        this.pendingRequests.set(url, { resolve, reject, url, options });
      });
    }
    
    try {
      const response = await fetch(url, options);
      return await response.json();
    } catch (error) {
      throw error;
    }
  }
  
  resumeRequests() {
    this.pendingRequests.forEach(({ resolve, reject, url, options }) => {
      fetch(url, options)
        .then(response => response.json())
        .then(resolve)
        .catch(reject);
    });
    
    this.pendingRequests.clear();
  }
  
  abortRequests() {
    this.pendingRequests.forEach(({ reject }) => {
      reject(new Error('Request aborted due to tab switch'));
    });
    
    this.pendingRequests.clear();
  }
}
```

**方案 4：React 中的优化**
```javascript
import { useState, useEffect, useRef } from 'react';

function OptimizedComponent() {
  const [data, setData] = useState(null);
  const intervalRef = useRef(null);
  const isVisibleRef = useRef(true);
  
  useEffect(() => {
    // 监听页面可见性
    const handleVisibilityChange = () => {
      isVisibleRef.current = !document.hidden;
      
      if (isVisibleRef.current) {
        startFetching();
      } else {
        stopFetching();
      }
    };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // 初始启动
    startFetching();
    
    return () => {
      stopFetching();
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, []);
  
  const startFetching = () => {
    if (intervalRef.current) return;
    
    intervalRef.current = setInterval(async () => {
      try {
        const response = await fetch('/api/data');
        const data = await response.json();
        setData(data);
      } catch (error) {
        console.error('Fetch error:', error);
      }
    }, 5000);
  };
  
  const stopFetching = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };
  
  return (
    <div>
      <h1>数据: {data ? JSON.stringify(data) : '加载中...'}</h1>
    </div>
  );
}
```

**方案 5：使用 Intersection Observer 优化**
```javascript
class LazyTabManager {
  constructor() {
    this.activeTabs = new Set();
    this.observer = null;
    this.init();
  }
  
  init() {
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const tabId = entry.target.dataset.tabId;
        
        if (entry.isIntersecting) {
          this.activateTab(tabId);
        } else {
          this.deactivateTab(tabId);
        }
      });
    }, {
      threshold: 0.5
    });
  }
  
  observeTab(tabElement, tabId) {
    tabElement.dataset.tabId = tabId;
    this.observer.observe(tabElement);
  }
  
  activateTab(tabId) {
    if (!this.activeTabs.has(tabId)) {
      this.activeTabs.add(tabId);
      this.loadTabContent(tabId);
    }
  }
  
  deactivateTab(tabId) {
    this.activeTabs.delete(tabId);
    this.unloadTabContent(tabId);
  }
  
  loadTabContent(tabId) {
    console.log(`Loading content for tab: ${tabId}`);
    // 加载标签页内容
  }
  
  unloadTabContent(tabId) {
    console.log(`Unloading content for tab: ${tabId}`);
    // 卸载标签页内容
  }
  
  destroy() {
    this.observer.disconnect();
  }
}
```

**优化技巧：**

1. **使用 requestIdleCallback**
```javascript
function performHeavyTask() {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() => {
      // 在浏览器空闲时执行
      heavyTask();
    });
  } else {
    // 降级方案
    setTimeout(() => {
      heavyTask();
    }, 0);
  }
}
```

2. **使用 Web Worker**
```javascript
// 主线程
const worker = new Worker('worker.js');

worker.onmessage = (e) => {
  const result = e.data;
  console.log('Worker result:', result);
};

// 发送任务给 Worker
worker.postMessage({ task: 'heavy-computation', data: largeData });

// worker.js
self.onmessage = (e) => {
  const { task, data } = e.data;
  
  if (task === 'heavy-computation') {
    const result = performHeavyComputation(data);
    self.postMessage(result);
  }
};
```

3. **使用 Virtual DOM 优化**
```javascript
import { memo } from 'react';

const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {
  // 只在 data 变化时重新渲染
  return <div>{/* 复杂渲染逻辑 */}</div>;
});

function Parent() {
  const [data, setData] = useState(null);
  
  return (
    <div>
      <ExpensiveComponent data={data} />
    </div>
  );
}
```

---

### 10. 如何实现一个高并发的请求控制器？

**答案：**

在高并发场景下，需要控制并发请求数量，避免浏览器或服务器过载。

**实现方案：**

**方案 1：基于 Promise 的并发控制**
```javascript
class ConcurrencyController {
  constructor(maxConcurrent = 5) {
    this.maxConcurrent = maxConcurrent;
    this.runningCount = 0;
    this.queue = [];
  }
  
  async run(task) {
    // 如果当前运行数量达到上限，加入队列等待
    if (this.runningCount >= this.maxConcurrent) {
      await new Promise(resolve => {
        this.queue.push(resolve);
      });
    }
    
    this.runningCount++;
    
    try {
      const result = await task();
      return result;
    } finally {
      this.runningCount--;
      
      // 从队列中取出下一个任务
      if (this.queue.length > 0) {
        const resolve = this.queue.shift();
        resolve();
      }
    }
  }
  
  async runAll(tasks) {
    return Promise.all(tasks.map(task => this.run(task)));
  }
}

// 使用
const controller = new ConcurrencyController(3);

const tasks = [
  () => fetch('/api/data1'),
  () => fetch('/api/data2'),
  () => fetch('/api/data3'),
  () => fetch('/api/data4'),
  () => fetch('/api/data5'),
  () => fetch('/api/data6'),
];

const results = await controller.runAll(tasks);
```

**方案 2：带优先级的并发控制**
```javascript
class PriorityConcurrencyController {
  constructor(maxConcurrent = 5) {
    this.maxConcurrent = maxConcurrent;
    this.runningCount = 0;
    this.queue = [];
  }
  
  async run(task, priority = 0) {
    return new Promise((resolve, reject) => {
      // 添加到队列，按优先级排序
      this.queue.push({ task, priority, resolve, reject });
      this.queue.sort((a, b) => b.priority - a.priority);
      
      this.processQueue();
    });
  }
  
  async processQueue() {
    if (this.runningCount >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    const { task, resolve, reject } = this.queue.shift();
    this.runningCount++;
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.runningCount--;
      this.processQueue();
    }
  }
  
  async runAll(tasks) {
    return Promise.all(tasks.map(task => this.run(task)));
  }
}

// 使用
const controller = new PriorityConcurrencyController(3);

// 高优先级任务
await controller.run(() => fetch('/api/high-priority'), 10);

// 普通优先级任务
await controller.run(() => fetch('/api/normal'), 5);

// 低优先级任务
await controller.run(() => fetch('/api/low'), 1);
```

**方案 3：带重试机制的并发控制**
```javascript
class RetryConcurrencyController {
  constructor(maxConcurrent = 5, maxRetries = 3) {
    this.maxConcurrent = maxConcurrent;
    this.maxRetries = maxRetries;
    this.runningCount = 0;
    this.queue = [];
  }
  
  async run(task, retryCount = 0) {
    if (this.runningCount >= this.maxConcurrent) {
      await new Promise(resolve => {
        this.queue.push(resolve);
      });
    }
    
    this.runningCount++;
    
    try {
      const result = await task();
      return result;
    } catch (error) {
      // 如果还有重试次数，重新加入队列
      if (retryCount < this.maxRetries) {
        console.log(`Retry ${retryCount + 1}/${this.maxRetries}`);
        return this.run(task, retryCount + 1);
      }
      throw error;
    } finally {
      this.runningCount--;
      
      if (this.queue.length > 0) {
        const resolve = this.queue.shift();
        resolve();
      }
    }
  }
  
  async runAll(tasks) {
    return Promise.all(tasks.map(task => this.run(task)));
  }
}
```

**方案 4：带超时控制的并发控制**
```javascript
class TimeoutConcurrencyController {
  constructor(maxConcurrent = 5, timeout = 10000) {
    this.maxConcurrent = maxConcurrent;
    this.timeout = timeout;
    this.runningCount = 0;
    this.queue = [];
  }
  
  async run(task) {
    if (this.runningCount >= this.maxConcurrent) {
      await new Promise(resolve => {
        this.queue.push(resolve);
      });
    }
    
    this.runningCount++;
    
    try {
      // 添加超时控制
      const result = await Promise.race([
        task(),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout')), this.timeout)
        )
      ]);
      return result;
    } finally {
      this.runningCount--;
      
      if (this.queue.length > 0) {
        const resolve = this.queue.shift();
        resolve();
      }
    }
  }
  
  async runAll(tasks) {
    return Promise.all(tasks.map(task => this.run(task)));
  }
}
```

**方案 5：批量请求优化**
```javascript
class BatchRequestManager {
  constructor(maxBatchSize = 10, maxWaitTime = 100) {
    this.maxBatchSize = maxBatchSize;
    this.maxWaitTime = maxWaitTime;
    this.currentBatch = [];
    this.timer = null;
  }
  
  async request(url) {
    return new Promise((resolve, reject) => {
      this.currentBatch.push({ url, resolve, reject });
      
      // 如果批次已满，立即发送
      if (this.currentBatch.length >= this.maxBatchSize) {
        this.flushBatch();
      } else if (!this.timer) {
        // 设置定时器，在最大等待时间后发送
        this.timer = setTimeout(() => {
          this.flushBatch();
          this.timer = null;
        }, this.maxWaitTime);
      }
    });
  }
  
  async flushBatch() {
    if (this.currentBatch.length === 0) return;
    
    const batch = this.currentBatch.splice(0);
    
    // 批量请求
    const urls = batch.map(item => item.url);
    try {
      const response = await fetch('/api/batch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ urls }),
      });
      const results = await response.json();
      
      // 分发结果
      results.forEach((result, index) => {
        batch[index].resolve(result);
      });
    } catch (error) {
      batch.forEach(item => item.reject(error));
    }
  }
  
  destroy() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
    this.flushBatch();
  }
}
```

---

## 总结

拼多多面试题重点掌握：

### 前端基础
1. **Promise**：all、allSettled、race、any 的实现
2. **状态管理**：Vuex/Redux 的实现原理
3. **性能优化**：频繁切换标签页、并发控制、批量请求

### 算法题
1. **二叉树遍历**：前序、中序、后序、层序
2. **设计模式**：发布订阅模式

### 场景题
1. **无限滚动**：性能优化、防抖节流
2. **拖拽上传**：文件上传、进度显示
3. **表单验证**：规则配置、错误处理
4. **权限控制**：权限上下文、权限检查组件
5. **标签页优化**：Page Visibility API、动画暂停、请求优化
6. **并发控制**：Promise 并发、优先级控制、重试机制、超时控制
7. **批量请求**：请求合并、性能优化

**面试准备建议：**
1. 深入理解 Promise 和异步编程
2. 掌握常见数据结构
3. 熟悉设计模式
4. 注重代码质量和可维护性
5. 关注性能优化和并发控制