# 10. 如何设计一个前端项目的监控和告警系统？

**答案：**

前端监控和告警系统需要覆盖性能、错误、用户行为等多个维度。

**系统设计：**

**方案 1：性能监控系统**
```javascript
class PerformanceMonitor {
  constructor(options = {}) {
    this.options = {
      sampleRate: 1,
      reportUrl: '',
      metrics: ['FCP', 'LCP', 'FID', 'CLS', 'TTFB'],
      ...options
    };
    
    this.metrics = {};
    this.init();
  }
  
  init() {
    // 监听页面加载
    if (document.readyState === 'complete') {
      this.collectMetrics();
    } else {
      window.addEventListener('load', () => this.collectMetrics());
    }
    
    // 监听性能指标
    this.observeWebVitals();
    
    // 监听资源加载
    this.observeResources();
  }
  
  collectMetrics() {
    const timing = performance.timing;
    
    this.metrics = {
      // 页面加载相关
      DNS: timing.domainLookupEnd - timing.domainLookupStart,
      TCP: timing.connectEnd - timing.connectStart,
      TTFB: timing.responseStart - timing.requestStart,
      Download: timing.responseEnd - timing.responseStart,
      DOMContentLoaded: timing.domContentLoadedEventEnd - timing.fetchStart,
      Load: timing.loadEventEnd - timing.fetchStart,
      
      // 首屏相关
      FirstPaint: timing.responseStart - timing.fetchStart,
      FirstContentfulPaint: timing.domLoading - timing.fetchStart,
    };
    
    this.report();
  }
  
  observeWebVitals() {
    // FCP (First Contentful Paint)
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach(entry => {
          if (entry.name === 'first-contentful-paint') {
            this.metrics.FCP = entry.startTime;
          }
        });
      });
      observer.observe({ entryTypes: ['paint'] });
      
      // LCP (Largest Contentful Paint)
      const lcpObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        const lastEntry = entries[entries.length - 1];
        this.metrics.LCP = lastEntry.startTime;
      });
      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
      
      // FID (First Input Delay)
      const fidObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach(entry => {
          this.metrics.FID = entry.processingStart - entry.startTime;
        });
      });
      fidObserver.observe({ entryTypes: ['first-input'] });
      
      // CLS (Cumulative Layout Shift)
      let clsValue = 0;
      const clsObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach(entry => {
          if (!entry.hadRecentInput) {
            clsValue += entry.value;
          }
        });
        this.metrics.CLS = clsValue;
      });
      clsObserver.observe({ entryTypes: ['layout-shift'] });
    }
  }
  
  observeResources() {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        if (entry.duration > 1000) { // 超过1秒的资源
          this.reportSlowResource(entry);
        }
      });
    });
    observer.observe({ entryTypes: ['resource'] });
  }
  
  reportSlowResource(entry) {
    this.report({
      type: 'slow-resource',
      data: {
        name: entry.name,
        duration: entry.duration,
        size: entry.transferSize,
        type: entry.initiatorType
      }
    });
  }
  
  report(extraData = {}) {
    if (Math.random() > this.options.sampleRate) {
      return;
    }
    
    const data = {
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      metrics: this.metrics,
      ...extraData
    };
    
    // 使用 sendBeacon 优先
    if (navigator.sendBeacon) {
      navigator.sendBeacon(this.options.reportUrl, JSON.stringify(data));
    } else {
      fetch(this.options.reportUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
        keepalive: true
      }).catch(() => {
        // 失败时存储到 localStorage
        this.storeFailedReport(data);
      });
    }
  }
  
  storeFailedReport(data) {
    const failedReports = JSON.parse(localStorage.getItem('failed-reports') || '[]');
    failedReports.push(data);
    localStorage.setItem('failed-reports', JSON.stringify(failedReports));
  }
  
  retryFailedReports() {
    const failedReports = JSON.parse(localStorage.getItem('failed-reports') || '[]');
    
    failedReports.forEach(data => {
      fetch(this.options.reportUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      }).then(() => {
        const index = failedReports.indexOf(data);
        if (index > -1) {
          failedReports.splice(index, 1);
          localStorage.setItem('failed-reports', JSON.stringify(failedReports));
        }
      });
    });
  }
}
```

**方案 2：错误监控系统**
```javascript
class ErrorMonitor {
  constructor(options = {}) {
    this.options = {
      sampleRate: 1,
      reportUrl: '',
      maxErrors: 100,
      ...options
    };
    
    this.errors = [];
    this.init();
  }
  
  init() {
    // 监听全局错误
    window.addEventListener('error', this.handleError.bind(this));
    
    // 监听 Promise 错误
    window.addEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this));
    
    // 监听资源加载错误
    window.addEventListener('error', this.handleResourceError.bind(this), true);
    
    // 监听 Vue 错误
    if (window.Vue) {
      Vue.config.errorHandler = this.handleVueError.bind(this);
    }
    
    // 监听 React 错误
    if (window.React) {
      window.addEventListener('error', this.handleReactError.bind(this));
    }
  }
  
  handleError(event) {
    const error = {
      type: 'javascript',
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      timestamp: Date.now(),
      url: window.location.href
    };
    
    this.collectError(error);
  }
  
  handleUnhandledRejection(event) {
    const error = {
      type: 'promise',
      reason: event.reason?.toString(),
      stack: event.reason?.stack,
      timestamp: Date.now(),
      url: window.location.href
    };
    
    this.collectError(error);
  }
  
  handleResourceError(event) {
    if (event.target !== window) {
      const error = {
        type: 'resource',
        tagName: event.target.tagName,
        src: event.target.src || event.target.href,
        timestamp: Date.now(),
        url: window.location.href
      };
      
      this.collectError(error);
    }
  }
  
  handleVueError(error, vm, info) {
    const errorData = {
      type: 'vue',
      message: error.message,
      stack: error.stack,
      info: info,
      component: vm?.$options?.name,
      timestamp: Date.now(),
      url: window.location.href
    };
    
    this.collectError(errorData);
  }
  
  handleReactError(event) {
    // React 错误边界处理
    if (event.error) {
      const error = {
        type: 'react',
        message: event.error.message,
        stack: event.error.stack,
        timestamp: Date.now(),
        url: window.location.href
      };
      
      this.collectError(error);
    }
  }
  
  collectError(error) {
    if (Math.random() > this.options.sampleRate) {
      return;
    }
    
    this.errors.push(error);
    
    // 限制错误数量
    if (this.errors.length > this.options.maxErrors) {
      this.errors.shift();
    }
    
    // 立即上报
    this.report(error);
  }
  
  report(error) {
    if (navigator.sendBeacon) {
      navigator.sendBeacon(this.options.reportUrl, JSON.stringify(error));
    } else {
      fetch(this.options.reportUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(error),
        keepalive: true
      }).catch(() => {
        // 失败时存储
        this.storeFailedError(error);
      });
    }
  }
  
  storeFailedError(error) {
    const failedErrors = JSON.parse(localStorage.getItem('failed-errors') || '[]');
    failedErrors.push(error);
    localStorage.setItem('failed-errors', JSON.stringify(failedErrors));
  }
}
```

**方案 3：告警系统**
```javascript
class AlertSystem {
  constructor(options = {}) {
    this.options = {
      webhookUrl: '',
      thresholds: {
        errorRate: 0.01, // 错误率 1%
        slowResponse: 3000, // 慢响应 3秒
        memoryUsage: 0.8 // 内存使用率 80%
      },
      ...options
    };
    
    this.errorCount = 0;
    this.totalRequests = 0;
    this.alertHistory = [];
    this.init();
  }
  
  init() {
    // 监控错误率
    setInterval(() => this.checkErrorRate(), 60000);
    
    // 监控内存使用
    setInterval(() => this.checkMemoryUsage(), 30000);
    
    // 监控慢请求
    this.monitorSlowRequests();
  }
  
  checkErrorRate() {
    const errorRate = this.errorCount / this.totalRequests;
    
    if (errorRate > this.options.thresholds.errorRate) {
      this.sendAlert({
        type: 'high-error-rate',
        severity: 'critical',
        message: `错误率过高: ${(errorRate * 100).toFixed(2)}%`,
        data: {
          errorCount: this.errorCount,
          totalRequests: this.totalRequests
        }
      });
    }
    
    // 重置计数器
    this.errorCount = 0;
    this.totalRequests = 0;
  }
  
  checkMemoryUsage() {
    if (performance.memory) {
      const usage = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
      
      if (usage > this.options.thresholds.memoryUsage) {
        this.sendAlert({
          type: 'high-memory-usage',
          severity: 'warning',
          message: `内存使用率过高: ${(usage * 100).toFixed(2)}%`,
          data: {
            used: performance.memory.usedJSHeapSize,
            total: performance.memory.jsHeapSizeLimit
          }
        });
      }
    }
  }
  
  monitorSlowRequests() {
    const originalFetch = window.fetch;
    
    window.fetch = async (...args) => {
      const start = Date.now();
      
      try {
        const response = await originalFetch(...args);
        const duration = Date.now() - start;
        
        if (duration > this.options.thresholds.slowResponse) {
          this.sendAlert({
            type: 'slow-request',
            severity: 'warning',
            message: `请求响应过慢: ${duration}ms`,
            data: {
              url: args[0],
              duration
            }
          });
        }
        
        return response;
      } catch (error) {
        this.errorCount++;
        throw error;
      } finally {
        this.totalRequests++;
      }
    };
  }
  
  sendAlert(alert) {
    // 避免重复告警
    const alertKey = `${alert.type}-${alert.message}`;
    const lastAlert = this.alertHistory[alertKey];
    
    if (lastAlert && Date.now() - lastAlert < 300000) { // 5分钟内不重复告警
      return;
    }
    
    this.alertHistory[alertKey] = Date.now();
    
    // 发送告警
    if (this.options.webhookUrl) {
      fetch(this.options.webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...alert,
          timestamp: Date.now(),
          url: window.location.href
        })
      }).catch(error => {
        console.error('Failed to send alert:', error);
      });
    }
    
    // 本地通知
    this.showNotification(alert);
  }
  
  showNotification(alert) {
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(alert.message, {
        body: alert.type,
        icon: '/alert-icon.png'
      });
    }
  }
}
```

---

## 总结

百度面试题重点掌握：

### 前端基础
1. **浏览器渲染**：DOM树、CSSOM树、Render树、重排重绘
2. **构建工具**：Webpack原理、模块化、代码分割
3. **性能优化**：大规模数据可视化、监控告警系统

### 算法题
1. **快速排序**：原地排序、三路快排
2. **节流函数**：立即执行、尾随调用

### 场景题
1. **虚拟滚动**：性能优化、大数据渲染
2. **数据可视化**：Canvas、WebGL、Web Workers
3. **监控系统**：性能监控、错误监控、告警系统
4. **工程化体系**：构建优化、代码质量、CI/CD

**面试准备建议：**
1. 深入理解浏览器渲染原理
2. 掌握常见排序算法
3. 熟悉性能优化技巧
4. 注重代码质量和可维护性
5. 了解大规模数据处理方案
6. 掌握监控和告警系统设计
