# 1. 谈谈你对浏览器渲染原理的理解

**答案：**

**浏览器渲染流程：**

```
1. 解析 HTML → 构建 DOM 树
2. 解析 CSS → 构建 CSSOM 树
3. 合并 DOM 和 CSSOM → 构建 Render 树
4. 布局（Layout）→ 计算元素位置和大小
5. 绘制（Paint）→ 填充像素
6. 合成（Composite）→ 将图层合成到屏幕
```

**详细过程：**

```javascript
// 1. DOM 树构建
// 浏览器将 HTML 解析为 DOM 树
// <div><p>Hello</p></div>
// → DIV
//    └── P
//         └── "Hello"

// 2. CSSOM 树构建
// 浏览器将 CSS 解析为 CSSOM 树
// div { color: red; }
// p { font-size: 16px; }
// → DIV
//    ├── color: red
//    └── P
//         ├── font-size: 16px
//         └── color: red (继承)

// 3. Render 树构建
// 合并 DOM 和 CSSOM，只包含可见元素
// → DIV
//    └── P (visible)

// 4. 布局（Layout/Reflow）
// 计算每个元素的位置和大小
function layout(element) {
  // 计算元素的几何属性
  const width = element.computedStyle.width;
  const height = element.computedStyle.height;
  const x = element.parent.x + element.computedStyle.marginLeft;
  const y = element.parent.y + element.computedStyle.marginTop;
  
  element.layout = { x, y, width, height };
  
  // 递归布局子元素
  for (const child of element.children) {
    layout(child);
  }
}

// 5. 绘制（Paint）
// 将元素绘制到图层
function paint(element, layer) {
  const { x, y, width, height } = element.layout;
  
  // 绘制背景
  if (element.computedStyle.backgroundColor) {
    layer.fillRect(x, y, width, height, element.computedStyle.backgroundColor);
  }
  
  // 绘制边框
  if (element.computedStyle.border) {
    layer.strokeRect(x, y, width, height, element.computedStyle.border);
  }
  
  // 绘制文本
  if (element.textContent) {
    layer.fillText(element.textContent, x, y, element.computedStyle);
  }
  
  // 递归绘制子元素
  for (const child of element.children) {
    paint(child, layer);
  }
}

// 6. 合成（Composite）
// 将多个图层合成到屏幕
function composite(layers) {
  for (const layer of layers) {
    // 将图层绘制到屏幕
    screen.drawImage(layer);
  }
}
```

**重排（Reflow）和重绘（Repaint）：**

```javascript
// 重排：元素位置或大小变化
// 触发重排的操作：
function triggerReflow() {
  // 1. 添加/删除可见 DOM 元素
  document.body.appendChild(div);
  
  // 2. 改变元素位置
  element.style.left = '100px';
  element.style.top = '100px';
  
  // 3. 改变元素尺寸
  element.style.width = '200px';
  element.style.height = '200px';
  
  // 4. 改变元素内容
  element.textContent = 'New content';
  
  // 5. 改变浏览器窗口大小
  window.onresize = () => {
    // 触发重排
  };
  
  // 6. 读取某些属性（强制同步布局）
  const height = element.offsetHeight; // 触发重排
  const width = element.offsetWidth;
  const scrollTop = element.scrollTop;
}

// 重绘：元素外观变化但位置不变
// 触发重绘的操作：
function triggerRepaint() {
  // 1. 改变颜色
  element.style.color = 'red';
  element.style.backgroundColor = 'blue';
  
  // 2. 改变背景
  element.style.backgroundImage = 'url(...)';
  
  // 3. 改变边框
  element.style.border = '1px solid red';
  
  // 4. 改变阴影
  element.style.boxShadow = '0 0 10px black';
}
```

---
