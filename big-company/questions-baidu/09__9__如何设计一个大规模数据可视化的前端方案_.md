# 9. 如何设计一个大规模数据可视化的前端方案？

**答案：**

大规模数据可视化需要考虑性能、交互、可扩展性等多个方面。

**方案设计：**

**方案 1：基于 Canvas 的数据可视化**
```javascript
class CanvasDataVisualization {
  constructor(canvas, data) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.data = data;
    this.visibleData = [];
    this.offsetX = 0;
    this.offsetY = 0;
    this.scale = 1;
    this.isDragging = false;
    this.lastMouseX = 0;
    this.lastMouseY = 0;
    
    this.init();
  }
  
  init() {
    // 设置 Canvas 大小
    this.resizeCanvas();
    window.addEventListener('resize', () => this.resizeCanvas());
    
    // 初始化交互
    this.initInteractions();
    
    // 初始渲染
    this.render();
  }
  
  resizeCanvas() {
    const container = this.canvas.parentElement;
    this.canvas.width = container.clientWidth;
    this.canvas.height = container.clientHeight;
    this.render();
  }
  
  initInteractions() {
    // 鼠标拖拽
    this.canvas.addEventListener('mousedown', (e) => {
      this.isDragging = true;
      this.lastMouseX = e.clientX;
      this.lastMouseY = e.clientY;
    });
    
    this.canvas.addEventListener('mousemove', (e) => {
      if (this.isDragging) {
        const dx = e.clientX - this.lastMouseX;
        const dy = e.clientY - this.lastMouseY;
        this.offsetX += dx;
        this.offsetY += dy;
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        this.render();
      }
    });
    
    this.canvas.addEventListener('mouseup', () => {
      this.isDragging = false;
    });
    
    // 滚轮缩放
    this.canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      this.scale *= zoomFactor;
      this.render();
    });
  }
  
  render() {
    // 清空画布
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // 计算可见区域
    const visibleStart = Math.floor(-this.offsetY / this.scale);
    const visibleEnd = visibleStart + Math.ceil(this.canvas.height / this.scale) + 1;
    
    // 只渲染可见区域的数据
    this.visibleData = this.data.slice(Math.max(0, visibleStart), visibleEnd);
    
    // 绘制数据点
    this.visibleData.forEach((point, index) => {
      const x = point.x * this.scale + this.offsetX;
      const y = point.y * this.scale + this.offsetY;
      
      // 绘制点
      this.ctx.beginPath();
      this.ctx.arc(x, y, 3 * this.scale, 0, Math.PI * 2);
      this.ctx.fillStyle = point.color || '#1890ff';
      this.ctx.fill();
      
      // 绘制标签
      if (this.scale > 1) {
        this.ctx.font = `${12 * this.scale}px Arial`;
        this.ctx.fillStyle = '#333';
        this.ctx.fillText(point.label, x + 5 * this.scale, y);
      }
    });
    
    // 绘制坐标轴
    this.drawAxes();
  }
  
  drawAxes() {
    const padding = 50 * this.scale;
    
    // X 轴
    this.ctx.beginPath();
    this.ctx.moveTo(padding, this.canvas.height - padding);
    this.ctx.lineTo(this.canvas.width - padding, this.canvas.height - padding);
    this.ctx.strokeStyle = '#333';
    this.ctx.lineWidth = 2 * this.scale;
    this.ctx.stroke();
    
    // Y 轴
    this.ctx.beginPath();
    this.ctx.moveTo(padding, padding);
    this.ctx.lineTo(padding, this.canvas.height - padding);
    this.ctx.strokeStyle = '#333';
    this.ctx.lineWidth = 2 * this.scale;
    this.ctx.stroke();
  }
}
```

**方案 2：基于 WebGL 的高性能渲染**
```javascript
class WebGLDataVisualization {
  constructor(canvas, data) {
    this.canvas = canvas;
    this.gl = canvas.getContext('webgl');
    this.data = data;
    this.program = null;
    this.positionBuffer = null;
    this.colorBuffer = null;
    
    this.init();
  }
  
  init() {
    // 创建着色器程序
    this.createShaders();
    this.createProgram();
    
    // 创建缓冲区
    this.createBuffers();
    
    // 设置视口
    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    
    // 渲染
    this.render();
  }
  
  createShaders() {
    // 顶点着色器
    const vertexShaderSource = `
      attribute vec2 a_position;
      attribute vec3 a_color;
      uniform vec2 u_resolution;
      uniform vec2 u_offset;
      uniform float u_scale;
      varying vec3 v_color;
      
      void main() {
        vec2 position = (a_position * u_scale + u_offset) / u_resolution * 2.0 - 1.0;
        gl_Position = vec4(position, 0.0, 1.0);
        gl_PointSize = 5.0;
        v_color = a_color;
      }
    `;
    
    // 片段着色器
    const fragmentShaderSource = `
      precision mediump float;
      varying vec3 v_color;
      
      void main() {
        gl_FragColor = vec4(v_color, 1.0);
      }
    `;
    
    this.vertexShader = this.compileShader(this.gl.VERTEX_SHADER, vertexShaderSource);
    this.fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
  }
  
  compileShader(type, source) {
    const shader = this.gl.createShader(type);
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
      this.gl.deleteShader(shader);
      return null;
    }
    
    return shader;
  }
  
  createProgram() {
    this.program = this.gl.createProgram();
    this.gl.attachShader(this.program, this.vertexShader);
    this.gl.attachShader(this.program, this.fragmentShader);
    this.gl.linkProgram(this.program);
    
    if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
      console.error('Program link error:', this.gl.getProgramInfoLog(this.program));
      return;
    }
    
    this.gl.useProgram(this.program);
  }
  
  createBuffers() {
    // 位置缓冲区
    this.positionBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
    
    const positions = this.data.map(point => [point.x, point.y]).flat();
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
    
    const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
    this.gl.enableVertexAttribArray(positionLocation);
    this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
    
    // 颜色缓冲区
    this.colorBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
    
    const colors = this.data.map(point => {
      const color = point.color || [0.1, 0.57, 1.0];
      return color;
    }).flat();
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);
    
    const colorLocation = this.gl.getAttribLocation(this.program, 'a_color');
    this.gl.enableVertexAttribArray(colorLocation);
    this.gl.vertexAttribPointer(colorLocation, 3, this.gl.FLOAT, false, 0, 0);
  }
  
  render() {
    this.gl.clearColor(1.0, 1.0, 1.0, 1.0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    
    // 设置 uniform 变量
    const resolutionLocation = this.gl.getUniformLocation(this.program, 'u_resolution');
    this.gl.uniform2f(resolutionLocation, this.canvas.width, this.canvas.height);
    
    const offsetLocation = this.gl.getUniformLocation(this.program, 'u_offset');
    this.gl.uniform2f(offsetLocation, 0, 0);
    
    const scaleLocation = this.gl.getUniformLocation(this.program, 'u_scale');
    this.gl.uniform1f(scaleLocation, 1.0);
    
    // 绘制点
    this.gl.drawArrays(this.gl.POINTS, 0, this.data.length);
  }
}
```

**方案 3：基于 Web Workers 的数据处理**
```javascript
// 主线程
class DataVisualizationWithWorkers {
  constructor(canvas, data) {
    this.canvas = canvas;
    this.data = data;
    this.workers = [];
    this.workerCount = navigator.hardwareConcurrency || 4;
    this.chunkSize = Math.ceil(data.length / this.workerCount);
    
    this.init();
  }
  
  init() {
    // 创建 Workers
    for (let i = 0; i < this.workerCount; i++) {
      const worker = new Worker('data-worker.js');
      this.workers.push(worker);
    }
    
    // 分发数据到 Workers
    this.distributeData();
  }
  
  distributeData() {
    const promises = this.workers.map((worker, index) => {
      const start = index * this.chunkSize;
      const end = Math.min(start + this.chunkSize, this.data.length);
      const chunk = this.data.slice(start, end);
      
      return new Promise((resolve) => {
        worker.onmessage = (e) => {
          resolve(e.data);
        };
        
        worker.postMessage({
          type: 'process',
          data: chunk,
          config: {
            filter: this.filter,
            group: this.group
          }
        });
      });
    });
    
    Promise.all(promises).then((results) => {
      const processedData = results.flat();
      this.render(processedData);
    });
  }
  
  render(data) {
    // 渲染处理后的数据
    console.log('Rendering data:', data.length, 'points');
  }
}

// data-worker.js
self.onmessage = (e) => {
  const { type, data, config } = e.data;
  
  if (type === 'process') {
    const processedData = processData(data, config);
    self.postMessage(processedData);
  }
};

function processData(data, config) {
  // 数据处理逻辑
  let result = data;
  
  if (config.filter) {
    result = result.filter(config.filter);
  }
  
  if (config.group) {
    result = groupData(result, config.group);
  }
  
  return result;
}
```

**优化技巧：**

1. **数据分片加载**
```javascript
class DataLoader {
  constructor(dataSource, chunkSize = 10000) {
    this.dataSource = dataSource;
    this.chunkSize = chunkSize;
    this.loadedChunks = 0;
    this.totalChunks = 0;
  }
  
  async loadChunks(onProgress) {
    const total = await this.getTotalCount();
    this.totalChunks = Math.ceil(total / this.chunkSize);
    
    for (let i = 0; i < this.totalChunks; i++) {
      const chunk = await this.loadChunk(i);
      onProgress(chunk, i, this.totalChunks);
      this.loadedChunks++;
    }
  }
  
  async loadChunk(index) {
    const response = await fetch(`${this.dataSource}?offset=${index * this.chunkSize}&limit=${this.chunkSize}`);
    return await response.json();
  }
  
  async getTotalCount() {
    const response = await fetch(`${this.dataSource}?count=true`);
    const data = await response.json();
    return data.count;
  }
}
```

2. **使用 OffscreenCanvas**
```javascript
class OffscreenCanvasRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.offscreen = canvas.transferControlToOffscreen();
    this.worker = new Worker('renderer-worker.js', { type: 'module' });
    this.worker.postMessage({ canvas: this.offscreen }, [this.offscreen]);
  }
  
  render(data) {
    this.worker.postMessage({ type: 'render', data });
  }
}
```

3. **使用 IndexedDB 存储大数据**
```javascript
class IndexedDBStorage {
  constructor(dbName, storeName) {
    this.dbName = dbName;
    this.storeName = storeName;
    this.db = null;
  }
  
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
          store.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }
  
  async add(data) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.add(data);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  async getAll() {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.getAll();
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}
```

---
