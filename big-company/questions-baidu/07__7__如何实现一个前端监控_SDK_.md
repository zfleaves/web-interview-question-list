# 7. 如何实现一个前端监控 SDK？

**答案：**

```javascript
class MonitorSDK {
  constructor(options = {}) {
    this.options = {
      appId: '',
      userId: '',
      enablePerformance: true,
      enableError: true,
      enableBehavior: false,
      reportUrl: '',
      sampleRate: 1,
      ...options
    };
    
    this.init();
  }
  
  init() {
    if (this.options.enablePerformance) {
      this.initPerformanceMonitor();
    }
    
    if (this.options.enableError) {
      this.initErrorMonitor();
    }
    
    if (this.options.enableBehavior) {
      this.initBehaviorMonitor();
    }
    
    setInterval(() => this.report(), 30000);
  }
  
  initPerformanceMonitor() {
    window.addEventListener('load', () => {
      const timing = performance.timing;
      const perfData = {
        type: 'performance',
        data: {
          dns: timing.domainLookupEnd - timing.domainLookupStart,
          tcp: timing.connectEnd - timing.connectStart,
          request: timing.responseEnd - timing.requestStart,
          dom: timing.domComplete - timing.domLoading,
          whiteScreen: timing.responseStart - timing.fetchStart,
          firstScreen: timing.domContentLoadedEventEnd - timing.fetchStart,
          loadPage: timing.loadEventEnd - timing.fetchStart
        }
      };
      this.collect(perfData);
    });
    
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        if (entry.entryType === 'resource') {
          this.collect({
            type: 'resource',
            data: {
              name: entry.name,
              duration: entry.duration,
              size: entry.transferSize,
              type: entry.initiatorType
            }
          });
        }
      });
    });
    
    observer.observe({ entryTypes: ['resource'] });
  }
  
  initErrorMonitor() {
    window.addEventListener('error', (event) => {
      this.collect({
        type: 'error',
        data: {
          message: event.message,
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno,
          stack: event.error?.stack
        }
      });
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      this.collect({
        type: 'promise',
        data: {
          reason: event.reason,
          promise: event.promise
        }
      });
    });
    
    window.addEventListener('error', (event) => {
      if (event.target !== window) {
        this.collect({
          type: 'resource-error',
          data: {
            tagName: event.target.tagName,
            src: event.target.src || event.target.href
          }
        });
      }
    }, true);
  }
  
  initBehaviorMonitor() {
    document.addEventListener('click', (event) => {
      const target = event.target;
      this.collect({
        type: 'click',
        data: {
          tagName: target.tagName,
          className: target.className,
          id: target.id,
          text: target.textContent?.slice(0, 50)
        }
      });
    });
    
    this.collect({
      type: 'pageview',
      data: {
        url: window.location.href,
        referrer: document.referrer
      }
    });
  }
  
  collect(data) {
    if (Math.random() > this.options.sampleRate) {
      return;
    }
    
    const reportData = {
      appId: this.options.appId,
      userId: this.options.userId,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      ...data
    };
    
    this.queue = this.queue || [];
    this.queue.push(reportData);
  }
  
  report() {
    if (!this.queue || this.queue.length === 0) {
      return;
    }
    
    const data = this.queue;
    this.queue = [];
    
    fetch(this.options.reportUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    }).catch(error => {
      console.error('Failed to report data:', error);
      this.queue = [...data, ...this.queue];
    });
  }
}
```

---
