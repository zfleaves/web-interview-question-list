# 8. 请简述 Vue.$nextTick 的实现原理

**答案：**

**Vue.$nextTick 用于在 DOM 更新完成后执行回调。**

**实现原理：**

```javascript
let callbacks = [];
let pending = false;

function flushCallbacks() {
  pending = false;
  const copies = callbacks.slice(0);
  callbacks.length = 0;
  for (let i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

let timerFunc;

if (typeof Promise !== 'undefined') {
  const p = Promise.resolve();
  timerFunc = () => {
    p.then(flushCallbacks);
  };
} else if (typeof MutationObserver !== 'undefined') {
  const observer = new MutationObserver(flushCallbacks);
  const textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = () => {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
} else {
  timerFunc = () => {
    setTimeout(flushCallbacks, 0);
  };
}

export function nextTick(cb) {
  callbacks.push(() => {
    if (cb) {
      cb();
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
}
```

**使用示例：**

```javascript
// Vue 2
new Vue({
  data: {
    message: 'Hello'
  },
  methods: {
    updateMessage() {
      this.message = 'Hello World';
      
      // DOM 还没有更新
      console.log(this.$el.textContent); // 'Hello'
      
      // 使用 nextTick 等待 DOM 更新
      this.$nextTick(() => {
        console.log(this.$el.textContent); // 'Hello World'
      });
    }
  }
});

// Vue 3
import { nextTick } from 'vue';

const { message } = toRefs(props);

function updateMessage() {
  message.value = 'Hello World';
  
  nextTick(() => {
    console.log('DOM 已更新');
  });
}
```

**为什么使用异步更新？**
- 避免频繁触发 DOM 更新
- 提高性能，批量处理更新
- 保证数据变更和 DOM 更新的顺序

**富途特色考点：**
- 富途高频考察 Vue 的异步更新机制
- 结合实际项目说明 nextTick 的应用场景
- 考察对浏览器事件循环的理解

---

## 算法题
