# 11. 股票最佳买卖时机（最多两笔交易）

**答案：**

```javascript
function maxProfit(prices) {
  if (prices.length === 0) return 0;
  
  // 初始化状态变量
  let buy1 = -prices[0];  // 第一次买入后的最大利润
  let sell1 = 0;          // 第一次卖出后的最大利润
  let buy2 = -prices[0];  // 第二次买入后的最大利润
  let sell2 = 0;          // 第二次卖出后的最大利润
  
  for (let i = 1; i < prices.length; i++) {
    // 更新第一次买入和卖出的状态
    buy1 = Math.max(buy1, -prices[i]);
    sell1 = Math.max(sell1, buy1 + prices[i]);
    
    // 更新第二次买入和卖出的状态
    buy2 = Math.max(buy2, sell1 - prices[i]);
    sell2 = Math.max(sell2, buy2 + prices[i]);
  }
  
  return sell2;
}

// 测试
console.log(maxProfit([3, 3, 5, 0, 0, 3, 1, 4])); // 6
console.log(maxProfit([1, 2, 3, 4, 5])); // 4
console.log(maxProfit([7, 6, 4, 3, 1])); // 0
```

**扩展：最多 k 笔交易**

```javascript
function maxProfitK(prices, k) {
  if (prices.length === 0 || k === 0) return 0;
  
  if (k >= prices.length / 2) {
    // 无限次交易
    let profit = 0;
    for (let i = 1; i < prices.length; i++) {
      if (prices[i] > prices[i - 1]) {
        profit += prices[i] - prices[i - 1];
      }
    }
    return profit;
  }
  
  // k 笔交易
  const dp = new Array(k + 1).fill(0).map(() => ({
    buy: -Infinity,
    sell: 0
  }));
  
  for (const price of prices) {
    for (let j = 1; j <= k; j++) {
      dp[j].buy = Math.max(dp[j].buy, dp[j - 1].sell - price);
      dp[j].sell = Math.max(dp[j].sell, dp[j].buy + price);
    }
  }
  
  return dp[k].sell;
}
```

**时间复杂度：** O(n × k)
**空间复杂度：** O(k)

**富途特色考点：**
- 富途高频考察动态规划问题
- 结合金融业务说明股票交易场景
- 考察对算法优化的理解

---

## 场景题
