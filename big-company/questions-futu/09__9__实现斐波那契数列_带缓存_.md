# 9. 实现斐波那契数列（带缓存）

**答案：**

```javascript
// 方法一：使用闭包缓存
function fibonacci() {
  const cache = {};
  
  return function(n) {
    if (n in cache) {
      return cache[n];
    }
    
    if (n <= 1) {
      return n;
    }
    
    const result = fibonacci(n - 1) + fibonacci(n - 2);
    cache[n] = result;
    return result;
  };
}

const fib = fibonacci();
console.log(fib(10)); // 55

// 方法二：使用函数原型缓存
function fibonacciWithProto(n) {
  if (n <= 1) {
    return n;
  }
  
  if (!fibonacciWithProto.cache) {
    fibonacciWithProto.cache = {};
  }
  
  if (n in fibonacciWithProto.cache) {
    return fibonacciWithProto.cache[n];
  }
  
  const result = fibonacciWithProto(n - 1) + fibonacciWithProto(n - 2);
  fibonacciWithProto.cache[n] = result;
  return result;
}

console.log(fibonacciWithProto(10)); // 55

// 方法三：使用 Map 缓存
function fibonacciWithMap(n, cache = new Map()) {
  if (n <= 1) {
    return n;
  }
  
  if (cache.has(n)) {
    return cache.get(n);
  }
  
  const result = fibonacciWithMap(n - 1, cache) + fibonacciWithMap(n - 2, cache);
  cache.set(n, result);
  return result;
}

console.log(fibonacciWithMap(10)); // 55
```

**时间复杂度分析：**
- 不带缓存：O(2^n)
- 带缓存：O(n)

**富途特色考点：**
- 富途高频考察递归和缓存优化
- 结合实际场景说明缓存的重要性
- 考察对时间复杂度的理解

---
