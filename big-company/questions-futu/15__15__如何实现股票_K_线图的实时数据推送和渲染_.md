# 15. 如何实现股票 K 线图的实时数据推送和渲染？

**答案：**

股票 K 线图是金融应用中的核心功能，需要实现实时数据推送和高效渲染。

**方案 1：使用 WebSocket 实现实时数据推送**

```javascript
class StockWebSocket {
  constructor(options = {}) {
    this.options = {
      url: 'wss://api.example.com/stocks',
      reconnectInterval: 5000,
      heartbeatInterval: 30000,
      ...options
    };
    
    this.ws = null;
    this.reconnectTimer = null;
    this.heartbeatTimer = null;
    this.listeners = new Map();
    this.isConnected = false;
  }
  
  connect() {
    this.ws = new WebSocket(this.options.url);
    
    this.ws.onopen = () => {
      console.log('WebSocket 连接已建立');
      this.isConnected = true;
      this.startHeartbeat();
      this.emit('connected');
    };
    
    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.handleMessage(data);
      } catch (error) {
        console.error('解析消息失败:', error);
      }
    };
    
    this.ws.onerror = (error) => {
      console.error('WebSocket 错误:', error);
      this.emit('error', error);
    };
    
    this.ws.onclose = () => {
      console.log('WebSocket 连接已关闭');
      this.isConnected = false;
      this.stopHeartbeat();
      this.emit('disconnected');
      this.reconnect();
    };
  }
  
  handleMessage(data) {
    switch (data.type) {
      case 'tick':
        this.emit('tick', data);
        break;
      case 'kline':
        this.emit('kline', data);
        break;
      case 'heartbeat':
        // 心跳响应
        break;
      default:
        console.warn('未知消息类型:', data.type);
    }
  }
  
  startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.isConnected) {
        this.send({ type: 'heartbeat' });
      }
    }, this.options.heartbeatInterval);
  }
  
  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  
  reconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }
    
    this.reconnectTimer = setTimeout(() => {
      console.log('尝试重新连接...');
      this.connect();
    }, this.options.reconnectInterval);
  }
  
  send(data) {
    if (this.isConnected && this.ws) {
      this.ws.send(JSON.stringify(data));
    } else {
      console.warn('WebSocket 未连接，无法发送消息');
    }
  }
  
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }
  
  off(event, callback) {
    if (this.listeners.has(event)) {
      const callbacks = this.listeners.get(event);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }
  
  emit(event, data) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(callback => {
        callback(data);
      });
    }
  }
  
  disconnect() {
    this.stopHeartbeat();
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.isConnected = false;
  }
}

// 使用
const stockWebSocket = new StockWebSocket({
  url: 'wss://api.example.com/stocks'
});

// 监听 K 线数据
stockWebSocket.on('kline', (data) => {
  console.log('收到 K 线数据:', data);
  updateKlineChart(data);
});

// 监听连接状态
stockWebSocket.on('connected', () => {
  console.log('已连接到服务器');
  // 订阅股票数据
  stockWebSocket.send({
    type: 'subscribe',
    symbols: ['AAPL', 'GOOGL', 'MSFT']
  });
});

stockWebSocket.on('disconnected', () => {
  console.log('与服务器断开连接');
});

// 连接
stockWebSocket.connect();
```

**方案 2：使用 Canvas 实现高性能 K 线图渲染**

```javascript
class KlineChart {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.options = {
      width: 800,
      height: 400,
      padding: 40,
      candleWidth: 10,
      candleGap: 2,
      ...options
    };
    
    this.data = [];
    this.init();
  }
  
  init() {
    // 设置 canvas 尺寸
    this.canvas.width = this.options.width * window.devicePixelRatio;
    this.canvas.height = this.options.height * window.devicePixelRatio;
    this.canvas.style.width = `${this.options.width}px`;
    this.canvas.style.height = `${this.options.height}px`;
    
    // 缩放上下文
    this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    
    // 监听鼠标事件
    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
    this.canvas.addEventListener('mouseleave', this.handleMouseLeave.bind(this));
  }
  
  setData(data) {
    this.data = data;
    this.render();
  }
  
  render() {
    const { width, height, padding, candleWidth, candleGap } = this.options;
    
    // 清空画布
    this.ctx.clearRect(0, 0, width, height);
    
    // 计算价格范围
    const prices = this.data.map(d => [d.high, d.low]).flat();
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    const priceRange = maxPrice - minPrice;
    
    // 绘制价格轴
    this.drawPriceAxis(minPrice, maxPrice);
    
    // 绘制 K 线
    this.data.forEach((item, index) => {
      const x = padding + index * (candleWidth + candleGap);
      
      // 计算价格对应的 Y 坐标
      const openY = height - padding - ((item.open - minPrice) / priceRange) * (height - 2 * padding);
      const closeY = height - padding - ((item.close - minPrice) / priceRange) * (height - 2 * padding);
      const highY = height - padding - ((item.high - minPrice) / priceRange) * (height - 2 * padding);
      const lowY = height - padding - ((item.low - minPrice) / priceRange) * (height - 2 * padding);
      
      // 判断涨跌
      const isUp = item.close >= item.open;
      const color = isUp ? '#26a69a' : '#ef5350';
      
      // 绘制影线
      this.ctx.strokeStyle = color;
      this.ctx.lineWidth = 1;
      this.ctx.beginPath();
      this.ctx.moveTo(x + candleWidth / 2, highY);
      this.ctx.lineTo(x + candleWidth / 2, lowY);
      this.ctx.stroke();
      
      // 绘制实体
      this.ctx.fillStyle = color;
      const bodyTop = Math.min(openY, closeY);
      const bodyHeight = Math.abs(closeY - openY) || 1; // 至少 1px
      
      if (isUp) {
        this.ctx.fillRect(x, bodyTop, candleWidth, bodyHeight);
      } else {
        this.ctx.fillRect(x, bodyTop, candleWidth, bodyHeight);
      }
    });
  }
  
  drawPriceAxis(minPrice, maxPrice) {
    const { height, padding } = this.options;
    
    // 绘制价格标签
    const priceStep = (maxPrice - minPrice) / 5;
    
    this.ctx.fillStyle = '#666';
    this.ctx.font = '12px Arial';
    this.ctx.textAlign = 'right';
    
    for (let i = 0; i <= 5; i++) {
      const price = minPrice + i * priceStep;
      const y = height - padding - (i / 5) * (height - 2 * padding);
      
      this.ctx.fillText(price.toFixed(2), padding - 5, y + 4);
      
      // 绘制水平线
      this.ctx.strokeStyle = '#e0e0e0';
      this.ctx.beginPath();
      this.ctx.moveTo(padding, y);
      this.ctx.lineTo(this.options.width - padding, y);
      this.ctx.stroke();
    }
  }
  
  handleMouseMove(event) {
    const rect = this.canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    // 计算鼠标对应的 K 线索引
    const { padding, candleWidth, candleGap } = this.options;
    const index = Math.floor((x - padding) / (candleWidth + candleGap));
    
    if (index >= 0 && index < this.data.length) {
      const item = this.data[index];
      this.showTooltip(event.clientX, event.clientY, item);
    }
  }
  
  handleMouseLeave() {
    this.hideTooltip();
  }
  
  showTooltip(x, y, item) {
    // 显示提示信息
    console.log('K 线信息:', item);
  }
  
  hideTooltip() {
    // 隐藏提示信息
  }
}

// 使用
const canvas = document.getElementById('kline-chart');
const klineChart = new KlineChart(canvas);

// 模拟数据
const klineData = [
  { time: '09:30', open: 100, close: 105, high: 108, low: 98 },
  { time: '09:35', open: 105, close: 103, high: 106, low: 102 },
  { time: '09:40', open: 103, close: 108, high: 110, low: 102 },
  { time: '09:45', open: 108, close: 106, high: 109, low: 105 },
  { time: '09:50', open: 106, close: 110, high: 112, low: 105 },
];

klineChart.setData(klineData);

// 监听 WebSocket 数据
stockWebSocket.on('kline', (data) => {
  // 更新 K 线数据
  klineData.push(data);
  if (klineData.length > 100) {
    klineData.shift();
  }
  klineChart.setData(klineData);
});
```

**方案 3：使用虚拟滚动处理大量 K 线数据**

```javascript
class VirtualKlineChart extends KlineChart {
  constructor(canvas, options = {}) {
    super(canvas, options);
    this.visibleRange = { start: 0, end: 100 };
    this.scrollOffset = 0;
  }
  
  setData(data) {
    this.data = data;
    this.updateVisibleRange();
    this.render();
  }
  
  updateVisibleRange() {
    const { width, padding, candleWidth, candleGap } = this.options;
    const visibleCount = Math.floor((width - 2 * padding) / (candleWidth + candleGap));
    
    this.visibleRange.start = Math.max(0, this.scrollOffset);
    this.visibleRange.end = Math.min(this.data.length, this.scrollOffset + visibleCount);
  }
  
  render() {
    const { width, height, padding, candleWidth, candleGap } = this.options;
    
    // 清空画布
    this.ctx.clearRect(0, 0, width, height);
    
    // 只渲染可见范围内的 K 线
    const visibleData = this.data.slice(this.visibleRange.start, this.visibleRange.end);
    
    // 计算价格范围
    const prices = visibleData.map(d => [d.high, d.low]).flat();
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    const priceRange = maxPrice - minPrice;
    
    // 绘制价格轴
    this.drawPriceAxis(minPrice, maxPrice);
    
    // 绘制 K 线
    visibleData.forEach((item, index) => {
      const globalIndex = this.visibleRange.start + index;
      const x = padding + index * (candleWidth + candleGap);
      
      // 计算价格对应的 Y 坐标
      const openY = height - padding - ((item.open - minPrice) / priceRange) * (height - 2 * padding);
      const closeY = height - padding - ((item.close - minPrice) / priceRange) * (height - 2 * padding);
      const highY = height - padding - ((item.high - minPrice) / priceRange) * (height - 2 * padding);
      const lowY = height - padding - ((item.low - minPrice) / priceRange) * (height - 2 * padding);
      
      // 判断涨跌
      const isUp = item.close >= item.open;
      const color = isUp ? '#26a69a' : '#ef5350';
      
      // 绘制影线
      this.ctx.strokeStyle = color;
      this.ctx.lineWidth = 1;
      this.ctx.beginPath();
      this.ctx.moveTo(x + candleWidth / 2, highY);
      this.ctx.lineTo(x + candleWidth / 2, lowY);
      this.ctx.stroke();
      
      // 绘制实体
      this.ctx.fillStyle = color;
      const bodyTop = Math.min(openY, closeY);
      const bodyHeight = Math.abs(closeY - openY) || 1;
      
      if (isUp) {
        this.ctx.fillRect(x, bodyTop, candleWidth, bodyHeight);
      } else {
        this.ctx.fillRect(x, bodyTop, candleWidth, bodyHeight);
      }
    });
  }
  
  handleWheel(event) {
    const delta = event.deltaY > 0 ? 1 : -1;
    this.scrollOffset = Math.max(0, this.scrollOffset + delta);
    this.updateVisibleRange();
    this.render();
  }
}
```

**富途特色考点：**
- 富途高频考察金融业务场景的实现
- 结合股票交易说明实时数据推送和渲染
- 考察对 WebSocket 和 Canvas 的熟练使用
- 关注性能优化（虚拟滚动、数据缓存）

---
