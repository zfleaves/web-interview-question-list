# 大厂面试题集锦（截止 2025 年底）

## 目录

1. [腾讯面试题](#腾讯面试题)
2. [拼多多面试题](#拼多多面试题)
3. [百度面试题](#百度面试题)
4. [京东面试题](#京东面试题)
5. [字节面试题](#字节面试题)
6. [知乎面试题](#知乎面试题)

---

## 腾讯面试题

### 前端基础

#### 1. 谈谈你对前端性能优化的理解，有哪些优化手段？

**答案：**

**性能优化核心思路：**

1. **加载性能优化**（减少首屏时间）
2. **运行性能优化**（减少卡顿、提高响应速度）
3. **渲染性能优化**（提高 FPS、减少重排重绘）

**具体优化手段：**

```javascript
// 1. 资源加载优化

// 代码分割（Webpack）
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },
  },
};

// 动态导入
const Home = lazy(() => import('./Home'));
const About = lazy(() => import('./About'));

// 预加载关键资源
<link rel="preload" href="critical.css" as="style">
<link rel="prefetch" href="next-page.js">

// 2. 网络优化

// HTTP 缓存
app.use(express.static('public', {
  maxAge: '1y',
  etag: true,
  lastModified: true,
}));

// CDN 加速
const cdnUrl = 'https://cdn.example.com';
const script = document.createElement('script');
script.src = `${cdnUrl}/app.js`;

// 3. 渲染优化

// 虚拟列表
function VirtualList({ items, itemHeight, visibleCount }) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleCount, items.length);
  const visibleItems = items.slice(startIndex, endIndex);
  
  return (
    <div
      style={{ height: visibleCount * itemHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItems.map((item, i) => (
          <div
            key={startIndex + i}
            style={{
              position: 'absolute',
              top: (startIndex + i) * itemHeight,
              height: itemHeight,
            }}
          >
            {item}
          </div>
        ))}
      </div>
    </div>
  );
}

// 防抖和节流
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

function throttle(fn, delay) {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      fn.apply(this, args);
      lastCall = now;
    }
  };
}

// 4. 代码优化

// 避免内存泄漏
useEffect(() => {
  const timer = setInterval(() => {
    console.log('tick');
  }, 1000);
  
  return () => clearInterval(timer); // 清理定时器
}, []);

// 使用 useMemo 和 useCallback
function ExpensiveComponent({ items }) {
  const expensiveValue = useMemo(() => {
    return items.filter(item => item.active).reduce((sum, item) => sum + item.value, 0);
  }, [items]);
  
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);
  
  return <div onClick={handleClick}>{expensiveValue}</div>;
}
```

**监控指标：**

```javascript
// Core Web Vitals
function measureWebVitals() {
  // Largest Contentful Paint (LCP) - 最大内容绘制
  new PerformanceObserver((list) => {
    const entries = list.getEntries();
    const lastEntry = entries[entries.length - 1];
    console.log('LCP:', lastEntry.renderTime || lastEntry.loadTime);
  }).observe({ type: 'largest-contentful-paint', buffered: true });
  
  // First Input Delay (FID) - 首次输入延迟
  new PerformanceObserver((list) => {
    const entries = list.getEntries();
    entries.forEach(entry => {
      console.log('FID:', entry.processingStart - entry.startTime);
    });
  }).observe({ type: 'first-input', buffered: true });
  
  // Cumulative Layout Shift (CLS) - 累积布局偏移
  let clsValue = 0;
  new PerformanceObserver((list) => {
    const entries = list.getEntries();
    entries.forEach(entry => {
      if (!entry.hadRecentInput) {
        clsValue += entry.value;
      }
    });
    console.log('CLS:', clsValue);
  }).observe({ type: 'layout-shift', buffered: true });
}
```

---

#### 2. 如何实现一个前端监控系统？

**答案：**

**监控系统架构：**

```javascript
// 1. 错误监控
class ErrorMonitor {
  constructor(config) {
    this.config = config;
    this.init();
  }
  
  init() {
    // 捕获 JavaScript 错误
    window.addEventListener('error', this.handleError.bind(this));
    
    // 捕获 Promise 错误
    window.addEventListener('unhandledrejection', this.handlePromiseError.bind(this));
    
    // 捕获资源加载错误
    window.addEventListener('error', this.handleResourceError.bind(this), true);
    
    // 捕获 Vue 错误
    if (window.Vue) {
      Vue.config.errorHandler = this.handleVueError.bind(this);
    }
    
    // 捕获 React 错误（需要 Error Boundary）
  }
  
  handleError(event) {
    this.report({
      type: 'js_error',
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
    });
  }
  
  handlePromiseError(event) {
    this.report({
      type: 'promise_error',
      message: event.reason?.message,
      stack: event.reason?.stack,
      timestamp: Date.now(),
      url: window.location.href,
    });
  }
  
  handleResourceError(event) {
    if (event.target !== window) {
      this.report({
        type: 'resource_error',
        message: `资源加载失败: ${event.target.src || event.target.href}`,
        tagName: event.target.tagName,
        timestamp: Date.now(),
      });
    }
  }
  
  handleVueError(err, vm, info) {
    this.report({
      type: 'vue_error',
      message: err.message,
      stack: err.stack,
      component: vm?.$options?.name,
      info: info,
      timestamp: Date.now(),
    });
  }
  
  report(data) {
    // 上报到服务器
    fetch(this.config.reportUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    }).catch(err => console.error('上报失败:', err));
  }
}

// 使用
const monitor = new ErrorMonitor({
  reportUrl: 'https://monitor.example.com/api/error',
});

// 2. 性能监控
class PerformanceMonitor {
  constructor(config) {
    this.config = config;
    this.init();
  }
  
  init() {
    // 页面加载性能
    window.addEventListener('load', () => {
      setTimeout(() => this.measurePageLoad(), 0);
    });
    
    // 资源加载性能
    this.measureResources();
    
    // 用户行为监控
    this.trackUserBehavior();
  }
  
  measurePageLoad() {
    const perfData = performance.getEntriesByType('navigation')[0];
    
    const metrics = {
      // DNS 查询时间
      dns: perfData.domainLookupEnd - perfData.domainLookupStart,
      // TCP 连接时间
      tcp: perfData.connectEnd - perfData.connectStart,
      // 请求响应时间
      ttfb: perfData.responseStart - perfData.requestStart,
      // DOM 解析时间
      domParse: perfData.domComplete - perfData.domInteractive,
      // 资源加载时间
      resourceLoad: perfData.loadEventStart - perfData.domContentLoadedEventEnd,
      // 首屏时间
      firstPaint: this.getFirstPaint(),
      // 可交互时间
      tti: this.getTimeToInteractive(),
    };
    
    this.report({
      type: 'page_performance',
      metrics,
      timestamp: Date.now(),
      url: window.location.href,
    });
  }
  
  getFirstPaint() {
    const paintEntries = performance.getEntriesByType('paint');
    const firstPaint = paintEntries.find(entry => entry.name === 'first-paint');
    return firstPaint ? firstPaint.startTime : 0;
  }
  
  getTimeToInteractive() {
    // 使用 PerformanceObserver 监听 TTI
    return new Promise((resolve) => {
      if (window.PerformanceObserver) {
        const observer = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const tti = entries[0]?.startTime || 0;
          resolve(tti);
        });
        observer.observe({ type: 'longtask', buffered: true });
      } else {
        resolve(0);
      }
    });
  }
  
  measureResources() {
    const resources = performance.getEntriesByType('resource');
    
    const slowResources = resources.filter(resource => {
      return resource.duration > 1000; // 超过 1 秒的慢资源
    });
    
    if (slowResources.length > 0) {
      this.report({
        type: 'slow_resources',
        resources: slowResources.map(r => ({
          name: r.name,
          duration: r.duration,
          size: r.transferSize,
        })),
        timestamp: Date.now(),
      });
    }
  }
  
  trackUserBehavior() {
    // 点击事件
    document.addEventListener('click', (e) => {
      this.report({
        type: 'click',
        target: e.target.tagName,
        className: e.target.className,
        id: e.target.id,
        timestamp: Date.now(),
      });
    });
    
    // 页面停留时间
    const startTime = Date.now();
    window.addEventListener('beforeunload', () => {
      const duration = Date.now() - startTime;
      this.report({
        type: 'page_view_duration',
        duration,
        url: window.location.href,
      });
    });
  }
  
  report(data) {
    // 使用 sendBeacon 确保页面关闭时也能上报
    if (navigator.sendBeacon) {
      const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
      navigator.sendBeacon(this.config.reportUrl, blob);
    } else {
      fetch(this.config.reportUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
    }
  }
}

// 使用
const perfMonitor = new PerformanceMonitor({
  reportUrl: 'https://monitor.example.com/api/performance',
});
```

---

### 算法题

#### 3. 实现一个 LRU 缓存

**答案：**

```javascript
// 使用 Map 实现 O(1) 时间复杂度
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    // 重新设置以更新访问顺序
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    
    return value;
  }
  
  put(key, value) {
    if (this.cache.has(key)) {
      // 更新现有 key
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // 删除最久未使用的（第一个）
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
  }
}

// 使用
const lru = new LRUCache(2);
lru.put(1, 'a');
lru.put(2, 'b');
console.log(lru.get(1)); // 'a'
lru.put(3, 'c'); // 删除 key 2
console.log(lru.get(2)); // -1

// 扩展：实现带过期时间的 LRU
class LRUCacheWithTTL {
  constructor(capacity, ttl = 60000) {
    this.capacity = capacity;
    this.ttl = ttl;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    const item = this.cache.get(key);
    
    // 检查是否过期
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return -1;
    }
    
    // 更新访问时间和顺序
    this.cache.delete(key);
    this.cache.set(key, { ...item, timestamp: Date.now() });
    
    return item.value;
  }
  
  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, {
      value,
      timestamp: Date.now(),
    });
  }
  
  // 清理过期项
  cleanExpired() {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
  }
}
```

**场景应用：**

```javascript
// 前端图片缓存
class ImageCache {
  constructor(maxSize = 20, ttl = 3600000) { // 1小时
    this.cache = new LRUCacheWithTTL(maxSize, ttl);
  }
  
  async loadImage(url) {
    // 检查缓存
    const cached = this.cache.get(url);
    if (cached !== -1) {
      return cached;
    }
    
    // 加载图片
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        this.cache.put(url, img.src);
        resolve(img.src);
      };
      img.onerror = reject;
      img.src = url;
    });
  }
}

// API 响应缓存
class APICache {
  constructor(maxSize = 50, ttl = 300000) { // 5分钟
    this.cache = new LRUCacheWithTTL(maxSize, ttl);
  }
  
  async fetch(url, options = {}) {
    const cacheKey = `${url}_${JSON.stringify(options)}`;
    
    // 检查缓存
    const cached = this.cache.get(cacheKey);
    if (cached !== -1) {
      return cached;
    }
    
    // 发起请求
    const response = await fetch(url, options);
    const data = await response.json();
    
    // 缓存结果
    this.cache.put(cacheKey, data);
    
    return data;
  }
}
```

---

#### 4. 实现一个防抖函数，支持立即执行

**答案：**

```javascript
// 基础防抖
function debounce(fn, delay) {
  let timer = null;
  
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 支持立即执行的防抖
function debounce(fn, delay, immediate = false) {
  let timer = null;
  let isInvoked = false;
  
  return function(...args) {
    const context = this;
    
    const later = () => {
      timer = null;
      if (!immediate && !isInvoked) {
        fn.apply(context, args);
      }
      isInvoked = false;
    };
    
    const callNow = immediate && !timer;
    
    clearTimeout(timer);
    timer = setTimeout(later, delay);
    
    if (callNow) {
      isInvoked = true;
      fn.apply(context, args);
    }
  };
}

// 使用示例
const debouncedSearch = debounce(function(query) {
  console.log('搜索:', query);
}, 300, false);

// 立即执行版本
const debouncedSubmit = debounce(function(data) {
  console.log('提交:', data);
}, 1000, true);

// 扩展：支持取消
function debounce(fn, delay, immediate = false) {
  let timer = null;
  let isInvoked = false;
  
  const debounced = function(...args) {
    const context = this;
    
    const later = () => {
      timer = null;
      if (!immediate && !isInvoked) {
        fn.apply(context, args);
      }
      isInvoked = false;
    };
    
    const callNow = immediate && !timer;
    
    clearTimeout(timer);
    timer = setTimeout(later, delay);
    
    if (callNow) {
      isInvoked = true;
      fn.apply(context, args);
    }
  };
  
  // 取消防抖
  debounced.cancel = function() {
    clearTimeout(timer);
    timer = null;
    isInvoked = false;
  };
  
  // 立即执行
  debounced.flush = function() {
    if (timer) {
      clearTimeout(timer);
      fn.apply(this, arguments);
    }
  };
  
  return debounced;
}

// 使用
const debounced = debounce(function() {
  console.log('执行');
}, 1000);

debounced(); // 1秒后执行
debounced.cancel(); // 取消执行

debounced.flush(); // 立即执行
```

**场景应用：**

```javascript
// 搜索框防抖
class SearchBox {
  constructor() {
    this.input = document.getElementById('search-input');
    this.debouncedSearch = debounce(this.performSearch.bind(this), 300);
    
    this.input.addEventListener('input', (e) => {
      this.debouncedSearch(e.target.value);
    });
  }
  
  async performSearch(query) {
    if (!query.trim()) {
      this.clearResults();
      return;
    }
    
    try {
      const results = await fetch(`/api/search?q=${encodeURIComponent(query)}`)
        .then(res => res.json());
      this.displayResults(results);
    } catch (error) {
      console.error('搜索失败:', error);
    }
  }
  
  clearResults() {
    // 清空结果
  }
  
  displayResults(results) {
    // 显示结果
  }
}

// 窗口大小调整防抖
class ResponsiveLayout {
  constructor() {
    this.debouncedResize = debounce(this.handleResize.bind(this), 200);
    window.addEventListener('resize', this.debouncedResize);
    this.handleResize();
  }
  
  handleResize() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    // 根据屏幕大小调整布局
    if (width < 768) {
      this.setMobileLayout();
    } else {
      this.setDesktopLayout();
    }
  }
  
  setMobileLayout() {
    // 移动端布局
  }
  
  setDesktopLayout() {
    // 桌面端布局
  }
}

// 表单提交防抖
class FormSubmitter {
  constructor() {
    this.form = document.getElementById('my-form');
    this.debouncedSubmit = debounce(this.submitForm.bind(this), 1000, true);
    
    this.form.addEventListener('submit', (e) => {
      e.preventDefault();
      this.debouncedSubmit(new FormData(this.form));
    });
  }
  
  async submitForm(formData) {
    try {
      const response = await fetch('/api/submit', {
        method: 'POST',
        body: formData,
      });
      const result = await response.json();
      this.handleSuccess(result);
    } catch (error) {
      this.handleError(error);
    }
  }
  
  handleSuccess(result) {
    // 处理成功
  }
  
  handleError(error) {
    // 处理错误
  }
}
```

---

### 场景题

#### 5. 如何实现一个前端路由系统？

**答案：**

```javascript
// Hash 路由实现
class HashRouter {
  constructor() {
    this.routes = {};
    this.currentUrl = '';
    this.init();
  }
  
  init() {
    // 监听 hash 变化
    window.addEventListener('hashchange', this.handleHashChange.bind(this));
    window.addEventListener('load', this.handleHashChange.bind(this));
  }
  
  // 注册路由
  register(path, handler) {
    this.routes[path] = handler;
  }
  
  // 处理 hash 变化
  handleHashChange() {
    const hash = window.location.hash.slice(1) || '/';
    this.currentUrl = hash;
    this.matchRoute(hash);
  }
  
  // 路由匹配
  matchRoute(path) {
    // 精确匹配
    if (this.routes[path]) {
      this.routes[path]();
      return;
    }
    
    // 动态路由匹配
    for (const route in this.routes) {
      const params = this.matchDynamicRoute(route, path);
      if (params) {
        this.routes[route](params);
        return;
      }
    }
    
    // 404 处理
    if (this.routes['*']) {
      this.routes['*']();
    }
  }
  
  // 动态路由匹配
  matchDynamicRoute(route, path) {
    const routeParts = route.split('/');
    const pathParts = path.split('/');
    
    if (routeParts.length !== pathParts.length) {
      return null;
    }
    
    const params = {};
    
    for (let i = 0; i < routeParts.length; i++) {
      const routePart = routeParts[i];
      const pathPart = pathParts[i];
      
      if (routePart.startsWith(':')) {
        params[routePart.slice(1)] = pathPart;
      } else if (routePart !== pathPart) {
        return null;
      }
    }
    
    return params;
  }
  
  // 导航
  navigate(path) {
    window.location.hash = path;
  }
  
  // 替换
  replace(path) {
    window.location.replace(`#${path}`);
  }
  
  // 后退
  back() {
    window.history.back();
  }
  
  // 前进
  forward() {
    window.history.forward();
  }
}

// 使用
const router = new HashRouter();

router.register('/', () => {
  console.log('首页');
  renderHome();
});

router.register('/about', () => {
  console.log('关于');
  renderAbout();
});

router.register('/user/:id', (params) => {
  console.log('用户详情:', params.id);
  renderUserDetail(params.id);
});

router.register('*', () => {
  console.log('404');
  render404();
});

// History 路由实现
class HistoryRouter {
  constructor() {
    this.routes = {};
    this.init();
  }
  
  init() {
    // 监听 popstate 事件
    window.addEventListener('popstate', this.handlePopState.bind(this));
    window.addEventListener('load', this.handleLoad.bind(this));
  }
  
  register(path, handler) {
    this.routes[path] = handler;
  }
  
  handlePopState(event) {
    const path = window.location.pathname;
    this.matchRoute(path);
  }
  
  handleLoad() {
    const path = window.location.pathname;
    this.matchRoute(path);
  }
  
  matchRoute(path) {
    // 精确匹配
    if (this.routes[path]) {
      this.routes[path]();
      return;
    }
    
    // 动态路由匹配
    for (const route in this.routes) {
      const params = this.matchDynamicRoute(route, path);
      if (params) {
        this.routes[route](params);
        return;
      }
    }
    
    // 404 处理
    if (this.routes['*']) {
      this.routes['*']();
    }
  }
  
  matchDynamicRoute(route, path) {
    // 同 HashRouter 的实现
    const routeParts = route.split('/');
    const pathParts = path.split('/');
    
    if (routeParts.length !== pathParts.length) {
      return null;
    }
    
    const params = {};
    
    for (let i = 0; i < routeParts.length; i++) {
      const routePart = routeParts[i];
      const pathPart = pathParts[i];
      
      if (routePart.startsWith(':')) {
        params[routePart.slice(1)] = pathPart;
      } else if (routePart !== pathPart) {
        return null;
      }
    }
    
    return params;
  }
  
  navigate(path) {
    window.history.pushState({}, '', path);
    this.matchRoute(path);
  }
  
  replace(path) {
    window.history.replaceState({}, '', path);
    this.matchRoute(path);
  }
  
  back() {
    window.history.back();
  }
  
  forward() {
    window.history.forward();
  }
  
  // 需要服务器配置支持
  // 例如：所有路径都返回 index.html
}

// React Router 简化实现
function BrowserRouter({ children }) {
  const [location, setLocation] = useState(window.location.pathname);
  
  useEffect(() => {
    const handlePopState = () => {
      setLocation(window.location.pathname);
    };
    
    window.addEventListener('popstate', handlePopState);
    
    return () => {
      window.removeEventListener('popstate', handlePopState);
    };
  }, []);
  
  const navigate = (path) => {
    window.history.pushState({}, '', path);
    setLocation(path);
  };
  
  const routerContext = {
    location,
    navigate,
  };
  
  return (
    <RouterContext.Provider value={routerContext}>
      {children}
    </RouterContext.Provider>
  );
}

function Route({ path, component: Component }) {
  const { location } = useContext(RouterContext);
  
  const params = matchPath(path, location);
  
  if (params) {
    return <Component params={params} />;
  }
  
  return null;
}

function matchPath(routePath, currentPath) {
  const routeParts = routePath.split('/');
  const pathParts = currentPath.split('/');
  
  if (routeParts.length !== pathParts.length) {
    return null;
  }
  
  const params = {};
  
  for (let i = 0; i < routeParts.length; i++) {
    const routePart = routeParts[i];
    const pathPart = pathParts[i];
    
    if (routePart.startsWith(':')) {
      params[routePart.slice(1)] = pathPart;
    } else if (routePart !== pathPart) {
      return null;
    }
  }
  
  return params;
}

// 使用
function App() {
  return (
    <BrowserRouter>
      <Route path="/" component={Home} />
      <Route path="/about" component={About} />
      <Route path="/user/:id" component={UserDetail} />
    </BrowserRouter>
  );
}
```

---

## 拼多多面试题

### 前端基础

#### 1. 手写一个 Promise.all

**答案：**

```javascript
// Promise.all 实现
Promise.myAll = function(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }
    
    const results = [];
    let completedCount = 0;
    const length = promises.length;
    
    if (length === 0) {
      return resolve(results);
    }
    
    promises.forEach((promise, index) => {
      // 处理非 Promise 值
      Promise.resolve(promise).then(
        value => {
          results[index] = value;
          completedCount++;
          
          if (completedCount === length) {
            resolve(results);
          }
        },
        reason => {
          reject(reason);
        }
      );
    });
  });
};

// 使用
const promise1 = Promise.resolve(3);
const promise2 = 1337;
const promise3 = new Promise(resolve => setTimeout(() => resolve('foo'), 1000));

Promise.myAll([promise1, promise2, promise3])
  .then(values => console.log(values)); // [3, 1337, "foo"]

// Promise.allSettled 实现
Promise.myAllSettled = function(promises) {
  return new Promise((resolve) => {
    if (!Array.isArray(promises)) {
      return resolve([]);
    }
    
    const results = [];
    let completedCount = 0;
    const length = promises.length;
    
    if (length === 0) {
      return resolve(results);
    }
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(
        value => {
          results[index] = { status: 'fulfilled', value };
          completedCount++;
          
          if (completedCount === length) {
            resolve(results);
          }
        },
        reason => {
          results[index] = { status: 'rejected', reason };
          completedCount++;
          
          if (completedCount === length) {
            resolve(results);
          }
        }
      );
    });
  });
};

// Promise.race 实现
Promise.myRace = function(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }
    
    promises.forEach(promise => {
      Promise.resolve(promise).then(resolve, reject);
    });
  });
};

// Promise.any 实现
Promise.myAny = function(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }
    
    const errors = [];
    let rejectedCount = 0;
    const length = promises.length;
    
    if (length === 0) {
      return reject(new AggregateError([], 'All promises were rejected'));
    }
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(
        value => {
          resolve(value);
        },
        reason => {
          errors[index] = reason;
          rejectedCount++;
          
          if (rejectedCount === length) {
            reject(new AggregateError(errors, 'All promises were rejected'));
          }
        }
      );
    });
  });
};
```

**场景应用：**

```javascript
// 并发请求控制
class ConcurrencyController {
  constructor(maxConcurrency = 5) {
    this.maxConcurrency = maxConcurrency;
    this.running = 0;
    this.queue = [];
  }
  
  async run(fn) {
    if (this.running >= this.maxConcurrency) {
      await new Promise(resolve => this.queue.push(resolve));
    }
    
    this.running++;
    
    try {
      return await fn();
    } finally {
      this.running--;
      if (this.queue.length > 0) {
        const next = this.queue.shift();
        next();
      }
    }
  }
  
  async runAll(fns) {
    return Promise.all(fns.map(fn => this.run(fn)));
  }
}

// 使用
const controller = new ConcurrencyController(3);

const urls = Array.from({ length: 10 }, (_, i) => `/api/data/${i}`);

const results = await controller.runAll(
  urls.map(url => () => fetch(url).then(r => r.json()))
);

// 重试机制
async function retry(fn, maxRetries = 3, delay = 1000) {
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      if (i < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
      }
    }
  }
  
  throw lastError;
}

// 使用
const data = await retry(
  () => fetch('/api/data').then(r => r.json()),
  3,
  1000
);
```

---

#### 2. 如何实现一个前端状态管理库（类似 Vuex）？

**答案：**

```javascript
// 简化版 Vuex
class Store {
  constructor(options) {
    this.state = options.state || {};
    this.mutations = options.mutations || {};
    this.actions = options.actions || {};
    this.getters = options.getters || {};
    this._subscribers = [];
    
    // 响应式状态
    this._reactiveState = this._makeReactive(this.state);
    
    // 计算属性
    this._computedGetters = {};
    this._setupGetters();
  }
  
  // 创建响应式对象
  _makeReactive(obj) {
    const self = this;
    
    return new Proxy(obj, {
      get(target, key) {
        if (typeof target[key] === 'object' && target[key] !== null) {
          return self._makeReactive(target[key]);
        }
        return target[key];
      },
      set(target, key, value) {
        if (target[key] !== value) {
          target[key] = value;
          self._notify();
        }
        return true;
      }
    });
  }
  
  // 设置 getters
  _setupGetters() {
    for (const key in this.getters) {
      Object.defineProperty(this._computedGetters, key, {
        get: () => this.getters[key](this.state, this.getters)
      });
    }
  }
  
  // 获取 state
  get state() {
    return this._reactiveState;
  }
  
  // 获取 getters
  get getters() {
    return this._computedGetters;
  }
  
  // 提交 mutation
  commit(type, payload) {
    const mutation = this.mutations[type];
    if (mutation) {
      mutation(this.state, payload);
    } else {
      console.error(`Unknown mutation type: ${type}`);
    }
  }
  
  // 分发 action
  dispatch(type, payload) {
    const action = this.actions[type];
    if (action) {
      return action({ commit: this.commit.bind(this), state: this.state }, payload);
    } else {
      console.error(`Unknown action type: ${type}`);
    }
  }
  
  // 订阅状态变化
  subscribe(fn) {
    this._subscribers.push(fn);
    
    // 返回取消订阅函数
    return () => {
      const index = this._subscribers.indexOf(fn);
      if (index > -1) {
        this._subscribers.splice(index, 1);
      }
    };
  }
  
  // 通知订阅者
  _notify() {
    this._subscribers.forEach(fn => fn(this.state));
  }
  
  // 替换 state
  replaceState(newState) {
    this.state = this._makeReactive(newState);
    this._notify();
  }
}

// 使用
const store = new Store({
  state: {
    count: 0,
    user: null,
  },
  mutations: {
    increment(state) {
      state.count++;
    },
    decrement(state) {
      state.count--;
    },
    setUser(state, user) {
      state.user = user;
    },
  },
  actions: {
    async fetchUser({ commit }, userId) {
      const response = await fetch(`/api/users/${userId}`);
      const user = await response.json();
      commit('setUser', user);
    },
  },
  getters: {
    doubleCount(state) {
      return state.count * 2;
    },
    isLoggedIn(state) {
      return !!state.user;
    },
  },
});

// 访问 state
console.log(store.state.count); // 0

// 提交 mutation
store.commit('increment');
console.log(store.state.count); // 1

// 访问 getter
console.log(store.getters.doubleCount); // 2

// 分发 action
store.dispatch('fetchUser', 1);

// 订阅状态变化
store.subscribe((state) => {
  console.log('State changed:', state);
});

// React Hook 集成
function createStore(store) {
  const StoreContext = React.createContext();
  
  function StoreProvider({ children }) {
    return (
      <StoreContext.Provider value={store}>
        {children}
      </StoreContext.Provider>
    );
  }
  
  function useStore() {
    return useContext(StoreContext);
  }
  
  function useState() {
    const store = useStore();
    const [, forceUpdate] = useReducer(x => x + 1, 0);
    
    useEffect(() => {
      const unsubscribe = store.subscribe(() => forceUpdate());
      return unsubscribe;
    }, [store]);
    
    return store.state;
  }
  
  function useGetters() {
    const store = useStore();
    return store.getters;
  }
  
  function useActions() {
    const store = useStore();
    return {
      commit: store.commit.bind(store),
      dispatch: store.dispatch.bind(store),
    };
  }
  
  return {
    StoreProvider,
    useStore,
    useState,
    useGetters,
    useActions,
  };
}

// 使用
const { StoreProvider, useState, useGetters, useActions } = createStore(store);

function Counter() {
  const count = useState().count;
  const doubleCount = useGetters().doubleCount;
  const { commit } = useActions();
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>Double Count: {doubleCount}</p>
      <button onClick={() => commit('increment')}>+</button>
      <button onClick={() => commit('decrement')}>-</button>
    </div>
  );
}

function App() {
  return (
    <StoreProvider>
      <Counter />
    </StoreProvider>
  );
}
```

---

### 算法题

#### 3. 实现一个二叉树的遍历（前序、中序、后序、层序）

**答案：**

```javascript
// 二叉树节点定义
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

// 前序遍历（根-左-右）
function preorderTraversal(root) {
  const result = [];
  
  function traverse(node) {
    if (!node) return;
    
    result.push(node.val);
    traverse(node.left);
    traverse(node.right);
  }
  
  traverse(root);
  return result;
}

// 前序遍历（迭代）
function preorderTraversalIterative(root) {
  if (!root) return [];
  
  const result = [];
  const stack = [root];
  
  while (stack.length > 0) {
    const node = stack.pop();
    result.push(node.val);
    
    // 先压右，再压左，这样左节点先出栈
    if (node.right) stack.push(node.right);
    if (node.left) stack.push(node.left);
  }
  
  return result;
}

// 中序遍历（左-根-右）
function inorderTraversal(root) {
  const result = [];
  
  function traverse(node) {
    if (!node) return;
    
    traverse(node.left);
    result.push(node.val);
    traverse(node.right);
  }
  
  traverse(root);
  return result;
}

// 中序遍历（迭代）
function inorderTraversalIterative(root) {
  const result = [];
  const stack = [];
  let current = root;
  
  while (current || stack.length > 0) {
    // 遍历到最左边
    while (current) {
      stack.push(current);
      current = current.left;
    }
    
    // 弹出节点
    current = stack.pop();
    result.push(current.val);
    
    // 遍历右子树
    current = current.right;
  }
  
  return result;
}

// 后序遍历（左-右-根）
function postorderTraversal(root) {
  const result = [];
  
  function traverse(node) {
    if (!node) return;
    
    traverse(node.left);
    traverse(node.right);
    result.push(node.val);
  }
  
  traverse(root);
  return result;
}

// 后序遍历（迭代）
function postorderTraversalIterative(root) {
  if (!root) return [];
  
  const result = [];
  const stack = [root];
  
  while (stack.length > 0) {
    const node = stack.pop();
    result.unshift(node.val); // 头部插入
    
    if (node.left) stack.push(node.left);
    if (node.right) stack.push(node.right);
  }
  
  return result;
}

// 层序遍历（BFS）
function levelOrder(root) {
  if (!root) return [];
  
  const result = [];
  const queue = [root];
  
  while (queue.length > 0) {
    const level = [];
    const levelSize = queue.length;
    
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      level.push(node.val);
      
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    
    result.push(level);
  }
  
  return result;
}

// 使用示例
const tree = new TreeNode(1,
  new TreeNode(2,
    new TreeNode(4),
    new TreeNode(5)
  ),
  new TreeNode(3,
    null,
    new TreeNode(6)
  )
);

console.log('前序遍历:', preorderTraversal(tree)); // [1, 2, 4, 5, 3, 6]
console.log('中序遍历:', inorderTraversal(tree)); // [4, 2, 5, 1, 3, 6]
console.log('后序遍历:', postorderTraversal(tree)); // [4, 5, 2, 6, 3, 1]
console.log('层序遍历:', levelOrder(tree)); // [[1], [2, 3], [4, 5, 6]]
```

**场景应用：**

```javascript
// DOM 树遍历
function traverseDOM(node, callback) {
  if (!node) return;
  
  callback(node);
  
  for (const child of node.children) {
    traverseDOM(child, callback);
  }
}

// 查找所有文本节点
function findTextNodes(root) {
  const textNodes = [];
  
  function walk(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      textNodes.push(node);
    }
    
    for (const child of node.childNodes) {
      walk(child);
    }
  }
  
  walk(root);
  return textNodes;
}

// 查找所有包含特定文本的元素
function findElementsByText(root, text) {
  const elements = [];
  
  function walk(node) {
    if (node.nodeType === Node.ELEMENT_NODE) {
      if (node.textContent.includes(text)) {
        elements.push(node);
      }
    }
    
    for (const child of node.childNodes) {
      walk(child);
    }
  }
  
  walk(root);
  return elements;
}

// 组件树遍历（React）
function traverseComponentTree(component, callback) {
  callback(component);
  
  const children = component.props?.children;
  if (children) {
    React.Children.forEach(children, child => {
      if (React.isValidElement(child)) {
        traverseComponentTree(child, callback);
      }
    });
  }
}
```

---

#### 4. 实现一个发布订阅模式

**答案：**

```javascript
// 发布订阅模式
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  // 订阅事件
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    
    this.events[event].push(listener);
    
    // 返回取消订阅函数
    return () => this.off(event, listener);
  }
  
  // 取消订阅
  off(event, listener) {
    if (!this.events[event]) return;
    
    const index = this.events[event].indexOf(listener);
    if (index > -1) {
      this.events[event].splice(index, 1);
    }
  }
  
  // 发布事件
  emit(event, ...args) {
    if (!this.events[event]) return;
    
    this.events[event].forEach(listener => {
      listener(...args);
    });
  }
  
  // 只订阅一次
  once(event, listener) {
    const onceWrapper = (...args) => {
      listener(...args);
      this.off(event, onceWrapper);
    };
    
    this.on(event, onceWrapper);
  }
  
  // 清除所有事件
  clear() {
    this.events = {};
  }
  
  // 清除特定事件的所有监听器
  clearEvent(event) {
    delete this.events[event];
  }
}

// 使用
const emitter = new EventEmitter();

// 订阅事件
const unsubscribe = emitter.on('data', (data) => {
  console.log('收到数据:', data);
});

// 发布事件
emitter.emit('data', { message: 'Hello' });

// 取消订阅
unsubscribe();

// 只订阅一次
emitter.once('init', () => {
  console.log('初始化完成');
});

// 扩展：支持命名空间
class NamespacedEventEmitter extends EventEmitter {
  constructor() {
    super();
    this.namespaces = new Map();
  }
  
  namespace(name) {
    if (!this.namespaces.has(name)) {
      this.namespaces.set(name, new EventEmitter());
    }
    return this.namespaces.get(name);
  }
  
  on(event, listener, namespace) {
    if (namespace) {
      return this.namespace(namespace).on(event, listener);
    }
    return super.on(event, listener);
  }
  
  emit(event, ...args) {
    super.emit(event, ...args);
    
    // 同时触发所有命名空间的事件
    for (const ns of this.namespaces.values()) {
      ns.emit(event, ...args);
    }
  }
}

// 使用
const emitter = new NamespacedEventEmitter();

emitter.on('click', () => console.log('全局点击'));
emitter.on('click', () => console.log('模块A点击'), 'moduleA');
emitter.on('click', () => console.log('模块B点击'), 'moduleB');

emitter.emit('click');
// 输出：
// 全局点击
// 模块A点击
// 模块B点击

// 扩展：支持异步监听器
class AsyncEventEmitter extends EventEmitter {
  async emit(event, ...args) {
    if (!this.events[event]) return [];
    
    const promises = this.events[event].map(listener => {
      try {
        return Promise.resolve(listener(...args));
      } catch (error) {
        return Promise.reject(error);
      }
    });
    
    return Promise.allSettled(promises);
  }
}

// 使用
const emitter = new AsyncEventEmitter();

emitter.on('fetch', async (url) => {
  const response = await fetch(url);
  return response.json();
});

emitter.emit('fetch', '/api/data').then(results => {
  console.log('所有请求完成:', results);
});
```

**场景应用：**

```javascript
// 跨组件通信
class EventBus {
  constructor() {
    this.events = new EventEmitter();
  }
  
  on(event, callback) {
    return this.events.on(event, callback);
  }
  
  emit(event, data) {
    this.events.emit(event, data);
  }
}

const eventBus = new EventBus();

// 组件 A
function ComponentA() {
  useEffect(() => {
    const unsubscribe = eventBus.on('user-update', (user) => {
      console.log('用户更新:', user);
    });
    
    return unsubscribe;
  }, []);
  
  return <div>Component A</div>;
}

// 组件 B
function ComponentB() {
  const handleUpdate = () => {
    eventBus.emit('user-update', { name: 'John', age: 30 });
  };
  
  return <button onClick={handleUpdate}>更新用户</button>;
}

// Redux 简化实现
function createStore(reducer, initialState) {
  let state = initialState;
  const listeners = [];
  
  function getState() {
    return state;
  }
  
  function dispatch(action) {
    state = reducer(state, action);
    listeners.forEach(listener => listener());
  }
  
  function subscribe(listener) {
    listeners.push(listener);
    
    return () => {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }
  
  return { getState, dispatch, subscribe };
}

// 使用
const store = createStore((state = { count: 0 }, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
});

store.subscribe(() => {
  console.log('State changed:', store.getState());
});

store.dispatch({ type: 'INCREMENT' });
```

---

## 百度面试题

### 前端基础

#### 1. 谈谈你对浏览器渲染原理的理解

**答案：**

**浏览器渲染流程：**

```
1. 解析 HTML → 构建 DOM 树
2. 解析 CSS → 构建 CSSOM 树
3. 合并 DOM 和 CSSOM → 构建 Render 树
4. 布局（Layout）→ 计算元素位置和大小
5. 绘制（Paint）→ 填充像素
6. 合成（Composite）→ 将图层合成到屏幕
```

**详细过程：**

```javascript
// 1. DOM 树构建
// 浏览器将 HTML 解析为 DOM 树
// <div><p>Hello</p></div>
// → DIV
//    └── P
//         └── "Hello"

// 2. CSSOM 树构建
// 浏览器将 CSS 解析为 CSSOM 树
// div { color: red; }
// p { font-size: 16px; }
// → DIV
//    ├── color: red
//    └── P
//         ├── font-size: 16px
//         └── color: red (继承)

// 3. Render 树构建
// 合并 DOM 和 CSSOM，只包含可见元素
// → DIV
//    └── P (visible)

// 4. 布局（Layout/Reflow）
// 计算每个元素的位置和大小
function layout(element) {
  // 计算元素的几何属性
  const width = element.computedStyle.width;
  const height = element.computedStyle.height;
  const x = element.parent.x + element.computedStyle.marginLeft;
  const y = element.parent.y + element.computedStyle.marginTop;
  
  element.layout = { x, y, width, height };
  
  // 递归布局子元素
  for (const child of element.children) {
    layout(child);
  }
}

// 5. 绘制（Paint）
// 将元素绘制到图层
function paint(element, layer) {
  const { x, y, width, height } = element.layout;
  
  // 绘制背景
  if (element.computedStyle.backgroundColor) {
    layer.fillRect(x, y, width, height, element.computedStyle.backgroundColor);
  }
  
  // 绘制边框
  if (element.computedStyle.border) {
    layer.strokeRect(x, y, width, height, element.computedStyle.border);
  }
  
  // 绘制文本
  if (element.textContent) {
    layer.fillText(element.textContent, x, y, element.computedStyle);
  }
  
  // 递归绘制子元素
  for (const child of element.children) {
    paint(child, layer);
  }
}

// 6. 合成（Composite）
// 将多个图层合成到屏幕
function composite(layers) {
  for (const layer of layers) {
    // 将图层绘制到屏幕
    screen.drawImage(layer);
  }
}
```

**重排（Reflow）和重绘（Repaint）：**

```javascript
// 重排：元素位置或大小变化
// 触发重排的操作：
function triggerReflow() {
  // 1. 添加/删除可见 DOM 元素
  document.body.appendChild(div);
  
  // 2. 改变元素位置
  element.style.left = '100px';
  element.style.top = '100px';
  
  // 3. 改变元素尺寸
  element.style.width = '200px';
  element.style.height = '200px';
  
  // 4. 改变元素内容
  element.textContent = 'New content';
  
  // 5. 改变浏览器窗口大小
  window.onresize = () => {
    // 触发重排
  };
  
  // 6. 读取某些属性（强制同步布局）
  const height = element.offsetHeight; // 触发重排
  const width = element.offsetWidth;
  const scrollTop = element.scrollTop;
}

// 重绘：元素外观变化但位置不变
// 触发重绘的操作：
function triggerRepaint() {
  // 1. 改变颜色
  element.style.color = 'red';
  element.style.backgroundColor = 'blue';
  
  // 2. 改变背景
  element.style.backgroundImage = 'url(...)';
  
  // 3. 改变边框
  element.style.border = '1px solid red';
  
  // 4. 改变阴影
  element.style.boxShadow = '0 0 10px black';
}

// 优化：避免强制同步布局
// ❌ 不好的做法
function badExample() {
  for (let i = 0; i < 100; i++) {
    const height = element.offsetHeight; // 每次都触发重排
    element.style.height = height + 10 + 'px';
  }
}

// ✅ 好的做法
function goodExample() {
  const height = element.offsetHeight; // 只触发一次重排
  for (let i = 0; i < 100; i++) {
    element.style.height = height + 10 * i + 'px';
  }
}

// 使用 requestAnimationFrame 优化
function optimizedAnimation() {
  let start = null;
  
  function animate(timestamp) {
    if (!start) start = timestamp;
    const progress = timestamp - start;
    
    element.style.transform = `translateX(${progress}px)`;
    
    if (progress < 1000) {
      requestAnimationFrame(animate);
    }
  }
  
  requestAnimationFrame(animate);
}
```

**性能优化：**

```javascript
// 1. 使用 transform 和 opacity 代替位置和显示变化
// ❌ 会触发重排
element.style.left = '100px';
element.style.display = 'none';

// ✅ 只触发合成
element.style.transform = 'translateX(100px)';
element.style.opacity = '0';

// 2. 批量 DOM 操作
// ❌ 多次操作
function badDOMManipulation() {
  const container = document.getElementById('container');
  
  for (let i = 0; i < 1000; i++) {
    const div = document.createElement('div');
    div.textContent = `Item ${i}`;
    container.appendChild(div); // 每次都触发重排
  }
}

// ✅ 使用文档片段
function goodDOMManipulation() {
  const container = document.getElementById('container');
  const fragment = document.createDocumentFragment();
  
  for (let i = 0; i < 1000; i++) {
    const div = document.createElement('div');
    div.textContent = `Item ${i}`;
    fragment.appendChild(div);
  }
  
  container.appendChild(fragment); // 只触发一次重排
}

// 3. 使用虚拟 DOM
function virtualDOMExample() {
  // React/Vue 等框架使用虚拟 DOM
  // 只在必要时更新真实 DOM
}

// 4. 使用 will-change 提示浏览器优化
element.style.willChange = 'transform, opacity';

// 5. 使用 CSS containment
.element {
  contain: layout;
}
```

---

#### 2. 如何实现一个前端构建工具（类似 Webpack）？

**答案：**

```javascript
// 简化版 Webpack
class MiniWebpack {
  constructor(options) {
    this.entry = options.entry;
    this.output = options.output;
    this.modules = [];
  }
  
  // 解析文件
  parse(filename) {
    const content = fs.readFileSync(filename, 'utf-8');
    
    // 解析依赖
    const dependencies = [];
    const ast = parser.parse(content, {
      sourceType: 'module',
    });
    
    traverse(ast, {
      ImportDeclaration({ node }) {
        dependencies.push(node.source.value);
      },
    });
    
    // 转换代码
    const { code } = babel.transformFromAst(ast, null, {
      presets: ['@babel/preset-env'],
    });
    
    return {
      filename,
      dependencies,
      code,
    };
  }
  
  // 构建依赖图
  buildDependencyGraph(entry) {
    const entryModule = this.parse(entry);
    const queue = [entryModule];
    
    for (const module of queue) {
      const dirname = path.dirname(module.filename);
      
      module.dependencies.forEach(relativePath => {
        const absolutePath = path.join(dirname, relativePath);
        const child = this.parse(absolutePath);
        this.modules.push(child);
        queue.push(child);
      });
    }
  }
  
  // 生成代码
  generate() {
    const modulesStr = this.modules
      .map(module => {
        return `${JSON.stringify(module.filename)}: function(module, exports, require) {
          ${module.code}
        }`;
      })
      .join(',\n');
    
    return `
      (function(modules) {
        const installedModules = {};
        
        function require(filename) {
          if (installedModules[filename]) {
            return installedModules[filename].exports;
          }
          
          const module = installedModules[filename] = {
            exports: {},
          };
          
          modules[filename](module, module.exports, require);
          
          return module.exports;
        }
        
        require('${this.entry}');
      })({
        ${modulesStr}
      });
    `;
  }
  
  // 运行
  run() {
    this.buildDependencyGraph(this.entry);
    const code = this.generate();
    
    fs.writeFileSync(this.output.path, code);
  }
}

// 使用
const webpack = new MiniWebpack({
  entry: './src/index.js',
  output: {
    path: './dist/bundle.js',
  },
});

webpack.run();

// 扩展：支持 Loader
class MiniWebpack {
  constructor(options) {
    this.entry = options.entry;
    this.output = options.output;
    this.modules = [];
    this.loaders = options.loaders || [];
  }
  
  // 应用 Loader
  applyLoaders(content, filename) {
    for (const loader of this.loaders) {
      if (loader.test.test(filename)) {
        content = loader.loader(content);
      }
    }
    return content;
  }
  
  parse(filename) {
    let content = fs.readFileSync(filename, 'utf-8');
    
    // 应用 Loader
    content = this.applyLoaders(content, filename);
    
    // 其余解析逻辑...
  }
}

// 使用
const webpack = new MiniWebpack({
  entry: './src/index.js',
  output: {
    path: './dist/bundle.js',
  },
  loaders: [
    {
      test: /\.css$/,
      loader: (content) => {
        // CSS Loader
        return `
          const style = document.createElement('style');
          style.textContent = ${JSON.stringify(content)};
          document.head.appendChild(style);
        `;
      },
    },
  ],
});

// 扩展：支持 Plugin
class MiniWebpack {
  constructor(options) {
    this.entry = options.entry;
    this.output = options.output;
    this.modules = [];
    this.plugins = options.plugins || [];
  }
  
  applyPlugins(compilation) {
    this.plugins.forEach(plugin => {
      plugin.apply(compilation);
    });
  }
  
  build() {
    const compilation = {
      modules: this.modules,
      assets: {},
    };
    
    this.buildDependencyGraph(this.entry);
    const code = this.generate();
    
    compilation.assets[this.output.path] = {
      source: () => code,
      size: () => code.length,
    };
    
    this.applyPlugins(compilation);
    
    // 写入文件
    for (const filename in compilation.assets) {
      const asset = compilation.assets[filename];
      fs.writeFileSync(filename, asset.source());
    }
  }
}

// 使用
class MyPlugin {
  apply(compilation) {
    compilation.hooks.done.tap('MyPlugin', () => {
      console.log('构建完成！');
    });
  }
}

const webpack = new MiniWebpack({
  entry: './src/index.js',
  output: {
    path: './dist/bundle.js',
  },
  plugins: [new MyPlugin()],
});
```

---

### 算法题

#### 3. 实现一个快速排序

**答案：**

```javascript
// 快速排序
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  
  const pivot = arr[0];
  const left = [];
  const right = [];
  
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  
  return [...quickSort(left), pivot, ...quickSort(right)];
}

// 原地快速排序（优化空间）
function quickSortInPlace(arr, left = 0, right = arr.length - 1) {
  if (left >= right) {
    return;
  }
  
  const pivotIndex = partition(arr, left, right);
  
  quickSortInPlace(arr, left, pivotIndex - 1);
  quickSortInPlace(arr, pivotIndex + 1, right);
}

function partition(arr, left, right) {
  const pivot = arr[right];
  let i = left;
  
  for (let j = left; j < right; j++) {
    if (arr[j] < pivot) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      i++;
    }
  }
  
  [arr[i], arr[right]] = [arr[right], arr[i]];
  return i;
}

// 优化：三路快速排序（处理重复元素）
function quickSort3Way(arr, left = 0, right = arr.length - 1) {
  if (left >= right) {
    return;
  }
  
  let pivot = arr[left];
  let lt = left;     // 小于 pivot 的边界
  let gt = right;    // 大于 pivot 的边界
  let i = left + 1;  // 当前元素
  
  while (i <= gt) {
    if (arr[i] < pivot) {
      [arr[i], arr[lt]] = [arr[lt], arr[i]];
      lt++;
      i++;
    } else if (arr[i] > pivot) {
      [arr[i], arr[gt]] = [arr[gt], arr[i]];
      gt--;
    } else {
      i++;
    }
  }
  
  quickSort3Way(arr, left, lt - 1);
  quickSort3Way(arr, gt + 1, right);
}

// 优化：随机选择 pivot
function quickSortRandom(arr, left = 0, right = arr.length - 1) {
  if (left >= right) {
    return;
  }
  
  // 随机选择 pivot
  const randomIndex = Math.floor(Math.random() * (right - left + 1)) + left;
  [arr[left], arr[randomIndex]] = [arr[randomIndex], arr[left]];
  
  const pivotIndex = partition(arr, left, right);
  
  quickSortRandom(arr, left, pivotIndex - 1);
  quickSortRandom(arr, pivotIndex + 1, right);
}

// 使用示例
const arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
console.log('原始数组:', arr);

console.log('快速排序:', quickSort([...arr]));
console.log('原地快速排序:', quickSortInPlace([...arr]));
console.log('三路快速排序:', quickSort3Way([...arr]));
console.log('随机快速排序:', quickSortRandom([...arr]));

// 性能测试
function testSort(sortFn, arr) {
  const start = performance.now();
  sortFn(arr);
  const end = performance.now();
  return end - start;
}

const largeArr = Array.from({ length: 10000 }, () => Math.random());
console.log('快速排序耗时:', testSort(quickSortInPlace, [...largeArr]));
```

**场景应用：**

```javascript
// 对象数组排序
function sortByKey(arr, key) {
  return quickSort(arr.map(item => item[key]))
    .map(value => arr.find(item => item[key] === value));
}

const users = [
  { id: 3, name: 'Alice' },
  { id: 1, name: 'Bob' },
  { id: 2, name: 'Charlie' },
];

console.log('按 ID 排序:', sortByKey(users, 'id'));

// 多条件排序
function multiSort(arr, compareFn) {
  return quickSort(arr, compareFn);
}

const products = [
  { price: 100, rating: 4.5 },
  { price: 200, rating: 4.0 },
  { price: 100, rating: 4.8 },
];

console.log('按价格和评分排序:', multiSort(products, (a, b) => {
  if (a.price !== b.price) {
    return a.price - b.price;
  }
  return b.rating - a.rating;
}));

// Top K 问题
function topK(arr, k) {
  if (k >= arr.length) {
    return quickSort(arr);
  }
  
  quickSortInPlace(arr);
  return arr.slice(-k);
}

const numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
console.log('Top 3:', topK([...numbers], 3));

// 使用快速选择算法优化 Top K
function quickSelect(arr, k) {
  if (k <= 0) return [];
  if (k >= arr.length) return quickSort(arr);
  
  function select(left, right, k) {
    if (left === right) {
      return arr[left];
    }
    
    const pivotIndex = partition(arr, left, right);
    
    if (k === pivotIndex) {
      return arr[k];
    } else if (k < pivotIndex) {
      return select(left, pivotIndex - 1, k);
    } else {
      return select(pivotIndex + 1, right, k);
    }
  }
  
  select(0, arr.length - 1, arr.length - k);
  return arr.slice(-k);
}

console.log('Top 3 (快速选择):', quickSelect([...numbers], 3));
```

---

#### 4. 实现一个节流函数

**答案：**

```javascript
// 基础节流
function throttle(fn, delay) {
  let lastCall = 0;
  
  return function(...args) {
    const now = Date.now();
    
    if (now - lastCall >= delay) {
      fn.apply(this, args);
      lastCall = now;
    }
  };
}

// 支持立即执行和尾随调用
function throttle(fn, delay, options = {}) {
  const { leading = true, trailing = true } = options;
  let timer = null;
  let lastCall = 0;
  
  return function(...args) {
    const now = Date.now();
    const context = this;
    
    // 首次调用
    if (!lastCall && !leading) {
      lastCall = now;
    }
    
    const remaining = delay - (now - lastCall);
    
    if (remaining <= 0) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      
      lastCall = now;
      fn.apply(context, args);
    } else if (!timer && trailing) {
      timer = setTimeout(() => {
        lastCall = leading ? Date.now() : 0;
        timer = null;
        fn.apply(context, args);
      }, remaining);
    }
  };
}

// 使用示例
const throttledScroll = throttle(function() {
  console.log('滚动事件');
}, 100);

window.addEventListener('scroll', throttledScroll);

// 立即执行版本
const throttledClick = throttle(function() {
  console.log('点击事件');
}, 1000, { leading: true, trailing: false });

// 尾随调用版本
const throttledResize = throttle(function() {
  console.log('调整大小');
}, 200, { leading: false, trailing: true });

// 扩展：支持取消
function throttle(fn, delay, options = {}) {
  const { leading = true, trailing = true } = options;
  let timer = null;
  let lastCall = 0;
  
  const throttled = function(...args) {
    const now = Date.now();
    const context = this;
    
    if (!lastCall && !leading) {
      lastCall = now;
    }
    
    const remaining = delay - (now - lastCall);
    
    if (remaining <= 0) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      
      lastCall = now;
      fn.apply(context, args);
    } else if (!timer && trailing) {
      timer = setTimeout(() => {
        lastCall = leading ? Date.now() : 0;
        timer = null;
        fn.apply(context, args);
      }, remaining);
    }
  };
  
  // 取消节流
  throttled.cancel = function() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    lastCall = 0;
  };
  
  return throttled;
}

// 使用
const throttled = throttle(function() {
  console.log('执行');
}, 1000);

throttled(); // 立即执行
throttled.cancel(); // 取消执行
```

**场景应用：**

```javascript
// 滚动加载
class InfiniteScroll {
  constructor() {
    this.throttledLoad = throttle(this.loadMore.bind(this), 200);
    window.addEventListener('scroll', this.throttledLoad);
  }
  
  loadMore() {
    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
    
    if (scrollTop + clientHeight >= scrollHeight - 100) {
      this.fetchData();
    }
  }
  
  async fetchData() {
    const response = await fetch('/api/more');
    const data = await response.json();
    this.appendData(data);
  }
  
  appendData(data) {
    // 追加数据
  }
}

// 窗口大小调整
class ResponsiveLayout {
  constructor() {
    this.throttledResize = throttle(this.handleResize.bind(this), 200);
    window.addEventListener('resize', this.throttledResize);
    this.handleResize();
  }
  
  handleResize() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    // 根据屏幕大小调整布局
    this.adjustLayout(width, height);
  }
  
  adjustLayout(width, height) {
    // 调整布局
  }
}

// 鼠标移动
class MouseTracker {
  constructor() {
    this.throttledMove = throttle(this.handleMove.bind(this), 50);
    document.addEventListener('mousemove', this.throttledMove);
  }
  
  handleMove(e) {
    const { clientX, clientY } = e;
    this.updatePosition(clientX, clientY);
  }
  
  updatePosition(x, y) {
    // 更新位置
  }
}

// 游戏循环
class Game {
  constructor() {
    this.throttledUpdate = throttle(this.update.bind(this), 16); // 60 FPS
    this.loop();
  }
  
  loop() {
    this.throttledUpdate();
    requestAnimationFrame(() => this.loop());
  }
  
  update() {
    // 更新游戏状态
  }
}
```

---

## 京东面试题

### 前端基础

#### 1. 如何实现一个前端路由守卫？

**答案：**

```javascript
// 路由守卫实现
class RouterGuard {
  constructor(router) {
    this.router = router;
    this.beforeHooks = [];
    this.afterHooks = [];
  }
  
  // 前置守卫
  beforeEach(guard) {
    this.beforeHooks.push(guard);
  }
  
  // 后置钩子
  afterEach(hook) {
    this.afterHooks.push(hook);
  }
  
  // 执行前置守卫
  async runBeforeHooks(to, from) {
    for (const guard of this.beforeHooks) {
      const result = await guard(to, from);
      
      if (result === false) {
        // 取消导航
        return false;
      }
      
      if (typeof result === 'string') {
        // 重定向
        this.router.push(result);
        return false;
      }
      
      if (result instanceof Promise) {
        const resolved = await result;
        if (resolved === false || typeof resolved === 'string') {
          if (typeof resolved === 'string') {
            this.router.push(resolved);
          }
          return false;
        }
      }
    }
    
    return true;
  }
  
  // 执行后置钩子
  runAfterHooks(to, from) {
    this.afterHooks.forEach(hook => {
      hook(to, from);
    });
  }
}

// 使用
const router = new HashRouter();
const guard = new RouterGuard(router);

// 权限检查
guard.beforeEach((to, from) => {
  const requiresAuth = to.meta?.requiresAuth;
  const isAuthenticated = checkAuth();
  
  if (requiresAuth && !isAuthenticated) {
    return '/login';
  }
});

// 页面标题
guard.afterEach((to, from) => {
  document.title = to.meta?.title || 'My App';
});

// React Router 集成
function createBrowserRouter(routes) {
  const beforeHooks = [];
  const afterHooks = [];
  
  const navigate = async (path) => {
    const to = findRoute(path);
    const from = findRoute(window.location.pathname);
    
    // 执行前置守卫
    for (const hook of beforeHooks) {
      const result = await hook(to, from);
      if (result === false) return;
      if (typeof result === 'string') {
        navigate(result);
        return;
      }
    }
    
    // 导航
    window.history.pushState({}, '', path);
    
    // 执行后置钩子
    afterHooks.forEach(hook => hook(to, from));
  };
  
  return {
    navigate,
    beforeEach: (hook) => beforeHooks.push(hook),
    afterEach: (hook) => afterHooks.push(hook),
  };
}

// 使用示例
const router = createBrowserRouter(routes);

// 登录检查
router.beforeEach((to, from) => {
  if (to.meta.requiresAuth && !isLoggedIn()) {
    return '/login';
  }
});

// 权限检查
router.beforeEach(async (to, from) => {
  const requiredPermissions = to.meta.permissions;
  if (requiredPermissions) {
    const hasPermission = await checkPermissions(requiredPermissions);
    if (!hasPermission) {
      return '/403';
    }
  }
});

// 页面标题
router.afterEach((to, from) => {
  document.title = to.meta.title || 'My App';
});

// 页面访问统计
router.afterEach((to, from) => {
  trackPageView(to.path);
});

// Vue Router 风格的守卫
class VueRouterGuard {
  constructor(router) {
    this.router = router;
    this.globalBeforeEach = [];
    this.globalAfterEach = [];
    this.routeGuards = new Map();
  }
  
  // 全局前置守卫
  beforeEach(guard) {
    this.globalBeforeEach.push(guard);
  }
  
  // 全局后置钩子
  afterEach(hook) {
    this.globalAfterEach.push(hook);
  }
  
  // 路由独享守卫
  addRouteGuard(path, guard) {
    if (!this.routeGuards.has(path)) {
      this.routeGuards.set(path, []);
    }
    this.routeGuards.get(path).push(guard);
  }
  
  // 执行守卫
  async runGuards(to, from) {
    // 全局前置守卫
    for (const guard of this.globalBeforeEach) {
      const result = await guard(to, from, this.next.bind(this));
      if (result === false) return false;
    }
    
    // 路由独享守卫
    const routeGuards = this.routeGuards.get(to.path) || [];
    for (const guard of routeGuards) {
      const result = await guard(to, from, this.next.bind(this));
      if (result === false) return false;
    }
    
    // 全局后置钩子
    for (const hook of this.globalAfterEach) {
      hook(to, from);
    }
    
    return true;
  }
  
  next(path) {
    if (typeof path === 'string') {
      this.router.push(path);
    }
  }
}

// 使用
const router = new HashRouter();
const guard = new VueRouterGuard(router);

// 全局前置守卫
guard.beforeEach((to, from, next) => {
  if (to.meta.requiresAuth && !isAuthenticated()) {
    next('/login');
  } else {
    next();
  }
});

// 路由独享守卫
guard.addRouteGuard('/admin', (to, from, next) => {
  if (isAdmin()) {
    next();
  } else {
    next('/403');
  }
});
```

---

#### 2. 如何实现一个前端日志系统？

**答案：**

```javascript
// 日志系统实现
class Logger {
  constructor(options = {}) {
    this.level = options.level || 'info';
    this.levels = {
      debug: 0,
      info: 1,
      warn: 2,
      error: 3,
    };
    this.handlers = options.handlers || [];
    this.context = options.context || {};
  }
  
  // 设置日志级别
  setLevel(level) {
    this.level = level;
  }
  
  // 添加处理器
  addHandler(handler) {
    this.handlers.push(handler);
  }
  
  // 设置上下文
  setContext(context) {
    this.context = { ...this.context, ...context };
  }
  
  // 记录日志
  log(level, message, meta = {}) {
    if (this.levels[level] < this.levels[this.level]) {
      return;
    }
    
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context: { ...this.context },
      meta,
    };
    
    this.handlers.forEach(handler => {
      handler(logEntry);
    });
  }
  
  debug(message, meta) {
    this.log('debug', message, meta);
  }
  
  info(message, meta) {
    this.log('info', message, meta);
  }
  
  warn(message, meta) {
    this.log('warn', message, meta);
  }
  
  error(message, meta) {
    this.log('error', message, meta);
  }
}

// 控制台处理器
function consoleHandler(entry) {
  const { timestamp, level, message, meta } = entry;
  const prefix = `[${timestamp}] [${level.toUpperCase()}]`;
  
  switch (level) {
    case 'debug':
      console.debug(prefix, message, meta);
      break;
    case 'info':
      console.info(prefix, message, meta);
      break;
    case 'warn':
      console.warn(prefix, message, meta);
      break;
    case 'error':
      console.error(prefix, message, meta);
      break;
  }
}

// 远程处理器
function remoteHandler(url) {
  const queue = [];
  let timer = null;
  
  return function(entry) {
    queue.push(entry);
    
    if (!timer) {
      timer = setTimeout(() => {
        fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(queue),
        }).catch(err => {
          console.error('日志上报失败:', err);
        });
        
        queue.length = 0;
        timer = null;
      }, 1000);
    }
  };
}

// 本地存储处理器
function localStorageHandler(key = 'logs') {
  return function(entry) {
    const logs = JSON.parse(localStorage.getItem(key) || '[]');
    logs.push(entry);
    
    // 只保留最近 100 条
    if (logs.length > 100) {
      logs.shift();
    }
    
    localStorage.setItem(key, JSON.stringify(logs));
  };
}

// 使用
const logger = new Logger({
  level: 'debug',
  handlers: [
    consoleHandler,
    remoteHandler('https://logs.example.com/api/logs'),
    localStorageHandler('app_logs'),
  ],
  context: {
    app: 'MyApp',
    version: '1.0.0',
  },
});

logger.info('应用启动');
logger.debug('调试信息', { userId: 123 });
logger.warn('警告信息', { action: 'delete' });
logger.error('错误信息', { error: new Error('Something went wrong') });

// 扩展：支持结构化日志
class StructuredLogger extends Logger {
  log(level, message, meta = {}) {
    if (typeof message === 'object') {
      meta = message;
      message = '';
    }
    
    super.log(level, message, meta);
  }
  
  // 记录用户行为
  logAction(action, details = {}) {
    this.info(`Action: ${action}`, {
      type: 'action',
      action,
      ...details,
    });
  }
  
  // 记录性能指标
  logPerformance(metric, value, details = {}) {
    this.info(`Performance: ${metric}`, {
      type: 'performance',
      metric,
      value,
      ...details,
    });
  }
  
  // 记录错误
  logError(error, details = {}) {
    this.error(error.message, {
      type: 'error',
      stack: error.stack,
      ...details,
    });
  }
}

// 使用
const structuredLogger = new StructuredLogger({
  level: 'info',
  handlers: [consoleHandler],
});

structuredLogger.logAction('click', { element: 'button', page: 'home' });
structuredLogger.logPerformance('FCP', 1200, { url: window.location.href });
structuredLogger.logError(new Error('API failed'), { endpoint: '/api/data' });

// React 集成
const LoggerContext = React.createContext();

function LoggerProvider({ children }) {
  const [logger] = useState(() => new Logger({
    level: 'info',
    handlers: [consoleHandler],
  }));
  
  return (
    <LoggerContext.Provider value={logger}>
      {children}
    </LoggerContext.Provider>
  );
}

function useLogger() {
  return useContext(LoggerContext);
}

function Component() {
  const logger = useLogger();
  
  const handleClick = () => {
    logger.logAction('click', { component: 'Component' });
  };
  
  return <button onClick={handleClick}>Click me</button>;
}
```

---

### 算法题

#### 3. 实现一个二分查找

**答案：**

```javascript
// 二分查找
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return -1;
}

// 递归实现
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
  if (left > right) {
    return -1;
  }
  
  const mid = Math.floor((left + right) / 2);
  
  if (arr[mid] === target) {
    return mid;
  } else if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, right);
  } else {
    return binarySearchRecursive(arr, target, left, mid - 1);
  }
}

// 查找第一个等于 target 的位置
function binarySearchFirst(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = -1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      result = mid;
      right = mid - 1; // 继续向左查找
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return result;
}

// 查找最后一个等于 target 的位置
function binarySearchLast(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = -1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      result = mid;
      left = mid + 1; // 继续向右查找
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return result;
}

// 查找第一个大于等于 target 的位置
function binarySearchLowerBound(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = arr.length;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] >= target) {
      result = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  
  return result;
}

// 查找第一个大于 target 的位置
function binarySearchUpperBound(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = arr.length;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] > target) {
      result = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  
  return result;
}

// 使用示例
const sortedArray = [1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 9];

console.log('查找 5:', binarySearch(sortedArray, 5)); // 4
console.log('第一个 5:', binarySearchFirst(sortedArray, 5)); // 4
console.log('最后一个 5:', binarySearchLast(sortedArray, 5)); // 6
console.log('第一个 >= 5:', binarySearchLowerBound(sortedArray, 5)); // 4
console.log('第一个 > 5:', binarySearchUpperBound(sortedArray, 5)); // 7
```

**场景应用：**

```javascript
// 在旋转数组中查找
function searchRotatedArray(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      return mid;
    }
    
    // 判断哪一半是有序的
    if (arr[left] <= arr[mid]) {
      // 左半部分有序
      if (arr[left] <= target && target < arr[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    } else {
      // 右半部分有序
      if (arr[mid] < target && target <= arr[right]) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
  }
  
  return -1;
}

// 查找峰值
function findPeakElement(arr) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left < right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] > arr[mid + 1]) {
      right = mid;
    } else {
      left = mid + 1;
    }
  }
  
  return left;
}

// 搜索二维矩阵
function searchMatrix(matrix, target) {
  if (!matrix.length || !matrix[0].length) {
    return false;
  }
  
  const rows = matrix.length;
  const cols = matrix[0].length;
  let left = 0;
  let right = rows * cols - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    const row = Math.floor(mid / cols);
    const col = mid % cols;
    const value = matrix[row][col];
    
    if (value === target) {
      return true;
    } else if (value < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return false;
}

// 寻找最小值（旋转数组）
function findMinInRotatedArray(arr) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left < right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] > arr[right]) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  
  return arr[left];
}
```

---

#### 4. 实现一个深拷贝

**答案：**

```javascript
// 深拷贝实现
function deepClone(obj, map = new WeakMap()) {
  // 处理基本类型
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理日期
  if (obj instanceof Date) {
    return new Date(obj);
  }
  
  // 处理正则表达式
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  
  // 处理 Map
  if (obj instanceof Map) {
    const cloned = new Map();
    obj.forEach((value, key) => {
      cloned.set(deepClone(key, map), deepClone(value, map));
    });
    return cloned;
  }
  
  // 处理 Set
  if (obj instanceof Set) {
    const cloned = new Set();
    obj.forEach(value => {
      cloned.add(deepClone(value, map));
    });
    return cloned;
  }
  
  // 处理数组
  if (Array.isArray(obj)) {
    return obj.map(item => deepClone(item, map));
  }
  
  // 处理循环引用
  if (map.has(obj)) {
    return map.get(obj);
  }
  
  // 处理普通对象
  const cloned = {};
  map.set(obj, cloned);
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone(obj[key], map);
    }
  }
  
  // 处理 Symbol
  const symbolKeys = Object.getOwnPropertySymbols(obj);
  for (const key of symbolKeys) {
    cloned[key] = deepClone(obj[key], map);
  }
  
  return cloned;
}

// 使用示例
const original = {
  name: 'Alice',
  age: 30,
  hobbies: ['reading', 'coding'],
  address: {
    city: 'Beijing',
    country: 'China',
  },
  birth: new Date('1990-01-01'),
  pattern: /test/g,
  map: new Map([['key', 'value']]),
  set: new Set([1, 2, 3]),
};

original.self = original; // 循环引用

const cloned = deepClone(original);
console.log(cloned);
console.log(cloned !== original); // true
console.log(cloned.self === cloned); // true

// 扩展：支持函数拷贝
function deepCloneWithFunction(obj, map = new WeakMap()) {
  // 处理基本类型
  if (obj === null || typeof obj !== 'object') {
    if (typeof obj === 'function') {
      // 拷贝函数
      const cloned = function(...args) {
        return obj.apply(this, args);
      };
      for (const key in obj) {
        cloned[key] = obj[key];
      }
      return cloned;
    }
    return obj;
  }
  
  // 其他类型处理同上...
  return deepClone(obj, map);
}

// 扩展：支持类实例
function deepCloneWithClass(obj, map = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理类实例
  if (obj.constructor && obj.constructor !== Object) {
    const cloned = Object.create(Object.getPrototypeOf(obj));
    map.set(obj, cloned);
    
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        cloned[key] = deepCloneWithClass(obj[key], map);
      }
    }
    
    return cloned;
  }
  
  // 其他类型处理同上...
  return deepClone(obj, map);
}

// 使用
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    console.log(`Hello, I'm ${this.name}`);
  }
}

const person = new Person('Alice', 30);
const clonedPerson = deepCloneWithClass(person);

console.log(clonedPerson instanceof Person); // true
clonedPerson.greet(); // "Hello, I'm Alice"
```

**场景应用：**

```javascript
// 状态管理中的深拷贝
function createStore(reducer, initialState) {
  let state = deepClone(initialState);
  const listeners = [];
  
  return {
    getState() {
      return deepClone(state);
    },
    dispatch(action) {
      state = reducer(state, action);
      listeners.forEach(listener => listener());
    },
    subscribe(listener) {
      listeners.push(listener);
      return () => {
        const index = listeners.indexOf(listener);
        listeners.splice(index, 1);
      };
    },
  };
}

// 表单重置
function resetForm(form, initialData) {
  const cloned = deepClone(initialData);
  Object.assign(form, cloned);
}

// 撤销/重做
class HistoryManager {
  constructor(initialState) {
    this.history = [deepClone(initialState)];
    this.currentIndex = 0;
  }
  
  push(state) {
    // 删除当前位置之后的历史
    this.history = this.history.slice(0, this.currentIndex + 1);
    this.history.push(deepClone(state));
    this.currentIndex = this.history.length - 1;
  }
  
  undo() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      return deepClone(this.history[this.currentIndex]);
    }
    return null;
  }
  
  redo() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      return deepClone(this.history[this.currentIndex]);
    }
    return null;
  }
}
```

---

## 字节面试题

### 前端基础

#### 1. 谈谈你对 React 并发模式的理解

**答案：**

**React 并发模式（Concurrent Mode）核心概念：**

```javascript
// 1. 可中断渲染
// 传统模式：同步渲染，一旦开始就不能中断
function TraditionalRendering() {
  // 执行大量计算
  const result = heavyComputation();
  
  return <div>{result}</div>;
}

// 并发模式：可中断渲染，优先处理用户交互
function ConcurrentRendering() {
  const [result, setResult] = useState(null);
  
  // 使用 startTransition 标记非紧急更新
  const handleClick = () => {
    startTransition(() => {
      setResult(heavyComputation());
    });
  };
  
  return (
    <div>
      <button onClick={handleClick}>计算</button>
      {result && <div>{result}</div>}
    </div>
  );
}

// 2. 优先级调度
// React 使用 Lane 模型来管理更新优先级
const priorities = {
  SyncLane: 1,           // 同步更新（最高优先级）
  InputContinuousLane: 2, // 连续输入
  DefaultLane: 3,        // 默认更新
  TransitionLane: 4,     // 过渡更新
  IdleLane: 5,           // 空闲更新（最低优先级）
};

// 3. useTransition Hook
function TransitionExample() {
  const [isPending, startTransition] = useTransition();
  const [filter, setFilter] = useState('');
  const [results, setResults] = useState([]);
  
  const handleSearch = (value) => {
    // 立即更新输入框
    setFilter(value);
    
    // 标记为过渡更新，可以中断
    startTransition(() => {
      const filtered = heavySearch(value);
      setResults(filtered);
    });
  };
  
  return (
    <div>
      <input
        type="text"
        value={filter}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="搜索..."
      />
      {isPending && <div>搜索中...</div>}
      <ul>
        {results.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}

// 4. useDeferredValue Hook
function DeferredValueExample() {
  const [query, setQuery] = useState('');
  
  // 延迟更新，减少频繁渲染
  const deferredQuery = useDeferredValue(query);
  
  const results = useMemo(() => {
    return heavySearch(deferredQuery);
  }, [deferredQuery]);
  
  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="搜索..."
      />
      <ul>
        {results.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}

// 5. Suspense 组件
function SuspenseExample() {
  return (
    <Suspense fallback={<div>加载中...</div>}>
      <AsyncComponent />
    </Suspense>
  );
}

async function AsyncComponent() {
  const data = await fetchData();
  return <div>{data}</div>;
}

// 6. 资源预加载
function ResourcePreloading() {
  const resource = preloadResource('/api/data');
  
  return (
    <Suspense fallback={<div>加载中...</div>}>
      <DataDisplay resource={resource} />
    </Suspense>
  );
}

function preloadResource(url) {
  let status = 'pending';
  let result;
  let suspender = fetch(url)
    .then(res => res.json())
    .then(data => {
      status = 'success';
      result = data;
    });
  
  return {
    read() {
      if (status === 'pending') {
        throw suspender;
      }
      return result;
    },
  };
}

function DataDisplay({ resource }) {
  const data = resource.read();
  return <div>{JSON.stringify(data)}</div>;
}
```

**并发模式的优势：**

```javascript
// 1. 提升用户体验
// 传统模式：长时间计算导致界面卡顿
function TraditionalList({ items }) {
  const results = items.map(item => heavyComputation(item));
  return <ul>{results.map(r => <li>{r}</li>)}</ul>;
}

// 并发模式：优先响应用户交互
function ConcurrentList({ items }) {
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  useEffect(() => {
    startTransition(() => {
      const computed = items.map(item => heavyComputation(item));
      setResults(computed);
    });
  }, [items]);
  
  return (
    <div>
      {isPending && <div>计算中...</div>}
      <ul>{results.map(r => <li>{r}</li>)}</ul>
    </div>
  );
}

// 2. 优化列表渲染
// 使用虚拟列表 + 并发模式
function VirtualizedList({ items }) {
  const [visibleItems, setVisibleItems] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const handleScroll = (e) => {
    const scrollTop = e.target.scrollTop;
    startTransition(() => {
      const newVisibleItems = computeVisibleItems(items, scrollTop);
      setVisibleItems(newVisibleItems);
    });
  };
  
  return (
    <div style={{ height: '500px', overflow: 'auto' }} onScroll={handleScroll}>
      {isPending && <div>加载中...</div>}
      {visibleItems.map(item => (
        <div key={item.id} style={{ height: '50px' }}>
          {item.name}
        </div>
      ))}
    </div>
  );
}

// 3. 优化表单输入
function OptimizedForm() {
  const [value, setValue] = useState('');
  const [suggestions, setSuggestions] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const handleChange = (e) => {
    const newValue = e.target.value;
    setValue(newValue); // 立即更新输入
    
    startTransition(() => {
      const newSuggestions = fetchSuggestions(newValue);
      setSuggestions(newSuggestions);
    });
  };
  
  return (
    <div>
      <input type="text" value={value} onChange={handleChange} />
      {isPending && <div>搜索建议中...</div>}
      <ul>
        {suggestions.map(s => (
          <li key={s.id}>{s.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

#### 2. 如何实现一个前端微前端架构？

**答案：**

```javascript
// 微前端架构实现

// 1. 基座应用（主应用）
class MicroApp {
  constructor(options) {
    this.apps = new Map();
    this.activeApp = null;
    this.container = options.container;
  }
  
  // 注册子应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      ...config,
      status: 'unmounted',
    });
  }
  
  // 启动应用
  async start() {
    // 启动默认应用
    const defaultApp = Array.from(this.apps.values())[0];
    if (defaultApp) {
      await this.loadApp(defaultApp.name);
    }
  }
  
  // 加载应用
  async loadApp(name) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    // 卸载当前应用
    if (this.activeApp && this.activeApp.name !== name) {
      await this.unloadApp(this.activeApp.name);
    }
    
    // 加载新应用
    app.status = 'loading';
    
    try {
      // 动态加载应用资源
      await this.loadResources(app);
      
      // 挂载应用
      await this.mountApp(app);
      
      app.status = 'mounted';
      this.activeApp = app;
    } catch (error) {
      app.status = 'error';
      console.error(`Failed to load app ${name}:`, error);
    }
  }
  
  // 加载资源
  async loadResources(app) {
    // 加载 JS
    if (app.js) {
      await this.loadScript(app.js);
    }
    
    // 加载 CSS
    if (app.css) {
      await this.loadStylesheet(app.css);
    }
  }
  
  // 加载脚本
  loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  
  // 加载样式
  loadStylesheet(url) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      link.onload = resolve;
      link.onerror = reject;
      document.head.appendChild(link);
    });
  }
  
  // 挂载应用
  async mountApp(app) {
    const { mount, container = this.container } = app;
    
    if (mount && typeof mount === 'function') {
      await mount(container);
    } else if (window[app.name]) {
      // 全局变量方式
      await window[app.name].mount(container);
    }
  }
  
  // 卸载应用
  async unloadApp(name) {
    const app = this.apps.get(name);
    if (!app || app.status !== 'mounted') {
      return;
    }
    
    app.status = 'unmounting';
    
    try {
      const { unmount } = app;
      
      if (unmount && typeof unmount === 'function') {
        await unmount();
      } else if (window[name]) {
        await window[name].unmount();
      }
      
      // 清理资源
      this.cleanupResources(app);
      
      app.status = 'unmounted';
    } catch (error) {
      app.status = 'error';
      console.error(`Failed to unload app ${name}:`, error);
    }
  }
  
  // 清理资源
  cleanupResources(app) {
    // 移除样式
    if (app.css) {
      const links = document.querySelectorAll(`link[href="${app.css}"]`);
      links.forEach(link => link.remove());
    }
    
    // 清空容器
    if (this.container) {
      this.container.innerHTML = '';
    }
  }
}

// 使用
const microApp = new MicroApp({
  container: document.getElementById('app'),
});

// 注册子应用
microApp.registerApp('app1', {
  name: 'app1',
  js: 'https://cdn.example.com/app1.js',
  css: 'https://cdn.example.com/app1.css',
  mount: (container) => {
    // 挂载逻辑
    container.innerHTML = '<div>App 1</div>';
  },
  unmount: () => {
    // 卸载逻辑
  },
});

microApp.registerApp('app2', {
  name: 'app2',
  js: 'https://cdn.example.com/app2.js',
  css: 'https://cdn.example.com/app2.css',
  mount: (container) => {
    container.innerHTML = '<div>App 2</div>';
  },
  unmount: () => {},
});

// 启动
microApp.start();

// 切换应用
microApp.loadApp('app2');

// 2. 通信机制
class EventBus {
  constructor() {
    this.events = new Map();
  }
  
  on(event, callback) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event).push(callback);
  }
  
  off(event, callback) {
    const callbacks = this.events.get(event);
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }
  
  emit(event, data) {
    const callbacks = this.events.get(event);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }
}

const eventBus = new EventBus();

// 子应用 A 发送消息
eventBus.emit('user-update', { id: 1, name: 'Alice' });

// 子应用 B 接收消息
eventBus.on('user-update', (data) => {
  console.log('User updated:', data);
});

// 3. 共享状态
class SharedState {
  constructor(initialState = {}) {
    this.state = initialState;
    this.listeners = new Map();
  }
  
  get(key) {
    return this.state[key];
  }
  
  set(key, value) {
    this.state[key] = value;
    this.notify(key, value);
  }
  
  subscribe(key, callback) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, []);
    }
    this.listeners.get(key).push(callback);
    
    // 返回取消订阅函数
    return () => {
      const callbacks = this.listeners.get(key);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    };
  }
  
  notify(key, value) {
    const callbacks = this.listeners.get(key);
    if (callbacks) {
      callbacks.forEach(callback => callback(value));
    }
  }
}

const sharedState = new SharedState({
  user: null,
  theme: 'light',
});

// 子应用 A 更新状态
sharedState.set('user', { id: 1, name: 'Alice' });

// 子应用 B 订阅状态
sharedState.subscribe('user', (user) => {
  console.log('User changed:', user);
});

// 4. 样式隔离
function scopedStyles(appName, styles) {
  const prefix = `[data-app="${appName}"]`;
  
  // 为每个选择器添加前缀
  const scoped = styles.replace(/([^{}]+){/g, (match) => {
    const selectors = match.slice(0, -1).split(',');
    const scopedSelectors = selectors.map(selector => {
      return `${prefix} ${selector.trim()}`;
    });
    return scopedSelectors.join(', ') + ' {';
  });
  
  return scoped;
}

// 使用
const app1Styles = `
  .container { background: white; }
  .button { color: blue; }
`;

const scopedApp1Styles = scopedStyles('app1', app1Styles);
console.log(scopedApp1Styles);
// [data-app="app1"] .container { background: white; }
// [data-app="app1"] .button { color: blue; }

// 5. 沙箱隔离
class Sandbox {
  constructor() {
    this.sandbox = Object.create(null);
    this.originalWindow = { ...window };
  }
  
  activate() {
    // 创建沙箱环境
    Object.defineProperty(this.sandbox, 'window', {
      value: this.sandbox,
      writable: false,
    });
    
    // 拦截全局变量
    const self = this;
    return new Proxy(this.sandbox, {
      get(target, prop) {
        if (prop in target) {
          return target[prop];
        }
        return self.originalWindow[prop];
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      },
    });
  }
  
  deactivate() {
    // 清理沙箱
    this.sandbox = Object.create(null);
  }
}

// 使用
const sandbox = new Sandbox();
const sandboxWindow = sandbox.activate();

// 在沙箱中执行代码
sandboxWindow.myVariable = 'test';
console.log(sandboxWindow.myVariable); // 'test'
console.log(window.myVariable); // undefined
```

---

### 算法题

#### 3. 实现一个最长公共子序列（LCS）

**答案：**

```javascript
// 最长公共子序列
function longestCommonSubsequence(text1, text2) {
  const m = text1.length;
  const n = text2.length;
  
  // 创建 DP 表
  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
  
  // 填充 DP 表
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }
  
  // 回溯找到 LCS
  const lcs = [];
  let i = m, j = n;
  
  while (i > 0 && j > 0) {
    if (text1[i - 1] === text2[j - 1]) {
      lcs.unshift(text1[i - 1]);
      i--;
      j--;
    } else if (dp[i - 1][j] > dp[i][j - 1]) {
      i--;
    } else {
      j--;
    }
  }
  
  return {
    length: dp[m][n],
    sequence: lcs.join(''),
  };
}

// 优化空间复杂度
function longestCommonSubsequenceOptimized(text1, text2) {
  const m = text1.length;
  const n = text2.length;
  
  // 只需要两行
  let prev = Array(n + 1).fill(0);
  let curr = Array(n + 1).fill(0);
  
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) {
        curr[j] = prev[j - 1] + 1;
      } else {
        curr[j] = Math.max(prev[j], curr[j - 1]);
      }
    }
    
    // 交换行
    [prev, curr] = [curr, prev];
  }
  
  return prev[n];
}

// 使用示例
const text1 = 'abcde';
const text2 = 'ace';
const result = longestCommonSubsequence(text1, text2);

console.log('LCS 长度:', result.length); // 3
console.log('LCS 序列:', result.sequence); // 'ace'

const optimizedLength = longestCommonSubsequenceOptimized(text1, text2);
console.log('优化后的 LCS 长度:', optimizedLength); // 3
```

**场景应用：**

```javascript
// 文件差异对比
function diffFiles(file1, file2) {
  const lcs = longestCommonSubsequence(file1, file2);
  
  const result = {
    added: [],
    removed: [],
    unchanged: [],
  };
  
  let i = 0, j = 0;
  for (const char of lcs.sequence) {
    // 找到相同字符之前的内容
    while (file1[i] !== char) {
      result.removed.push(file1[i]);
      i++;
    }
    while (file2[j] !== char) {
      result.added.push(file2[j]);
      j++;
    }
    
    result.unchanged.push(char);
    i++;
    j++;
  }
  
  // 处理剩余内容
  while (i < file1.length) {
    result.removed.push(file1[i]);
    i++;
  }
  while (j < file2.length) {
    result.added.push(file2[j]);
    j++;
  }
  
  return result;
}

// 字符串相似度
function stringSimilarity(str1, str2) {
  const lcsLength = longestCommonSubsequenceOptimized(str1, str2);
  const maxLength = Math.max(str1.length, str2.length);
  return lcsLength / maxLength;
}

console.log('相似度:', stringSimilarity('kitten', 'sitting')); // 0.571...

// 版本控制
function versionControl(oldVersion, newVersion) {
  const lcs = longestCommonSubsequence(oldVersion, newVersion);
  
  const changes = {
    additions: [],
    deletions: [],
  };
  
  let i = 0, j = 0;
  for (const char of lcs.sequence) {
    while (oldVersion[i] !== char) {
      changes.deletions.push({ index: i, char: oldVersion[i] });
      i++;
    }
    while (newVersion[j] !== char) {
      changes.additions.push({ index: j, char: newVersion[j] });
      j++;
    }
    i++;
    j++;
  }
  
  return changes;
}
```

---

#### 4. 实现一个 Trie（前缀树）

**答案：**

```javascript
// Trie 节点
class TrieNode {
  constructor() {
    this.children = {};
    this.isEnd = false;
    this.count = 0; // 记录经过该节点的单词数
  }
}

// Trie 实现
class Trie {
  constructor() {
    this.root = new TrieNode();
  }
  
  // 插入单词
  insert(word) {
    let node = this.root;
    
    for (const char of word) {
      if (!node.children[char]) {
        node.children[char] = new TrieNode();
      }
      node = node.children[char];
      node.count++;
    }
    
    node.isEnd = true;
  }
  
  // 搜索单词
  search(word) {
    let node = this.root;
    
    for (const char of word) {
      if (!node.children[char]) {
        return false;
      }
      node = node.children[char];
    }
    
    return node.isEnd;
  }
  
  // 搜索前缀
  startsWith(prefix) {
    let node = this.root;
    
    for (const char of prefix) {
      if (!node.children[char]) {
        return false;
      }
      node = node.children[char];
    }
    
    return true;
  }
  
  // 删除单词
  delete(word) {
    return this._deleteHelper(this.root, word, 0);
  }
  
  _deleteHelper(node, word, index) {
    if (index === word.length) {
      if (!node.isEnd) {
        return false;
      }
      node.isEnd = false;
      return Object.keys(node.children).length === 0;
    }
    
    const char = word[index];
    if (!node.children[char]) {
      return false;
    }
    
    const shouldDelete = this._deleteHelper(node.children[char], word, index + 1);
    
    if (shouldDelete) {
      delete node.children[char];
      return Object.keys(node.children).length === 0 && !node.isEnd;
    }
    
    return false;
  }
  
  // 获取所有以 prefix 开头的单词
  getWordsWithPrefix(prefix) {
    const words = [];
    let node = this.root;
    
    // 找到前缀对应的节点
    for (const char of prefix) {
      if (!node.children[char]) {
        return words;
      }
      node = node.children[char];
    }
    
    // DFS 收集所有单词
    this._collectWords(node, prefix, words);
    
    return words;
  }
  
  _collectWords(node, prefix, words) {
    if (node.isEnd) {
      words.push(prefix);
    }
    
    for (const char in node.children) {
      this._collectWords(node.children[char], prefix + char, words);
    }
  }
  
  // 统计以 prefix 开头的单词数量
  countWordsWithPrefix(prefix) {
    let node = this.root;
    
    for (const char of prefix) {
      if (!node.children[char]) {
        return 0;
      }
      node = node.children[char];
    }
    
    return node.count;
  }
}

// 使用示例
const trie = new Trie();

trie.insert('apple');
trie.insert('app');
trie.insert('application');
trie.insert('banana');

console.log('搜索 apple:', trie.search('apple')); // true
console.log('搜索 app:', trie.search('app')); // true
console.log('搜索 appl:', trie.search('appl')); // false
console.log('前缀 app:', trie.startsWith('app')); // true
console.log('前缀 ban:', trie.startsWith('ban')); // true

console.log('app 开头的单词:', trie.getWordsWithPrefix('app')); // ['app', 'apple', 'application']
console.log('app 开头的单词数:', trie.countWordsWithPrefix('app')); // 3

trie.delete('app');
console.log('删除 app 后搜索:', trie.search('app')); // false
```

**场景应用：**

```javascript
// 自动补全
class AutoComplete {
  constructor() {
    this.trie = new Trie();
  }
  
  addWord(word) {
    this.trie.insert(word);
  }
  
  getSuggestions(prefix, limit = 10) {
    const words = this.trie.getWordsWithPrefix(prefix);
    return words.slice(0, limit);
  }
}

// 使用
const autoComplete = new AutoComplete();
const dictionary = ['apple', 'application', 'apply', 'banana', 'band', 'bank'];

dictionary.forEach(word => autoComplete.addWord(word));

console.log('app 的建议:', autoComplete.getSuggestions('app'));
// ['app', 'apple', 'application', 'apply']

// 拼写检查
class SpellChecker {
  constructor(dictionary) {
    this.trie = new Trie();
    dictionary.forEach(word => this.trie.insert(word));
  }
  
  check(word) {
    return this.trie.search(word);
  }
  
  getSuggestions(word, maxDistance = 2) {
    const suggestions = [];
    this._findSuggestions(this.trie.root, '', word, suggestions, maxDistance);
    return suggestions;
  }
  
  _findSuggestions(node, current, target, suggestions, maxDistance) {
    const distance = this._editDistance(current, target);
    
    if (distance <= maxDistance && node.isEnd) {
      suggestions.push(current);
    }
    
    if (distance > maxDistance) {
      return;
    }
    
    for (const char in node.children) {
      this._findSuggestions(node.children[char], current + char, target, suggestions, maxDistance);
    }
  }
  
  _editDistance(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    
    for (let i = 0; i <= m; i++) {
      dp[i][0] = i;
    }
    for (let j = 0; j <= n; j++) {
      dp[0][j] = j;
    }
    
    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
        if (str1[i - 1] === str2[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1];
        } else {
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,    // 删除
            dp[i][j - 1] + 1,    // 插入
            dp[i - 1][j - 1] + 1 // 替换
          );
        }
      }
    }
    
    return dp[m][n];
  }
}

// 使用
const spellChecker = new SpellChecker(['apple', 'application', 'banana']);

console.log('检查 apple:', spellChecker.check('apple')); // true
console.log('检查 aple:', spellChecker.check('aple')); // false
console.log('aple 的建议:', spellChecker.getSuggestions('aple'));
// ['apple']

// IP 路由查找
class IPRouter {
  constructor() {
    this.trie = new Trie();
  }
  
  addRoute(ip, route) {
    this.trie.insert(ip);
    this.trie._routes = this.trie._routes || {};
    this.trie._routes[ip] = route;
  }
  
  findRoute(ip) {
    let node = this.trie.root;
    let longestMatch = '';
    
    for (const char of ip) {
      if (!node.children[char]) {
        break;
      }
      node = node.children[char];
      longestMatch += char;
    }
    
    return this.trie._routes?.[longestMatch] || null;
  }
}
```

---

## 知乎面试题

### 前端基础

#### 1. 如何实现一个前端富文本编辑器？

**答案：**

```javascript
// 富文本编辑器实现
class RichTextEditor {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      toolbar: true,
      placeholder: '请输入内容...',
      ...options,
    };
    
    this.init();
  }
  
  init() {
    // 创建编辑器容器
    this.editor = document.createElement('div');
    this.editor.contentEditable = true;
    this.editor.className = 'rich-text-editor';
    this.editor.setAttribute('data-placeholder', this.options.placeholder);
    
    // 创建工具栏
    if (this.options.toolbar) {
      this.toolbar = this.createToolbar();
      this.container.appendChild(this.toolbar);
    }
    
    this.container.appendChild(this.editor);
    
    // 绑定事件
    this.bindEvents();
  }
  
  createToolbar() {
    const toolbar = document.createElement('div');
    toolbar.className = 'rich-text-toolbar';
    
    const buttons = [
      { command: 'bold', icon: 'B', title: '加粗' },
      { command: 'italic', icon: 'I', title: '斜体' },
      { command: 'underline', icon: 'U', title: '下划线' },
      { command: 'strikeThrough', icon: 'S', title: '删除线' },
      { divider: true },
      { command: 'justifyLeft', icon: '←', title: '左对齐' },
      { command: 'justifyCenter', icon: '↔', title: '居中' },
      { command: 'justifyRight', icon: '→', title: '右对齐' },
      { divider: true },
      { command: 'insertUnorderedList', icon: '•', title: '无序列表' },
      { command: 'insertOrderedList', icon: '1.', title: '有序列表' },
      { divider: true },
      { command: 'createLink', icon: '🔗', title: '插入链接' },
      { command: 'insertImage', icon: '🖼️', title: '插入图片' },
    ];
    
    buttons.forEach(btn => {
      if (btn.divider) {
        const divider = document.createElement('span');
        divider.className = 'toolbar-divider';
        toolbar.appendChild(divider);
      } else {
        const button = document.createElement('button');
        button.className = 'toolbar-button';
        button.textContent = btn.icon;
        button.title = btn.title;
        button.addEventListener('click', () => this.executeCommand(btn.command));
        toolbar.appendChild(button);
      }
    });
    
    return toolbar;
  }
  
  bindEvents() {
    // 监听输入事件
    this.editor.addEventListener('input', () => {
      this.onInput();
    });
    
    // 监听选择变化
    document.addEventListener('selectionchange', () => {
      this.onSelectionChange();
    });
    
    // 监听粘贴事件
    this.editor.addEventListener('paste', (e) => {
      this.onPaste(e);
    });
  }
  
  executeCommand(command, value = null) {
    document.execCommand(command, false, value);
    this.editor.focus();
  }
  
  onInput() {
    if (this.options.onInput) {
      this.options.onInput(this.getHTML());
    }
  }
  
  onSelectionChange() {
    // 更新工具栏状态
    const commands = ['bold', 'italic', 'underline', 'strikeThrough'];
    commands.forEach(command => {
      const isActive = document.queryCommandState(command);
      this.updateToolbarButton(command, isActive);
    });
  }
  
  updateToolbarButton(command, isActive) {
    const button = this.toolbar.querySelector(`[data-command="${command}"]`);
    if (button) {
      button.classList.toggle('active', isActive);
    }
  }
  
  onPaste(e) {
    e.preventDefault();
    
    // 获取纯文本
    const text = e.clipboardData.getData('text/plain');
    document.execCommand('insertText', false, text);
  }
  
  getHTML() {
    return this.editor.innerHTML;
  }
  
  setHTML(html) {
    this.editor.innerHTML = html;
  }
  
  getText() {
    return this.editor.textContent;
  }
  
  focus() {
    this.editor.focus();
  }
  
  blur() {
    this.editor.blur();
  }
}

// 使用
const editor = new RichTextEditor(document.getElementById('editor-container'), {
  placeholder: '请输入内容...',
  onInput: (html) => {
    console.log('内容变化:', html);
  },
});

// 扩展：支持 Markdown
class MarkdownEditor extends RichTextEditor {
  constructor(container, options = {}) {
    super(container, options);
  }
  
  parseMarkdown(markdown) {
    // 简单的 Markdown 解析
    let html = markdown
      .replace(/^# (.*$)/gim, '<h1>$1</h1>')
      .replace(/^## (.*$)/gim, '<h2>$1</h2>')
      .replace(/^### (.*$)/gim, '<h3>$1</h3>')
      .replace(/\*\*(.*)\*\*/gim, '<b>$1</b>')
      .replace(/\*(.*)\*/gim, '<i>$1</i>')
      .replace(/!\[(.*?)\]\((.*?)\)/gim, '<img alt="$1" src="$2" />')
      .replace(/\[(.*?)\]\((.*?)\)/gim, '<a href="$2">$1</a>')
      .replace(/\n/gim, '<br>');
    
    return html;
  }
  
  setMarkdown(markdown) {
    const html = this.parseMarkdown(markdown);
    this.setHTML(html);
  }
}

// 扩展：支持代码高亮
class CodeHighlightEditor extends RichTextEditor {
  constructor(container, options = {}) {
    super(container, options);
  }
  
  insertCode(code, language = 'javascript') {
    const pre = document.createElement('pre');
    pre.className = `language-${language}`;
    
    const codeElement = document.createElement('code');
    codeElement.textContent = code;
    
    pre.appendChild(codeElement);
    
    this.editor.appendChild(pre);
  }
}
```

---

#### 2. 如何实现一个前端图片压缩？

**答案：**

```javascript
// 图片压缩实现
class ImageCompressor {
  constructor(options = {}) {
    this.options = {
      quality: 0.8,
      maxWidth: 1920,
      maxHeight: 1080,
      mimeType: 'image/jpeg',
      ...options,
    };
  }
  
  async compress(file) {
    return new Promise((resolve, reject) => {
      // 检查文件类型
      if (!file.type.startsWith('image/')) {
        reject(new Error('文件必须是图片'));
        return;
      }
      
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const img = new Image();
        
        img.onload = () => {
          const compressedFile = this._compressImage(img);
          resolve(compressedFile);
        };
        
        img.onerror = () => {
          reject(new Error('图片加载失败'));
        };
        
        img.src = e.target.result;
      };
      
      reader.onerror = () => {
        reject(new Error('文件读取失败'));
      };
      
      reader.readAsDataURL(file);
    });
  }
  
  _compressImage(img) {
    // 计算新尺寸
    const { width, height } = this._calculateSize(img.width, img.height);
    
    // 创建 Canvas
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    
    // 绘制图片
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, width, height);
    
    // 压缩
    const compressedDataUrl = canvas.toDataURL(this.options.mimeType, this.options.quality);
    
    // 转换为 File
    const compressedFile = this._dataURLToFile(compressedDataUrl, this.options.mimeType);
    
    return {
      file: compressedFile,
      dataUrl: compressedDataUrl,
      originalSize: img.width * img.height,
      compressedSize: width * height,
      originalFile: img.src,
    };
  }
  
  _calculateSize(width, height) {
    const { maxWidth, maxHeight } = this.options;
    
    let newWidth = width;
    let newHeight = height;
    
    // 计算缩放比例
    const ratio = Math.min(maxWidth / width, maxHeight / height);
    
    if (ratio < 1) {
      newWidth = Math.round(width * ratio);
      newHeight = Math.round(height * ratio);
    }
    
    return { width: newWidth, height: newHeight };
  }
  
  _dataURLToFile(dataURL, mimeType) {
    const arr = dataURL.split(',');
    const match = arr[0].match(/:(.*?);/);
    const mime = match ? match[1] : mimeType;
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    
    return new File([u8arr], 'compressed.jpg', { type: mime });
  }
  
  async compressMultiple(files) {
    const results = [];
    
    for (const file of files) {
      try {
        const compressed = await this.compress(file);
        results.push(compressed);
      } catch (error) {
        results.push({ error, file });
      }
    }
    
    return results;
  }
}

// 使用
const compressor = new ImageCompressor({
  quality: 0.7,
  maxWidth: 1280,
  maxHeight: 720,
});

// 压缩单张图片
compressor.compress(file).then(result => {
  console.log('压缩成功:', result);
  console.log('原始大小:', result.originalSize);
  console.log('压缩后大小:', result.compressedSize);
});

// 压缩多张图片
compressor.compressMultiple(files).then(results => {
  results.forEach((result, index) => {
    if (result.error) {
      console.error(`图片 ${index + 1} 压缩失败:`, result.error);
    } else {
      console.log(`图片 ${index + 1} 压缩成功:`, result);
    }
  });
});

// 扩展：支持裁剪
class ImageCropper {
  constructor(options = {}) {
    this.options = {
      width: 300,
      height: 300,
      ...options,
    };
  }
  
  async crop(file, cropArea) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const img = new Image();
        
        img.onload = () => {
          const croppedFile = this._cropImage(img, cropArea);
          resolve(croppedFile);
        };
        
        img.onerror = () => {
          reject(new Error('图片加载失败'));
        };
        
        img.src = e.target.result;
      };
      
      reader.onerror = () => {
        reject(new Error('文件读取失败'));
      };
      
      reader.readAsDataURL(file);
    });
  }
  
  _cropImage(img, cropArea) {
    const canvas = document.createElement('canvas');
    const { x, y, width, height } = cropArea;
    
    canvas.width = width;
    canvas.height = height;
    
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, x, y, width, height, 0, 0, width, height);
    
    const croppedDataUrl = canvas.toDataURL('image/jpeg', 1.0);
    const croppedFile = this._dataURLToFile(croppedDataUrl);
    
    return {
      file: croppedFile,
      dataUrl: croppedDataUrl,
    };
  }
  
  _dataURLToFile(dataURL) {
    const arr = dataURL.split(',');
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    
    return new File([u8arr], 'cropped.jpg', { type: 'image/jpeg' });
  }
}

// 扩展：支持水印
class WatermarkAdder {
  constructor(options = {}) {
    this.options = {
      text: 'Watermark',
      color: 'rgba(255, 255, 255, 0.5)',
      fontSize: 20,
      position: 'bottom-right',
      ...options,
    };
  }
  
  async addWatermark(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const img = new Image();
        
        img.onload = () => {
          const watermarkedFile = this._addWatermark(img);
          resolve(watermarkedFile);
        };
        
        img.onerror = () => {
          reject(new Error('图片加载失败'));
        };
        
        img.src = e.target.result;
      };
      
      reader.onerror = () => {
        reject(new Error('文件读取失败'));
      };
      
      reader.readAsDataURL(file);
    });
  }
  
  _addWatermark(img) {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    
    const ctx = canvas.getContext('2d');
    
    // 绘制原图
    ctx.drawImage(img, 0, 0);
    
    // 绘制水印
    ctx.font = `${this.options.fontSize}px Arial`;
    ctx.fillStyle = this.options.color;
    ctx.textBaseline = 'bottom';
    
    const { width, height } = canvas;
    const textWidth = ctx.measureText(this.options.text).width;
    const padding = 20;
    
    let x, y;
    
    switch (this.options.position) {
      case 'top-left':
        x = padding;
        y = padding + this.options.fontSize;
        break;
      case 'top-right':
        x = width - textWidth - padding;
        y = padding + this.options.fontSize;
        break;
      case 'bottom-left':
        x = padding;
        y = height - padding;
        break;
      case 'bottom-right':
      default:
        x = width - textWidth - padding;
        y = height - padding;
        break;
    }
    
    ctx.fillText(this.options.text, x, y);
    
    const watermarkedDataUrl = canvas.toDataURL('image/jpeg', 1.0);
    const watermarkedFile = this._dataURLToFile(watermarkedDataUrl);
    
    return {
      file: watermarkedFile,
      dataUrl: watermarkedDataUrl,
    };
  }
  
  _dataURLToFile(dataURL) {
    const arr = dataURL.split(',');
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    
    return new File([u8arr], 'watermarked.jpg', { type: 'image/jpeg' });
  }
}
```

---

### 算法题

#### 3. 实现一个布隆过滤器

**答案：**

```javascript
// 布隆过滤器实现
class BloomFilter {
  constructor(size = 1000, hashFunctions = []) {
    this.size = size;
    this.bitArray = new Array(size).fill(false);
    this.hashFunctions = hashFunctions.length > 0 
      ? hashFunctions 
      : [
          this._hash1,
          this._hash2,
          this._hash3,
        ];
  }
  
  // 添加元素
  add(element) {
    for (const hashFn of this.hashFunctions) {
      const index = hashFn.call(this, element) % this.size;
      this.bitArray[index] = true;
    }
  }
  
  // 检查元素是否存在
  contains(element) {
    for (const hashFn of this.hashFunctions) {
      const index = hashFn.call(this, element) % this.size;
      if (!this.bitArray[index]) {
        return false;
      }
    }
    return true;
  }
  
  // 哈希函数 1
  _hash1(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  
  // 哈希函数 2
  _hash2(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return Math.abs(hash);
  }
  
  // 哈希函数 3
  _hash3(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash ^ (hash >> 16);
    }
    return Math.abs(hash);
  }
}

// 使用
const bloomFilter = new BloomFilter(1000);

bloomFilter.add('apple');
bloomFilter.add('banana');
bloomFilter.add('orange');

console.log('包含 apple:', bloomFilter.contains('apple')); // true
console.log('包含 grape:', bloomFilter.contains('grape')); // false

// 扩展：支持动态扩容
class ScalableBloomFilter extends BloomFilter {
  constructor(initialSize = 1000, growthFactor = 2) {
    super(initialSize);
    this.growthFactor = growthFactor;
    this.filters = [this];
    this.currentFilter = this;
  }
  
  add(element) {
    // 检查是否需要扩容
    if (this._isFull()) {
      this._expand();
    }
    
    this.currentFilter.add(element);
  }
  
  contains(element) {
    // 检查所有过滤器
    for (const filter of this.filters) {
      if (filter.contains(element)) {
        return true;
      }
    }
    return false;
  }
  
  _isFull() {
    const trueCount = this.currentFilter.bitArray.filter(Boolean).length;
    return trueCount / this.currentFilter.size > 0.7;
  }
  
  _expand() {
    const newSize = this.currentFilter.size * this.growthFactor;
    const newFilter = new BloomFilter(newSize, this.hashFunctions);
    this.filters.push(newFilter);
    this.currentFilter = newFilter;
  }
}

// 扩展：支持删除（Counting Bloom Filter）
class CountingBloomFilter {
  constructor(size = 1000) {
    this.size = size;
    this.countArray = new Array(size).fill(0);
    this.hashFunctions = [
      this._hash1,
      this._hash2,
      this._hash3,
    ];
  }
  
  add(element) {
    for (const hashFn of this.hashFunctions) {
      const index = hashFn.call(this, element) % this.size;
      this.countArray[index]++;
    }
  }
  
  remove(element) {
    for (const hashFn of this.hashFunctions) {
      const index = hashFn.call(this, element) % this.size;
      if (this.countArray[index] > 0) {
        this.countArray[index]--;
      }
    }
  }
  
  contains(element) {
    for (const hashFn of this.hashFunctions) {
      const index = hashFn.call(this, element) % this.size;
      if (this.countArray[index] === 0) {
        return false;
      }
    }
    return true;
  }
  
  _hash1(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  
  _hash2(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) + hash) + str.charCodeAt(i);
    }
    return Math.abs(hash);
  }
  
  _hash3(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash ^ (hash >> 16);
    }
    return Math.abs(hash);
  }
}
```

**场景应用：**

```javascript
// URL 去重
class URLDeduplicator {
  constructor() {
    this.bloomFilter = new BloomFilter(10000);
  }
  
  isDuplicate(url) {
    if (this.bloomFilter.contains(url)) {
      return true;
    }
    
    this.bloomFilter.add(url);
    return false;
  }
}

// 使用
const deduplicator = new URLDeduplicator();

console.log('重复:', deduplicator.isDuplicate('https://example.com')); // false
console.log('重复:', deduplicator.isDuplicate('https://example.com')); // true

// 恶意 IP 检测
class MaliciousIPDetector {
  constructor(maliciousIPs) {
    this.bloomFilter = new BloomFilter(10000);
    maliciousIPs.forEach(ip => this.bloomFilter.add(ip));
  }
  
  isMalicious(ip) {
    return this.bloomFilter.contains(ip);
  }
}

// 使用
const detector = new MaliciousIPDetector(['192.168.1.1', '10.0.0.1']);

console.log('恶意 IP:', detector.isMalicious('192.168.1.1')); // true
console.log('恶意 IP:', detector.isMalicious('192.168.1.2')); // false

// 缓存穿透防护
class Cache {
  constructor() {
    this.cache = new Map();
    this.bloomFilter = new BloomFilter(10000);
  }
  
  get(key) {
    // 检查是否可能存在
    if (!this.bloomFilter.contains(key)) {
      return null; // 肯定不存在
    }
    
    // 检查缓存
    return this.cache.get(key) || null;
  }
  
  set(key, value) {
    this.bloomFilter.add(key);
    this.cache.set(key, value);
  }
}

// 使用
const cache = new Cache();

cache.set('user:1', { name: 'Alice' });
console.log('获取:', cache.get('user:1')); // { name: 'Alice' }
console.log('获取:', cache.get('user:2')); // null
```

---

#### 4. 实现一个一致性哈希

**答案：**

```javascript
// 一致性哈希实现
class ConsistentHash {
  constructor(virtualNodes = 150) {
    this.virtualNodes = virtualNodes;
    this.ring = new Map();
    this.sortedKeys = [];
  }
  
  // 添加节点
  addNode(node) {
    for (let i = 0; i < this.virtualNodes; i++) {
      const virtualNodeKey = `${node}:${i}`;
      const hash = this._hash(virtualNodeKey);
      this.ring.set(hash, node);
      this.sortedKeys.push(hash);
    }
    
    this.sortedKeys.sort((a, b) => a - b);
  }
  
  // 移除节点
  removeNode(node) {
    for (let i = 0; i < this.virtualNodes; i++) {
      const virtualNodeKey = `${node}:${i}`;
      const hash = this._hash(virtualNodeKey);
      this.ring.delete(hash);
      
      const index = this.sortedKeys.indexOf(hash);
      if (index > -1) {
        this.sortedKeys.splice(index, 1);
      }
    }
  }
  
  // 获取节点
  getNode(key) {
    if (this.sortedKeys.length === 0) {
      return null;
    }
    
    const hash = this._hash(key);
    
    // 二分查找
    let left = 0;
    let right = this.sortedKeys.length - 1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      
      if (this.sortedKeys[mid] === hash) {
        return this.ring.get(hash);
      } else if (this.sortedKeys[mid] < hash) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    // 如果没找到，返回第一个节点（环形）
    if (left >= this.sortedKeys.length) {
      return this.ring.get(this.sortedKeys[0]);
    }
    
    return this.ring.get(this.sortedKeys[left]);
  }
  
  // 哈希函数
  _hash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}

// 使用
const consistentHash = new ConsistentHash();

consistentHash.addNode('server1');
consistentHash.addNode('server2');
consistentHash.addNode('server3');

console.log('key1 的节点:', consistentHash.getNode('key1'));
console.log('key2 的节点:', consistentHash.getNode('key2'));

// 扩展：支持权重
class WeightedConsistentHash extends ConsistentHash {
  constructor() {
    super();
    this.nodeWeights = new Map();
  }
  
  addNode(node, weight = 1) {
    this.nodeWeights.set(node, weight);
    
    // 根据权重创建虚拟节点
    const virtualNodes = this.virtualNodes * weight;
    
    for (let i = 0; i < virtualNodes; i++) {
      const virtualNodeKey = `${node}:${i}`;
      const hash = this._hash(virtualNodeKey);
      this.ring.set(hash, node);
      this.sortedKeys.push(hash);
    }
    
    this.sortedKeys.sort((a, b) => a - b);
  }
}

// 使用
const weightedHash = new WeightedConsistentHash();

weightedHash.addNode('server1', 1);
weightedHash.addNode('server2', 2);
weightedHash.addNode('server3', 3);

console.log('key1 的节点:', weightedHash.getNode('key1'));

// 扩展：支持节点复制
class ReplicatedConsistentHash extends ConsistentHash {
  constructor(replicas = 2) {
    super();
    this.replicas = replicas;
  }
  
  getNodes(key) {
    if (this.sortedKeys.length === 0) {
      return [];
    }
    
    const hash = this._hash(key);
    const nodes = [];
    
    // 找到所有副本节点
    let left = 0;
    for (let i = 0; i < this.replicas; i++) {
      // 二分查找
      while (left < this.sortedKeys.length && this.sortedKeys[left] < hash) {
        left++;
      }
      
      // 环形
      if (left >= this.sortedKeys.length) {
        left = 0;
      }
      
      const node = this.ring.get(this.sortedKeys[left]);
      
      // 避免重复
      if (!nodes.includes(node)) {
        nodes.push(node);
      }
      
      left++;
    }
    
    return nodes;
  }
}

// 使用
const replicatedHash = new ReplicatedConsistentHash(3);

replicatedHash.addNode('server1');
replicatedHash.addNode('server2');
replicatedHash.addNode('server3');

console.log('key1 的副本节点:', replicatedHash.getNodes('key1'));
```

**场景应用：**

```javascript
// 分布式缓存
class DistributedCache {
  constructor(servers) {
    this.hash = new ConsistentHash();
    this.caches = new Map();
    
    servers.forEach(server => {
      this.hash.addNode(server);
      this.caches.set(server, new Map());
    });
  }
  
  get(key) {
    const server = this.hash.getNode(key);
    return this.caches.get(server)?.get(key);
  }
  
  set(key, value) {
    const server = this.hash.getNode(key);
    this.caches.get(server)?.set(key, value);
  }
  
  addServer(server) {
    this.hash.addNode(server);
    this.caches.set(server, new Map());
  }
  
  removeServer(server) {
    this.hash.removeNode(server);
    this.caches.delete(server);
  }
}

// 使用
const cache = new DistributedCache(['server1', 'server2', 'server3']);

cache.set('user:1', { name: 'Alice' });
cache.set('user:2', { name: 'Bob' });

console.log('获取 user:1:', cache.get('user:1'));

// 添加新服务器
cache.addServer('server4');

// 负载均衡
class LoadBalancer {
  constructor(servers) {
    this.hash = new ConsistentHash();
    this.servers = servers;
    
    servers.forEach(server => {
      this.hash.addNode(server);
    });
  }
  
  getServer(request) {
    const key = this._extractKey(request);
    return this.hash.getNode(key);
  }
  
  _extractKey(request) {
    // 使用请求的某些特征作为 key
    return request.ip + request.path;
  }
  
  addServer(server) {
    this.servers.push(server);
    this.hash.addNode(server);
  }
  
  removeServer(server) {
    const index = this.servers.indexOf(server);
    if (index > -1) {
      this.servers.splice(index, 1);
      this.hash.removeNode(server);
    }
  }
}

// 使用
const loadBalancer = new LoadBalancer(['server1', 'server2', 'server3']);

const request = { ip: '192.168.1.1', path: '/api/data' };
console.log('路由到:', loadBalancer.getServer(request));
```

---

## 总结

大厂面试题重点掌握：

### 前端基础
1. **性能优化**：加载、运行、渲染优化
2. **浏览器原理**：渲染流程、重排重绘
3. **工程化**：构建工具、监控系统
4. **架构设计**：微前端、状态管理、路由

### 算法题
1. **数据结构**：LRU、Trie、布隆过滤器、一致性哈希
2. **排序算法**：快速排序、归并排序
3. **搜索算法**：二分查找、DFS、BFS
4. **动态规划**：LCS、背包问题

### 场景题
1. **实际应用**：将算法应用到实际场景
2. **扩展性**：考虑边界情况和优化
3. **代码质量**：清晰、可维护、可测试

**面试准备建议：**
1. 深入理解原理，不要只背答案
2. 多写代码，注重代码质量
3. 关注最新技术趋势
4. 准备项目经验，能讲清楚技术选型和难点
5. 保持学习热情和解决问题的能力