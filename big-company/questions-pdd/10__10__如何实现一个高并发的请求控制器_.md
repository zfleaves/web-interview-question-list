# 10. 如何实现一个高并发的请求控制器？

**答案：**

在高并发场景下，需要控制并发请求数量，避免浏览器或服务器过载。

**实现方案：**

**方案 1：基于 Promise 的并发控制**
```javascript
class ConcurrencyController {
  constructor(maxConcurrent = 5) {
    this.maxConcurrent = maxConcurrent;
    this.runningCount = 0;
    this.queue = [];
  }
  
  async run(task) {
    // 如果当前运行数量达到上限，加入队列等待
    if (this.runningCount >= this.maxConcurrent) {
      await new Promise(resolve => {
        this.queue.push(resolve);
      });
    }
    
    this.runningCount++;
    
    try {
      const result = await task();
      return result;
    } finally {
      this.runningCount--;
      
      // 从队列中取出下一个任务
      if (this.queue.length > 0) {
        const resolve = this.queue.shift();
        resolve();
      }
    }
  }
  
  async runAll(tasks) {
    return Promise.all(tasks.map(task => this.run(task)));
  }
}

// 使用
const controller = new ConcurrencyController(3);

const tasks = [
  () => fetch('/api/data1'),
  () => fetch('/api/data2'),
  () => fetch('/api/data3'),
  () => fetch('/api/data4'),
  () => fetch('/api/data5'),
  () => fetch('/api/data6'),
];

const results = await controller.runAll(tasks);
```

**方案 2：带优先级的并发控制**
```javascript
class PriorityConcurrencyController {
  constructor(maxConcurrent = 5) {
    this.maxConcurrent = maxConcurrent;
    this.runningCount = 0;
    this.queue = [];
  }
  
  async run(task, priority = 0) {
    return new Promise((resolve, reject) => {
      // 添加到队列，按优先级排序
      this.queue.push({ task, priority, resolve, reject });
      this.queue.sort((a, b) => b.priority - a.priority);
      
      this.processQueue();
    });
  }
  
  async processQueue() {
    if (this.runningCount >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    const { task, resolve, reject } = this.queue.shift();
    this.runningCount++;
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.runningCount--;
      this.processQueue();
    }
  }
  
  async runAll(tasks) {
    return Promise.all(tasks.map(task => this.run(task)));
  }
}

// 使用
const controller = new PriorityConcurrencyController(3);

// 高优先级任务
await controller.run(() => fetch('/api/high-priority'), 10);

// 普通优先级任务
await controller.run(() => fetch('/api/normal'), 5);

// 低优先级任务
await controller.run(() => fetch('/api/low'), 1);
```

**方案 3：带重试机制的并发控制**
```javascript
class RetryConcurrencyController {
  constructor(maxConcurrent = 5, maxRetries = 3) {
    this.maxConcurrent = maxConcurrent;
    this.maxRetries = maxRetries;
    this.runningCount = 0;
    this.queue = [];
  }
  
  async run(task, retryCount = 0) {
    if (this.runningCount >= this.maxConcurrent) {
      await new Promise(resolve => {
        this.queue.push(resolve);
      });
    }
    
    this.runningCount++;
    
    try {
      const result = await task();
      return result;
    } catch (error) {
      // 如果还有重试次数，重新加入队列
      if (retryCount < this.maxRetries) {
        console.log(`Retry ${retryCount + 1}/${this.maxRetries}`);
        return this.run(task, retryCount + 1);
      }
      throw error;
    } finally {
      this.runningCount--;
      
      if (this.queue.length > 0) {
        const resolve = this.queue.shift();
        resolve();
      }
    }
  }
  
  async runAll(tasks) {
    return Promise.all(tasks.map(task => this.run(task)));
  }
}
```

**方案 4：带超时控制的并发控制**
```javascript
class TimeoutConcurrencyController {
  constructor(maxConcurrent = 5, timeout = 10000) {
    this.maxConcurrent = maxConcurrent;
    this.timeout = timeout;
    this.runningCount = 0;
    this.queue = [];
  }
  
  async run(task) {
    if (this.runningCount >= this.maxConcurrent) {
      await new Promise(resolve => {
        this.queue.push(resolve);
      });
    }
    
    this.runningCount++;
    
    try {
      // 添加超时控制
      const result = await Promise.race([
        task(),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout')), this.timeout)
        )
      ]);
      return result;
    } finally {
      this.runningCount--;
      
      if (this.queue.length > 0) {
        const resolve = this.queue.shift();
        resolve();
      }
    }
  }
  
  async runAll(tasks) {
    return Promise.all(tasks.map(task => this.run(task)));
  }
}
```

**方案 5：批量请求优化**
```javascript
class BatchRequestManager {
  constructor(maxBatchSize = 10, maxWaitTime = 100) {
    this.maxBatchSize = maxBatchSize;
    this.maxWaitTime = maxWaitTime;
    this.currentBatch = [];
    this.timer = null;
  }
  
  async request(url) {
    return new Promise((resolve, reject) => {
      this.currentBatch.push({ url, resolve, reject });
      
      // 如果批次已满，立即发送
      if (this.currentBatch.length >= this.maxBatchSize) {
        this.flushBatch();
      } else if (!this.timer) {
        // 设置定时器，在最大等待时间后发送
        this.timer = setTimeout(() => {
          this.flushBatch();
          this.timer = null;
        }, this.maxWaitTime);
      }
    });
  }
  
  async flushBatch() {
    if (this.currentBatch.length === 0) return;
    
    const batch = this.currentBatch.splice(0);
    
    // 批量请求
    const urls = batch.map(item => item.url);
    try {
      const response = await fetch('/api/batch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ urls }),
      });
      const results = await response.json();
      
      // 分发结果
      results.forEach((result, index) => {
        batch[index].resolve(result);
      });
    } catch (error) {
      batch.forEach(item => item.reject(error));
    }
  }
  
  destroy() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
    this.flushBatch();
  }
}
```

---

## 总结

拼多多面试题重点掌握：

### 前端基础
1. **Promise**：all、allSettled、race、any 的实现
2. **状态管理**：Vuex/Redux 的实现原理
3. **性能优化**：频繁切换标签页、并发控制、批量请求

### 算法题
1. **二叉树遍历**：前序、中序、后序、层序
2. **设计模式**：发布订阅模式

### 场景题
1. **无限滚动**：性能优化、防抖节流
2. **拖拽上传**：文件上传、进度显示
3. **表单验证**：规则配置、错误处理
4. **权限控制**：权限上下文、权限检查组件
5. **标签页优化**：Page Visibility API、动画暂停、请求优化
6. **并发控制**：Promise 并发、优先级控制、重试机制、超时控制
7. **批量请求**：请求合并、性能优化

**面试准备建议：**
1. 深入理解 Promise 和异步编程
2. 掌握常见数据结构
3. 熟悉设计模式
4. 注重代码质量和可维护性
5. 关注性能优化和并发控制
