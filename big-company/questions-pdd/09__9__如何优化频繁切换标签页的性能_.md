# 9. 如何优化频繁切换标签页的性能？

**答案：**

频繁切换标签页会导致页面重新渲染和资源浪费，需要进行性能优化。

**优化方案：**

**方案 1：使用 Page Visibility API**
```javascript
class TabVisibilityManager {
  constructor() {
    this.isVisible = true;
    this.hiddenHandlers = [];
    this.visibleHandlers = [];
    this.init();
  }
  
  init() {
    // 监听页面可见性变化
    document.addEventListener('visibilitychange', this.handleVisibilityChange);
    
    // 兼容旧版浏览器
    document.addEventListener('webkitvisibilitychange', this.handleVisibilityChange);
    document.addEventListener('mozvisibilitychange', this.handleVisibilityChange);
    document.addEventListener('msvisibilitychange', this.handleVisibilityChange);
  }
  
  handleVisibilityChange = () => {
    this.isVisible = !document.hidden;
    
    if (this.isVisible) {
      this.visibleHandlers.forEach(handler => handler());
    } else {
      this.hiddenHandlers.forEach(handler => handler());
    }
  };
  
  onHidden(handler) {
    this.hiddenHandlers.push(handler);
  }
  
  onVisible(handler) {
    this.visibleHandlers.push(handler);
  }
  
  destroy() {
    document.removeEventListener('visibilitychange', this.handleVisibilityChange);
    document.removeEventListener('webkitvisibilitychange', this.handleVisibilityChange);
    document.removeEventListener('mozvisibilitychange', this.handleVisibilityChange);
    document.removeEventListener('msvisibilitychange', this.handleVisibilityChange);
  }
}

// 使用
const visibilityManager = new TabVisibilityManager();

// 页面隐藏时暂停定时器
let timer;
visibilityManager.onHidden(() => {
  clearInterval(timer);
});

// 页面显示时恢复定时器
visibilityManager.onVisible(() => {
  timer = setInterval(() => {
    fetchData();
  }, 5000);
});
```

**方案 2：暂停和恢复动画**
```javascript
class AnimationManager {
  constructor() {
    this.animations = new Map();
    this.init();
  }
  
  init() {
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.pauseAll();
      } else {
        this.resumeAll();
      }
    });
  }
  
  register(id, animation) {
    this.animations.set(id, animation);
  }
  
  pauseAll() {
    this.animations.forEach(animation => {
      if (animation.pause) {
        animation.pause();
      }
    });
  }
  
  resumeAll() {
    this.animations.forEach(animation => {
      if (animation.resume) {
        animation.resume();
      }
    });
  }
}

// 使用
const animationManager = new AnimationManager();

const animation1 = new Animation();
const animation2 = new Animation();

animationManager.register('anim1', animation1);
animationManager.register('anim2', animation2);
```

**方案 3：优化数据请求**
```javascript
class RequestManager {
  constructor() {
    this.isTabActive = true;
    this.pendingRequests = new Map();
    this.init();
  }
  
  init() {
    document.addEventListener('visibilitychange', () => {
      this.isTabActive = !document.hidden;
      
      if (this.isTabActive) {
        this.resumeRequests();
      } else {
        this.abortRequests();
      }
    });
  }
  
  async fetch(url, options = {}) {
    if (!this.isTabActive) {
      return new Promise((resolve, reject) => {
        this.pendingRequests.set(url, { resolve, reject, url, options });
      });
    }
    
    try {
      const response = await fetch(url, options);
      return await response.json();
    } catch (error) {
      throw error;
    }
  }
  
  resumeRequests() {
    this.pendingRequests.forEach(({ resolve, reject, url, options }) => {
      fetch(url, options)
        .then(response => response.json())
        .then(resolve)
        .catch(reject);
    });
    
    this.pendingRequests.clear();
  }
  
  abortRequests() {
    this.pendingRequests.forEach(({ reject }) => {
      reject(new Error('Request aborted due to tab switch'));
    });
    
    this.pendingRequests.clear();
  }
}
```

**方案 4：React 中的优化**
```javascript
import { useState, useEffect, useRef } from 'react';

function OptimizedComponent() {
  const [data, setData] = useState(null);
  const intervalRef = useRef(null);
  const isVisibleRef = useRef(true);
  
  useEffect(() => {
    // 监听页面可见性
    const handleVisibilityChange = () => {
      isVisibleRef.current = !document.hidden;
      
      if (isVisibleRef.current) {
        startFetching();
      } else {
        stopFetching();
      }
    };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // 初始启动
    startFetching();
    
    return () => {
      stopFetching();
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, []);
  
  const startFetching = () => {
    if (intervalRef.current) return;
    
    intervalRef.current = setInterval(async () => {
      try {
        const response = await fetch('/api/data');
        const data = await response.json();
        setData(data);
      } catch (error) {
        console.error('Fetch error:', error);
      }
    }, 5000);
  };
  
  const stopFetching = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };
  
  return (
    <div>
      <h1>数据: {data ? JSON.stringify(data) : '加载中...'}</h1>
    </div>
  );
}
```

**方案 5：使用 Intersection Observer 优化**
```javascript
class LazyTabManager {
  constructor() {
    this.activeTabs = new Set();
    this.observer = null;
    this.init();
  }
  
  init() {
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const tabId = entry.target.dataset.tabId;
        
        if (entry.isIntersecting) {
          this.activateTab(tabId);
        } else {
          this.deactivateTab(tabId);
        }
      });
    }, {
      threshold: 0.5
    });
  }
  
  observeTab(tabElement, tabId) {
    tabElement.dataset.tabId = tabId;
    this.observer.observe(tabElement);
  }
  
  activateTab(tabId) {
    if (!this.activeTabs.has(tabId)) {
      this.activeTabs.add(tabId);
      this.loadTabContent(tabId);
    }
  }
  
  deactivateTab(tabId) {
    this.activeTabs.delete(tabId);
    this.unloadTabContent(tabId);
  }
  
  loadTabContent(tabId) {
    console.log(`Loading content for tab: ${tabId}`);
    // 加载标签页内容
  }
  
  unloadTabContent(tabId) {
    console.log(`Unloading content for tab: ${tabId}`);
    // 卸载标签页内容
  }
  
  destroy() {
    this.observer.disconnect();
  }
}
```

**优化技巧：**

1. **使用 requestIdleCallback**
```javascript
function performHeavyTask() {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() => {
      // 在浏览器空闲时执行
      heavyTask();
    });
  } else {
    // 降级方案
    setTimeout(() => {
      heavyTask();
    }, 0);
  }
}
```

2. **使用 Web Worker**
```javascript
// 主线程
const worker = new Worker('worker.js');

worker.onmessage = (e) => {
  const result = e.data;
  console.log('Worker result:', result);
};

// 发送任务给 Worker
worker.postMessage({ task: 'heavy-computation', data: largeData });

// worker.js
self.onmessage = (e) => {
  const { task, data } = e.data;
  
  if (task === 'heavy-computation') {
    const result = performHeavyComputation(data);
    self.postMessage(result);
  }
};
```

3. **使用 Virtual DOM 优化**
```javascript
import { memo } from 'react';

const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {
  // 只在 data 变化时重新渲染
  return <div>{/* 复杂渲染逻辑 */}</div>;
});

function Parent() {
  const [data, setData] = useState(null);
  
  return (
    <div>
      <ExpensiveComponent data={data} />
    </div>
  );
}
```

---
