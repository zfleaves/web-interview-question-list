# 8. 如何实现一个权限控制组件？

**答案：**

```javascript
// 权限上下文
const PermissionContext = React.createContext();

function PermissionProvider({ permissions, children }) {
  return (
    <PermissionContext.Provider value={permissions}>
      {children}
    </PermissionContext.Provider>
  );
}

// 权限检查组件
function Permission({ permission, fallback = null, children }) {
  const permissions = React.useContext(PermissionContext);
  
  const hasPermission = permissions.includes(permission);
  
  if (!hasPermission) {
    return fallback;
  }
  
  return children;
}

// 使用
function App() {
  const userPermissions = ['read', 'write', 'delete'];
  
  return (
    <PermissionProvider permissions={userPermissions}>
      <Dashboard />
    </PermissionProvider>
  );
}

function Dashboard() {
  return (
    <div>
      <Permission permission="read">
        <ReadData />
      </Permission>
      
      <Permission permission="write" fallback={<div>没有写入权限</div>}>
        <WriteData />
      </Permission>
      
      <Permission permission="delete" fallback={<div>没有删除权限</div>}>
        <DeleteData />
      </Permission>
    </div>
  );
}
```

---

## 总结

拼多多面试题重点掌握：

### 前端基础
1. **Promise**：all、allSettled、race、any 的实现
2. **状态管理**：Vuex/Redux 的实现原理
3. **无限滚动**：性能优化、防抖节流
4. **拖拽上传**：拖拽事件、文件上传、进度显示
5. **表单验证**：规则配置、错误处理
6. **权限控制**：权限上下文、权限检查组件

### 算法题
1. **二叉树遍历**：前序、中序、后序、层序
2. **设计模式**：发布订阅模式

### 场景题
1. **实际应用**：将算法应用到实际场景
2. **扩展性**：考虑边界情况和优化
3. **代码质量**：清晰、可维护、可测试

**面试准备建议：**
1. 深入理解 Promise 和异步编程
2. 掌握常见数据结构
3. 熟悉设计模式
4. 注重代码质量和可维护性

**答案：**

```javascript
class InfiniteScroll {
  constructor() {
    this.state = {
      items: [],
      page: 1,
      loading: false,
      hasMore: true
    };
    
    this.init();
  }
  
  init() {
    this.loadItems();
    window.addEventListener('scroll', this.handleScroll);
  }
  
  loadItems = async () => {
    if (this.state.loading || !this.state.hasMore) return;
    
    this.state.loading = true;
    
    try {
      const { page } = this.state;
      const newItems = await this.fetchItems(page);
      
      this.state.items = [...this.state.items, ...newItems];
      this.state.page = page + 1;
      this.state.loading = false;
      this.state.hasMore = newItems.length >= 10;
      
      this.render();
    } catch (error) {
      console.error(error);
      this.state.loading = false;
    }
  };
  
  fetchItems = async (page) => {
    const response = await fetch(`/api/items?page=${page}`);
    const data = await response.json();
    return data;
  };
  
  handleScroll = () => {
    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
    
    // 距离底部 100px 时加载更多
    if (scrollTop + clientHeight >= scrollHeight - 100) {
      this.loadItems();
    }
  };
  
  render() {
    const container = document.getElementById('container');
    container.innerHTML = `
      <ul>
        ${this.state.items.map((item, index) => `
          <li key="${index}">${item.name}</li>
        `).join('')}
      </ul>
      ${this.state.loading ? '<div>加载中...</div>' : ''}
    `;
  }
}
```
