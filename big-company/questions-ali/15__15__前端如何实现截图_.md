# 15. 前端如何实现截图？

**答案：**

前端截图有多种实现方案，根据需求选择合适的方法。

**方案 1：使用 html2canvas**

```javascript
import html2canvas from 'html2canvas';

async function captureElement(element) {
  try {
    const canvas = await html2canvas(element, {
      useCORS: true, // 允许跨域图片
      scale: 2, // 提高清晰度
      backgroundColor: null, // 透明背景
      logging: false, // 关闭日志
      allowTaint: true, // 允许污染的 canvas
    });
    
    return canvas.toDataURL('image/png');
  } catch (error) {
    console.error('截图失败:', error);
    throw error;
  }
}

// 使用
const element = document.getElementById('capture-area');
const dataUrl = await captureElement(element);

// 下载图片
const link = document.createElement('a');
link.download = 'screenshot.png';
link.href = dataUrl;
link.click();
```

**方案 2：使用 Canvas 手动绘制**

```javascript
class CanvasCapture {
  constructor(options = {}) {
    this.options = {
      scale: 2,
      backgroundColor: '#ffffff',
      ...options
    };
  }
  
  async capture(element) {
    const rect = element.getBoundingClientRect();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // 设置 canvas 尺寸
    canvas.width = rect.width * this.options.scale;
    canvas.height = rect.height * this.options.scale;
    
    // 设置缩放
    ctx.scale(this.options.scale, this.options.scale);
    
    // 填充背景
    if (this.options.backgroundColor) {
      ctx.fillStyle = this.options.backgroundColor;
      ctx.fillRect(0, 0, rect.width, rect.height);
    }
    
    // 绘制元素
    await this.drawElement(ctx, element, 0, 0);
    
    return canvas.toDataURL('image/png');
  }
  
  async drawElement(ctx, element, x, y) {
    const rect = element.getBoundingClientRect();
    const computedStyle = window.getComputedStyle(element);
    
    // 绘制背景
    if (computedStyle.backgroundColor !== 'rgba(0, 0, 0, 0)') {
      ctx.fillStyle = computedStyle.backgroundColor;
      ctx.fillRect(x, y, rect.width, rect.height);
    }
    
    // 绘制边框
    if (computedStyle.borderWidth !== '0px') {
      ctx.strokeStyle = computedStyle.borderColor;
      ctx.lineWidth = parseFloat(computedStyle.borderWidth);
      ctx.strokeRect(x, y, rect.width, rect.height);
    }
    
    // 绘制文本
    if (element.childNodes) {
      for (const node of element.childNodes) {
        if (node.nodeType === Node.TEXT_NODE) {
          ctx.fillStyle = computedStyle.color;
          ctx.font = `${computedStyle.fontWeight} ${computedStyle.fontSize} ${computedStyle.fontFamily}`;
          ctx.fillText(node.textContent, x + parseFloat(computedStyle.paddingLeft), y + parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.fontSize));
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          await this.drawElement(ctx, node, x, y);
        }
      }
    }
  }
}

// 使用
const capture = new CanvasCapture({ scale: 2 });
const dataUrl = await capture.capture(document.getElementById('capture-area'));
```

**方案 3：使用 SVG foreignObject**

```javascript
async function captureWithSVG(element) {
  const rect = element.getBoundingClientRect();
  const data = new XMLSerializer().serializeToString(element);
  
  // 创建 SVG
  const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="${rect.width}" height="${rect.height}">
      <foreignObject width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml">
          ${data}
        </div>
      </foreignObject>
    </svg>
  `;
  
  // 转换为 canvas
  const img = new Image();
  img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
  
  return new Promise((resolve, reject) => {
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = rect.width;
      canvas.height = rect.height;
      
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      
      resolve(canvas.toDataURL('image/png'));
    };
    
    img.onerror = reject;
  });
}

// 使用
const dataUrl = await captureWithSVG(document.getElementById('capture-area'));
```

**方案 4：使用浏览器原生截图 API**

```javascript
async function captureWithNativeAPI() {
  try {
    // 获取所有窗口
    const sources = await navigator.mediaDevices.getDisplayMedia({
      video: {
        cursor: 'never',
      },
      audio: false,
    });
    
    // 创建 video 元素
    const video = document.createElement('video');
    video.srcObject = sources;
    video.play();
    
    // 等待视频加载
    await new Promise(resolve => {
      video.onloadedmetadata = resolve;
    });
    
    // 创建 canvas
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    // 绘制到 canvas
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    
    // 停止视频流
    sources.getTracks().forEach(track => track.stop());
    
    return canvas.toDataURL('image/png');
  } catch (error) {
    console.error('原生截图失败:', error);
    throw error;
  }
}

// 使用
const dataUrl = await captureWithNativeAPI();
```

**注意事项：**
1. **跨域问题**：使用 `useCORS: true` 和 `allowTaint: true`
2. **清晰度**：通过 `scale` 参数提高清晰度
3. **性能**：大元素截图可能较慢，建议使用 Web Worker
4. **兼容性**：html2canvas 兼容性最好，原生 API 兼容性较差

---
