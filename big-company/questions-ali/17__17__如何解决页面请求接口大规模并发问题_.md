# 17. 如何解决页面请求接口大规模并发问题？

**答案：**

大规模并发问题是前端开发中的常见挑战，需要从多个层面进行优化。

**方案 1：使用请求队列和并发控制**

```javascript
class RequestQueue {
  constructor(options = {}) {
    this.options = {
      maxConcurrent: 6, // 最大并发数
      ...options
    };
    
    this.queue = [];
    this.running = 0;
  }
  
  add(request) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        request,
        resolve,
        reject
      });
      
      this.process();
    });
  }
  
  process() {
    while (this.queue.length > 0 && this.running < this.options.maxConcurrent) {
      const task = this.queue.shift();
      this.running++;
      
      task.request()
        .then(task.resolve)
        .catch(task.reject)
        .finally(() => {
          this.running--;
          this.process();
        });
    }
  }
}

// 使用
const requestQueue = new RequestQueue({ maxConcurrent: 6 });

// 添加大量请求
const requests = [];
for (let i = 0; i < 100; i++) {
  requests.push(
    requestQueue.add(() => fetch(`/api/data/${i}`).then(res => res.json()))
  );
}

// 等待所有请求完成
const results = await Promise.all(requests);
```

**方案 2：使用请求优先级**

```javascript
class PriorityRequestQueue {
  constructor(options = {}) {
    this.options = {
      maxConcurrent: 6,
      ...options
    };
    
    this.queues = {
      high: [],
      medium: [],
      low: []
    };
    
    this.running = 0;
  }
  
  add(request, priority = 'medium') {
    return new Promise((resolve, reject) => {
      this.queues[priority].push({
        request,
        resolve,
        reject
      });
      
      this.process();
    });
  }
  
  process() {
    while (this.running < this.options.maxConcurrent) {
      // 优先处理高优先级队列
      let task = this.queues.high.shift();
      
      if (!task) {
        task = this.queues.medium.shift();
      }
      
      if (!task) {
        task = this.queues.low.shift();
      }
      
      if (!task) {
        break;
      }
      
      this.running++;
      
      task.request()
        .then(task.resolve)
        .catch(task.reject)
        .finally(() => {
          this.running--;
          this.process();
        });
    }
  }
}

// 使用
const priorityQueue = new PriorityRequestQueue({ maxConcurrent: 6 });

// 添加不同优先级的请求
const highPriorityRequest = priorityQueue.add(
  () => fetch('/api/critical').then(res => res.json()),
  'high'
);

const mediumPriorityRequest = priorityQueue.add(
  () => fetch('/api/normal').then(res => res.json()),
  'medium'
);

const lowPriorityRequest = priorityQueue.add(
  () => fetch('/api/background').then(res => res.json()),
  'low'
);
```

**方案 3：使用请求分组和批量处理**

```javascript
class BatchRequestProcessor {
  constructor(options = {}) {
    this.options = {
      maxBatchSize: 10,
      maxWaitTime: 100,
      ...options
    };
    
    this.batches = new Map();
    this.timers = new Map();
  }
  
  add(key, request) {
    return new Promise((resolve, reject) => {
      if (!this.batches.has(key)) {
        this.batches.set(key, []);
      }
      
      this.batches.get(key).push({ request, resolve, reject });
      
      const batch = this.batches.get(key);
      
      if (batch.length >= this.options.maxBatchSize) {
        this.processBatch(key);
      } else if (!this.timers.has(key)) {
        this.timers.set(
          key,
          setTimeout(() => this.processBatch(key), this.options.maxWaitTime)
        );
      }
    });
  }
  
  async processBatch(key) {
    clearTimeout(this.timers.get(key));
    this.timers.delete(key);
    
    const batch = this.batches.get(key);
    if (!batch || batch.length === 0) {
      return;
    }
    
    this.batches.delete(key);
    
    try {
      const requests = batch.map(item => item.request);
      const responses = await this.executeBatch(requests);
      
      batch.forEach((item, index) => {
        item.resolve(responses[index]);
      });
    } catch (error) {
      batch.forEach(item => item.reject(error));
    }
  }
  
  async executeBatch(requests) {
    // 实现批量请求
    const response = await fetch('/api/batch', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ requests })
    });
    
    return response.json();
  }
}

// 使用
const batchProcessor = new BatchRequestProcessor({
  maxBatchSize: 10,
  maxWaitTime: 100
});

// 添加请求到同一批次
const results = await Promise.all([
  batchProcessor.add('user', { url: '/api/user/1' }),
  batchProcessor.add('user', { url: '/api/user/2' }),
  batchProcessor.add('user', { url: '/api/user/3' })
]);
```

**方案 4：使用请求缓存和去重**

```javascript
class RequestDeduplicator {
  constructor(options = {}) {
    this.options = {
      ttl: 60000,
      ...options
    };
    
    this.cache = new Map();
    this.pending = new Map();
  }
  
  async request(key, fn) {
    // 检查缓存
    if (this.cache.has(key)) {
      const cached = this.cache.get(key);
      if (Date.now() - cached.timestamp < this.options.ttl) {
        return cached.data;
      } else {
        this.cache.delete(key);
      }
    }
    
    // 检查是否有相同的请求正在进行
    if (this.pending.has(key)) {
      return this.pending.get(key);
    }
    
    // 发起新请求
    const promise = fn().then(data => {
      this.cache.set(key, {
        data,
        timestamp: Date.now()
      });
      this.pending.delete(key);
      return data;
    }).catch(error => {
      this.pending.delete(key);
      throw error;
    });
    
    this.pending.set(key, promise);
    return promise;
  }
  
  clear() {
    this.cache.clear();
    this.pending.clear();
  }
}

// 使用
const deduplicator = new RequestDeduplicator();

async function getUser(id) {
  return deduplicator.request(`user_${id}`, () => {
    return fetch(`/api/user/${id}`).then(res => res.json());
  });
}

// 多次调用相同请求，只会发起一次 HTTP 请求
const user1 = await getUser(1);
const user2 = await getUser(1); // 从缓存获取
```

**方案 5：使用 Web Worker 处理大量请求**

```javascript
// worker.js
self.onmessage = async (e) => {
  const { requests, maxConcurrent } = e.data;
  const results = [];
  
  // 并发控制
  const chunks = [];
  for (let i = 0; i < requests.length; i += maxConcurrent) {
    chunks.push(requests.slice(i, i + maxConcurrent));
  }
  
  for (const chunk of chunks) {
    const chunkResults = await Promise.all(
      chunk.map(request => fetch(request.url).then(res => res.json()))
    );
    results.push(...chunkResults);
  }
  
  self.postMessage({ results });
};

// main.js
class WorkerRequestProcessor {
  constructor(options = {}) {
    this.options = {
      maxConcurrent: 6,
      ...options
    };
    
    this.worker = new Worker('worker.js');
  }
  
  async process(requests) {
    return new Promise((resolve, reject) => {
      this.worker.onmessage = (e) => {
        resolve(e.data.results);
      };
      
      this.worker.onerror = reject;
      
      this.worker.postMessage({
        requests,
        maxConcurrent: this.options.maxConcurrent
      });
    });
  }
}

// 使用
const workerProcessor = new WorkerRequestProcessor({ maxConcurrent: 6 });

const requests = Array.from({ length: 100 }, (_, i) => ({
  url: `/api/data/${i}`
}));

const results = await workerProcessor.process(requests);
```

---

## 总结

阿里面试题重点掌握：

### 前端基础
1. **JavaScript 核心**：事件循环、数据类型、异步机制、闭包
2. **前端框架**：Vue/React 虚拟 DOM 原理、响应式系统、Diff 算法
3. **CSS 与布局**：三栏布局、选择器优先级、BFC
4. **性能优化**：全链路性能优化方案、图片懒加载、虚拟滚动
5. **工程化与网络**：HTTP 缓存、WebSocket、TCP 优化、HTTP/2
6. **浏览器与安全**：跨域、XSS/CSRF、同源策略

### 算法题
1. **深拷贝**：处理循环引用、特殊对象
2. **LRU 缓存**：使用 Map 实现 O(1) 时间复杂度
3. **函数防抖**：搜索框输入优化
4. **Promise.all**：并发请求聚合
5. **异步调度器**：并发控制

### 场景题
1. **实际应用**：将算法应用到实际场景
2. **扩展性**：考虑边界情况和优化
3. **代码质量**：清晰、可维护、可测试
4. **高并发场景**：QPS 峰值处理、大规模并发控制
5. **截图功能**：html2canvas、Canvas、SVG、原生 API
6. **性能监控**：请求监控、告警机制

**面试准备建议：**
1. 深入理解 JavaScript 核心原理（事件循环、闭包、原型链）
2. 掌握 Vue/React 框架底层原理（虚拟 DOM、响应式系统、Diff 算法）
3. 熟悉性能优化全链路方案（加载、运行、渲染）
4. 熟练掌握手写代码题（深拷贝、防抖节流、Promise 等）
5. 结合阿里业务场景（电商、中后台系统）说明解决方案
6. 注重代码质量和可维护性
7. 保持对新技术的关注和学习热情
8. 掌握高并发场景的解决方案（限流、降级、熔断）
9. 了解前端监控和性能优化工具

**阿里特色：**
- 高频考察工程化实践（Webpack 优化、微前端）
- 关注小程序开发深度（原生组件、框架限制）
- 考察中后台系统开发经验
- 关注高并发场景解决方案
- 注重实际项目经验和问题解决能力
- 考察对性能监控和优化的理解
