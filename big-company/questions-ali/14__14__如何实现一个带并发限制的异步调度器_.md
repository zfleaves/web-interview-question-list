# 14. 如何实现一个带并发限制的异步调度器？

**答案：**

```javascript
class AsyncScheduler {
  constructor(max = 6) {
    this.max = max;
    this.queue = [];
    this.running = 0;
  }
  
  add(task) {
    return new Promise((resolve, reject) => {
      const execute = () => {
        this.running++;
        task()
          .then(resolve)
          .catch(reject)
          .finally(() => {
            this.running--;
            this.next();
          });
      };
      
      this.queue.push(execute);
      this.next();
    });
  }
  
  next() {
    while (this.queue.length && this.running < this.max) {
      const execute = this.queue.shift();
      execute();
    }
  }
}

// 使用
const scheduler = new AsyncScheduler(6); // 最多6个并发

// 添加任务
for (let i = 0; i < 20; i++) {
  scheduler.add(() => {
    return fetch(`/api/data/${i}`)
      .then(res => res.json())
      .then(data => {
        console.log(`任务 ${i} 完成:`, data);
      });
  });
}
```

**阿里特色考点：**
- 阿里高频考察并发控制的实现原理
- 结合浏览器并发限制（Chrome 最多6个）说明必要性
- 考察对异步编程和性能优化的理解

---
