# 16. 当 QPS 达到峰值时，该如何处理？

**答案：**

QPS（Queries Per Second）峰值处理是高并发场景下的核心问题，需要从前端和后端两个层面进行优化。

**前端优化方案：**

**1. 请求合并和批量处理**

```javascript
class RequestBatcher {
  constructor(options = {}) {
    this.options = {
      maxBatchSize: 10,
      maxWaitTime: 100,
      ...options
    };
    
    this.queue = [];
    this.timer = null;
  }
  
  add(request) {
    return new Promise((resolve, reject) => {
      this.queue.push({ request, resolve, reject });
      
      if (this.queue.length >= this.options.maxBatchSize) {
        this.flush();
      } else if (!this.timer) {
        this.timer = setTimeout(() => this.flush(), this.options.maxWaitTime);
      }
    });
  }
  
  async flush() {
    clearTimeout(this.timer);
    this.timer = null;
    
    if (this.queue.length === 0) {
      return;
    }
    
    const batch = this.queue.splice(0);
    try {
      const responses = await this.executeBatch(batch.map(item => item.request));
      
      batch.forEach((item, index) => {
        item.resolve(responses[index]);
      });
    } catch (error) {
      batch.forEach(item => item.reject(error));
    }
  }
  
  async executeBatch(requests) {
    // 批量请求实现
    const response = await fetch('/api/batch', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ requests })
    });
    
    return response.json();
  }
}

// 使用
const batcher = new RequestBatcher({
  maxBatchSize: 10,
  maxWaitTime: 100
});

// 添加请求
const result1 = await batcher.add({ url: '/api/user/1' });
const result2 = await batcher.add({ url: '/api/user/2' });
const result3 = await batcher.add({ url: '/api/user/3' });
```

**2. 请求缓存和去重**

```javascript
class RequestCache {
  constructor(options = {}) {
    this.options = {
      ttl: 60000, // 缓存时间
      ...options
    };
    
    this.cache = new Map();
    this.pending = new Map();
  }
  
  async request(key, fn) {
    // 检查缓存
    if (this.cache.has(key)) {
      const cached = this.cache.get(key);
      if (Date.now() - cached.timestamp < this.options.ttl) {
        return cached.data;
      } else {
        this.cache.delete(key);
      }
    }
    
    // 检查是否有相同的请求正在进行
    if (this.pending.has(key)) {
      return this.pending.get(key);
    }
    
    // 发起新请求
    const promise = fn().then(data => {
      this.cache.set(key, {
        data,
        timestamp: Date.now()
      });
      this.pending.delete(key);
      return data;
    }).catch(error => {
      this.pending.delete(key);
      throw error;
    });
    
    this.pending.set(key, promise);
    return promise;
  }
  
  clear() {
    this.cache.clear();
    this.pending.clear();
  }
}

// 使用
const requestCache = new RequestCache();

async function getUser(id) {
  return requestCache.request(`user_${id}`, () => {
    return fetch(`/api/user/${id}`).then(res => res.json());
  });
}

// 多次调用相同请求，只会发起一次 HTTP 请求
const user1 = await getUser(1);
const user2 = await getUser(1); // 从缓存获取
```

**3. 请求限流和节流**

```javascript
class RateLimiter {
  constructor(options = {}) {
    this.options = {
      maxRequests: 60, // 最大请求数
      period: 60000, // 时间周期（毫秒）
      ...options
    };
    
    this.requests = [];
  }
  
  async request(fn) {
    // 清理过期请求
    const now = Date.now();
    this.requests = this.requests.filter(time => now - time < this.options.period);
    
    // 检查是否超过限制
    if (this.requests.length >= this.options.maxRequests) {
      const oldestRequest = this.requests[0];
      const waitTime = this.options.period - (now - oldestRequest);
      
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
    
    // 记录请求
    this.requests.push(now);
    
    // 执行请求
    return fn();
  }
}

// 使用
const rateLimiter = new RateLimiter({
  maxRequests: 60,
  period: 60000
});

async function fetchWithRateLimit(url) {
  return rateLimiter.request(() => {
    return fetch(url).then(res => res.json());
  });
}
```

**4. 优雅降级和熔断**

```javascript
class CircuitBreaker {
  constructor(options = {}) {
    this.options = {
      failureThreshold: 5, // 失败阈值
      resetTimeout: 30000, // 重置超时
      ...options
    };
    
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = 'closed'; // closed, open, half-open
  }
  
  async request(fn) {
    // 检查熔断器状态
    if (this.state === 'open') {
      const now = Date.now();
      if (now - this.lastFailureTime >= this.options.resetTimeout) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker is open');
      }
    }
    
    try {
      const result = await fn();
      
      // 请求成功，重置失败计数
      this.failureCount = 0;
      
      if (this.state === 'half-open') {
        this.state = 'closed';
      }
      
      return result;
    } catch (error) {
      this.failureCount++;
      this.lastFailureTime = Date.now();
      
      // 检查是否需要打开熔断器
      if (this.failureCount >= this.options.failureThreshold) {
        this.state = 'open';
      }
      
      throw error;
    }
  }
}

// 使用
const circuitBreaker = new CircuitBreaker({
  failureThreshold: 5,
  resetTimeout: 30000
});

async function fetchWithCircuitBreaker(url) {
  try {
    return await circuitBreaker.request(() => {
      return fetch(url).then(res => res.json());
    });
  } catch (error) {
    // 降级处理
    console.error('请求失败，使用降级数据:', error);
    return { fallback: true };
  }
}
```

**后端优化方案：**

1. **负载均衡**：使用 Nginx、HAProxy 等进行负载均衡
2. **缓存**：使用 Redis、Memcached 进行缓存
3. **限流**：使用令牌桶、漏桶算法进行限流
4. **降级**：在高峰期关闭非核心功能
5. **扩容**：动态增加服务器实例

**监控和告警：**

```javascript
class RequestMonitor {
  constructor() {
    this.metrics = {
      totalRequests: 0,
      successRequests: 0,
      failureRequests: 0,
      avgResponseTime: 0,
      qps: 0
    };
    
    this.startTime = Date.now();
    this.responseTimes = [];
  }
  
  recordRequest(success, responseTime) {
    this.metrics.totalRequests++;
    
    if (success) {
      this.metrics.successRequests++;
    } else {
      this.metrics.failureRequests++;
    }
    
    this.responseTimes.push(responseTime);
    
    // 计算平均响应时间
    this.metrics.avgResponseTime = this.responseTimes.reduce((a, b) => a + b, 0) / this.responseTimes.length;
    
    // 计算 QPS
    const elapsed = (Date.now() - this.startTime) / 1000;
    this.metrics.qps = this.metrics.totalRequests / elapsed;
  }
  
  getMetrics() {
    return { ...this.metrics };
  }
}

// 使用
const monitor = new RequestMonitor();

async function monitoredRequest(url) {
  const startTime = Date.now();
  let success = false;
  
  try {
    const response = await fetch(url);
    success = response.ok;
    return response.json();
  } catch (error) {
    success = false;
    throw error;
  } finally {
    const responseTime = Date.now() - startTime;
    monitor.recordRequest(success, responseTime);
    
    // 检查是否需要告警
    if (monitor.metrics.qps > 1000) {
      console.warn('QPS 过高:', monitor.metrics.qps);
    }
    
    if (monitor.metrics.avgResponseTime > 1000) {
      console.warn('平均响应时间过长:', monitor.metrics.avgResponseTime);
    }
  }
}
```

---
