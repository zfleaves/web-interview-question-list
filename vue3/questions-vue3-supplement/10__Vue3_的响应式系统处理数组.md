# Vue3 的响应式系统处理数组

**答案：**

## 如何处理数组

Vue3 使用 Proxy 来处理数组的响应式，相比 Vue2 的数组重写，Vue3 能够更高效地拦截数组操作。

```javascript
import { reactive } from 'vue';

const arr = reactive([1, 2, 3]);

// 以下操作都会触发响应式更新
arr.push(4);
arr.pop();
arr.splice(0, 1);
arr[0] = 10;
arr.length = 5;
```

## 拦截数组方法

Vue3 会拦截所有数组的变异方法，确保它们能够触发响应式更新：

```javascript
// 这些方法会被拦截
arr.push()
arr.pop()
arr.shift()
arr.unshift()
arr.splice()
arr.sort()
arr.reverse()
```

## 拦截数组索引

```javascript
const arr = reactive([1, 2, 3]);

// 直接通过索引赋值会触发更新
arr[0] = 10;

// 使用 length 属性也会触发更新
arr.length = 5;
```

## 注意事项

### 1. 直接设置数组长度

```javascript
// ✅ 推荐
arr.length = 5;

// ❌ 不推荐（虽然 Vue3 支持，但不如使用 splice 清晰）
arr.splice(5);
```

### 2. 数组解构

```javascript
// 解构会失去响应式
const [first, second] = arr; // first 和 second 不是响应式的

// 正确的做法
const first = computed(() => arr[0]);
```

### 3. 使用展开运算符

```javascript
// 展开运算符会创建新数组，失去响应式
const newArr = [...arr]; // newArr 不是响应式的

// 正确的做法
const newArr = computed(() => [...arr]);
```

### 4. 数组作为对象的属性

```javascript
const obj = reactive({
  items: [1, 2, 3]
});

// ✅ 正确
obj.items.push(4);

// ❌ 错误（会替换整个数组）
obj.items = [4, 5, 6]; // 这样会失去响应式

// 正确的做法
obj.items.splice(0, obj.items.length, 4, 5, 6);
```

---