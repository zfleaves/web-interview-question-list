# Vue3 的自定义渲染器

**答案：**

## 创建自定义渲染器

```javascript
import { createRenderer } from 'vue';

const renderer = createRenderer({
  createElement(tag) {
    return document.createElement(tag);
  },
  patchProp(el, key, prevValue, nextValue) {
    if (key === 'onClick') {
      el.onclick = nextValue;
    } else if (key in el) {
      el[key] = nextValue;
    } else {
      el.setAttribute(key, nextValue);
    }
  },
  insert(child, parent, anchor) {
    parent.insertBefore(child, anchor || null);
  },
  remove(child) {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createText(text) {
    return document.createTextNode(text);
  },
  setText(node, text) {
    node.nodeValue = text;
  }
});

const { createApp } = renderer;

createApp({
  data() {
    return { count: 0 };
  }
}).mount('#app');
```

## 实现 Canvas 渲染

```javascript
import { createRenderer } from 'vue';

const canvasRenderer = createRenderer({
  createElement(tag) {
    // 对于 canvas，返回一个虚拟节点
    return { tag, type: 'element', children: [], props: {} };
  },
  patchProp(el, key, prevValue, nextValue) {
    el.props[key] = nextValue;
  },
  insert(child, parent) {
    parent.children.push(child);
  },
  remove(child) {
    const index = parent.children.indexOf(child);
    if (index > -1) {
      parent.children.splice(index, 1);
    }
  },
  createText(text) {
    return { type: 'text', value: text };
  },
  setText(node, text) {
    node.value = text;
  },
  parentNode(node) {
    return node.parent;
  },
  nextSibling(node) {
    const parent = node.parent;
    const index = parent.children.indexOf(node);
    return parent.children[index + 1];
  }
});

// 使用 canvas 渲染器
const { createApp } = canvasRenderer;

createApp({
  data() {
    return { x: 0, y: 0 };
  },
  render() {
    return h('rect', {
      x: this.x,
      y: this.y,
      width: 100,
      height: 100,
      fill: 'red'
    });
  }
}).mount(canvasContainer);
```

---