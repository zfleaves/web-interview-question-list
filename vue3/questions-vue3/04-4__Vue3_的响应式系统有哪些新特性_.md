# 4. Vue3 的响应式系统有哪些新特性？

**答案：**

**1. Proxy 的优势：**

```javascript
import { reactive } from 'vue';

const state = reactive({
  user: { name: 'John' },
  items: [1, 2, 3]
});

// ✅ 可以检测对象属性的添加
state.user.age = 20; // 响应式

// ✅ 可以检测对象属性的删除
delete state.user.name; // 响应式

// ✅ 可以检测数组索引的变化
state.items[0] = 10; // 响应式

// ✅ 可以检测数组长度的变化
state.items.length = 0; // 响应式

// ✅ 可以检测 Map、Set
const map = reactive(new Map());
map.set('key', 'value'); // 响应式

const set = reactive(new Set());
set.add('value'); // 响应式
```

**2. 懒性代理：**

```javascript
// Vue2: 递归代理所有属性
const data = {
  user: {
    profile: {
      name: 'John'
    }
  }
};
// 即使不访问 user.profile，也会被代理

// Vue3: 懒性代理
const state = reactive({
  user: {
    profile: {
      name: 'John'
    }
  }
});
// 只有访问 state.user.profile 时，才会代理 profile
// 初始化速度更快
```

**3. 只读和浅层响应式：**

```javascript
import { reactive, readonly, shallowReactive, shallowReadonly } from 'vue';

// readonly: 创建只读代理
const original = reactive({ count: 0 });
const copy = readonly(original);

copy.count++; // ❌ 警告：不能修改只读代理

// shallowReactive: 浅层响应式
const state = shallowReactive({
  count: 0,
  nested: { value: 1 }
});

state.count++; // ✅ 响应式
state.nested.value++; // ❌ 非响应式

// shallowReadonly: 浅层只读
const state = shallowReadonly({
  count: 0,
  nested: { value: 1 }
});

state.count++; // ❌ 警告
state.nested.value++; // ✅ 可以修改（非响应式）
```

**4. toRaw 和 markRaw：**

```javascript
import { reactive, toRaw, markRaw } from 'vue';

// toRaw: 获取原始对象
const state = reactive({ count: 0 });
const original = toRaw(state);
console.log(original === state); // false
console.log(original === toRaw(state)); // true

// markRaw: 标记对象为非响应式
const foo = markRaw({
  nested: {}
});

const state = reactive({
  foo
});

state.foo.nested = 'bar'; // ❌ 非响应式

// 使用场景：
// 1. 不需要响应式的复杂对象
// 2. 第三方库实例（如浏览器 API）
// 3. 性能优化（避免不必要的代理）
```

**5. effectScope：**

```javascript
import { effectScope, reactive, watchEffect } from 'vue';

// 创建作用域
const scope = effectScope();

scope.run(() => {
  const state = reactive({ count: 0 });
  
  watchEffect(() => {
    console.log(state.count);
  });
});

// 停止作用域内的所有 effect
scope.stop();

// 使用场景：
// 1. 组件卸载时清理副作用
// 2. 测试时清理副作用
// 3. 插件开发时管理副作用
```
