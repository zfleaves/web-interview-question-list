# 6. Vue3 组件通信有哪些新方式？

**答案：**

**1. defineProps 和 defineEmits：**

```javascript
// Vue2
export default {
  props: {
    message: String
  },
  emits: ['update'],
  methods: {
    handleClick() {
      this.$emit('update', 'new message');
    }
  }
};

// Vue3: <script setup>
<script setup>
const props = defineProps({
  message: {
    type: String,
    required: true
  }
});

const emit = defineEmits(['update']);

const handleClick = () => {
  emit('update', 'new message');
};
</script>

// TypeScript 支持
<script setup lang="ts">
interface Props {
  message: string;
  count?: number;
}

interface Emits {
  (e: 'update', value: string): void;
  (e: 'delete', id: number): void;
}

const props = defineProps<Props>();
const emit = defineEmits<Emits>();
</script>
```

**2. defineExpose：**

```javascript
// Vue2
export default {
  methods: {
    publicMethod() {
      console.log('public method');
    }
  }
};

// Vue3: <script setup>
<script setup>
const count = ref(0);

const publicMethod = () => {
  console.log('public method');
};

// 暴露给父组件
defineExpose({
  count,
  publicMethod
});
</script>

// 父组件使用
<template>
  <ChildComponent ref="child" />
</template>

<script setup>
import { ref, onMounted } from 'vue';

const child = ref(null);

onMounted(() => {
  console.log(child.value.count); // 0
  child.value.publicMethod(); // 调用子组件方法
});
</script>
```

**3. v-model 升级：**

```javascript
// Vue2: v-model 默认使用 value 和 input 事件
<ChildComponent v-model="message" />

// Vue3: 支持多个 v-model
<ChildComponent 
  v-model="message"
  v-model:title="title"
  v-model:content="content"
/>

// 自定义组件
<script setup>
const props = defineProps(['modelValue', 'title', 'content']);
const emit = defineEmits(['update:modelValue', 'update:title', 'update:content']);

const updateValue = (value) => {
  emit('update:modelValue', value);
};

const updateTitle = (value) => {
  emit('update:title', value);
};

const updateContent = (value) => {
  emit('update:content', value);
};
</script>

// 自定义 v-model 修饰符
<ChildComponent v-model.capitalize="message" />

<script setup>
const props = defineProps({
  modelValue: String,
  modelModifiers: { default: () => ({}) }
});

const emit = defineEmits(['update:modelValue']);

const emitValue = (e) => {
  let value = e.target.value;
  if (props.modelModifiers.capitalize) {
    value = value.charAt(0).toUpperCase() + value.slice(1);
  }
  emit('update:modelValue', value);
};
</script>
```

**4. provide 和 inject 改进：**

```javascript
// Vue2
export default {
  provide() {
    return {
      theme: this.theme
    };
  }
};

// Vue3: 支持响应式和只读
<script setup>
import { provide, reactive, readonly } from 'vue';

const theme = reactive({
  color: 'blue',
  size: 'medium'
});

// 提供响应式数据
provide('theme', theme);

// 提供只读数据
provide('readonlyTheme', readonly(theme));

// 提供方法
provide('updateTheme', (color) => {
  theme.color = color;
});
</script>

// 后代组件
<script setup>
import { inject } from 'vue';

// 注入响应式数据
const theme = inject('theme');

// 注入只读数据
const readonlyTheme = inject('readonlyTheme');

// 注入方法
const updateTheme = inject('updateTheme');

// 提供默认值
const user = inject('user', { name: 'Guest' });

// TypeScript 支持
interface Theme {
  color: string;
  size: string;
}

const theme = inject<Theme>('theme');
</script>
```

**5. Teleport（传送门）：**

```javascript
// 将组件渲染到 DOM 的其他位置
<Teleport to="body">
  <div class="modal">
    Modal Content
  </div>
</Teleport>

// 传送到指定元素
<Teleport to="#modal-container">
  <div class="modal">
    Modal Content
  </div>
</Teleport>

// 禁用 Teleport
<Teleport to="body" :disabled="isInline">
  <div class="modal">
    Modal Content
  </div>
</Teleport>

// 使用场景：
// 1. Modal 弹窗
// 2. Toast 提示
// 3. Dropdown 下拉菜单
// 4. Tooltip 提示
```
