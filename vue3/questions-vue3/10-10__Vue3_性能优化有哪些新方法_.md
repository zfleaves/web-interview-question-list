# 10. Vue3 性能优化有哪些新方法？

**答案：**

**1. 静态提升：**

```javascript
// Vue2: 静态节点每次都重新创建
function render() {
  return h('div', [
    h('p', 'static text'), // 每次都创建
    h('p', this.message)
  ]);
}

// Vue3: 静态节点提升到外部
const _hoisted_1 = h('p', 'static text'); // 只创建一次

function render() {
  return h('div', [
    _hoisted_1, // 复用
    h('p', this.message)
  ]);
}

// 性能提升：减少 VNode 创建
```

**2. 补丁标记：**

```javascript
// Vue3 使用补丁标记，只 diff 有变化的部分
const PatchFlags = {
  TEXT: 1,           // 动态文本
  CLASS: 2,           // 动态 class
  STYLE: 4,           // 动态 style
  PROPS: 8,           // 动态属性
  EVENT: 32,          // 动态事件
  // ...
};

// 示例
function render() {
  return h('div', {
    class: isActive ? 'active' : '', // PatchFlags.CLASS
    onClick: handleClick              // PatchFlags.EVENT
  }, [
    h('p', message)                   // PatchFlags.TEXT
  ]);
}

// 性能提升：减少 diff 范围
```

**3. 块树（Block Tree）：**

```javascript
// Vue3 使用块树，只 diff 动态节点
<div>
  <p>static</p>
  <p>{{ message }}</p>
  <p>static</p>
  <p>{{ count }}</p>
</div>

// Vue2: diff 所有 4 个 p 标签
// Vue3: 只 diff 2 个动态节点

// 性能提升：大幅减少 diff 范围
```

**4. Tree-shaking：**

```javascript
// Vue2
import Vue from 'vue';
// 打包所有功能

// Vue3
import { ref, computed } from 'vue';
// 只打包使用的功能

// 性能提升：减少包体积
```

**5. 懒加载和异步组件：**

```javascript
// 路由懒加载
const routes = [
  {
    path: '/about',
    component: () => import('@/views/About.vue')
  }
];

// 异步组件
const AsyncComponent = defineAsyncComponent({
  loader: () => import('./AsyncComponent.vue'),
  loadingComponent: LoadingComponent,
  errorComponent: ErrorComponent,
  delay: 200,
  timeout: 3000
});

// Suspense
<Suspense>
  <template #default>
    <AsyncComponent />
  </template>
  <template #fallback>
    <Loading />
  </template>
</Suspense>
```

**6. 虚拟滚动：**

```javascript
// 使用 vue-virtual-scroller
import { RecycleScroller } from 'vue-virtual-scroller';

<RecycleScroller
  :items="items"
  :item-size="50"
  key-field="id"
  v-slot="{ item }"
>
  <div>{{ item.name }}</div>
</RecycleScroller>

// 性能提升：只渲染可见区域的元素
```

**7. computed 缓存：**

```javascript
import { computed } from 'vue';

const expensiveValue = computed(() => {
  // 复杂计算
  return heavyComputation();
});

// 计算属性会缓存结果，依赖不变不会重新计算
```

**8. markRaw 和 shallowReactive：**

```javascript
import { markRaw, shallowReactive } from 'vue';

// markRaw: 标记对象为非响应式
const largeData = markRaw(largeDataSet);
// 避免不必要的代理

// shallowReactive: 浅层响应式
const state = shallowReactive({
  count: 0,
  nested: { value: 1 }
});
// 只代理顶层属性，提高性能
```
