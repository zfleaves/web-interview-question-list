# 1. Vue2 的双向绑定原理是什么？

**答案：**

Vue2 的双向绑定是通过 **数据劫持** 结合 **发布-订阅模式** 实现的。

**核心实现：**

```javascript
// 1. Object.defineProperty 数据劫持
function observe(obj) {
  if (typeof obj !== 'object' || obj === null) return;
  
  Object.keys(obj).forEach(key => {
    let value = obj[key];
    let dep = new Dep(); // 依赖收集器
    
    Object.defineProperty(obj, key, {
      get() {
        // 收集依赖
        if (Dep.target) {
          dep.addSub(Dep.target);
        }
        return value;
      },
      set(newValue) {
        if (newValue !== value) {
          value = newValue;
          // 通知更新
          dep.notify();
        }
      }
    });
    
    // 递归劫持嵌套对象
    if (typeof value === 'object') {
      observe(value);
    }
  });
}

// 2. 依赖收集器
class Dep {
  constructor() {
    this.subs = [];
  }
  
  addSub(sub) {
    this.subs.push(sub);
  }
  
  notify() {
    this.subs.forEach(sub => sub.update());
  }
}

// 3. Watcher 观察者
class Watcher {
  constructor(vm, key, callback) {
    this.vm = vm;
    this.key = key;
    this.callback = callback;
    this.value = this.get();
  }
  
  get() {
    Dep.target = this;
    const value = this.vm[this.key];
    Dep.target = null;
    return value;
  }
  
  update() {
    const newValue = this.vm[this.key];
    if (newValue !== this.value) {
      this.value = newValue;
      this.callback.call(this.vm, newValue);
    }
  }
}
```

**v-model 实现原理：**

```javascript
// v-model = v-bind:value + v-on:input
<input v-model="message" />

// 编译后
<input
  :value="message"
  @input="message = $event.target.value"
/>

// 自定义组件的 v-model
Vue.component('my-input', {
  props: ['value'],
  template: `
    <input
      :value="value"
      @input="$emit('input', $event.target.value)"
    />
  `
});
```

**双向绑定流程：**

```
1. 数据变化 -> setter -> notify() -> Watcher.update() -> 视图更新
2. 视图变化 -> input事件 -> 数据更新 -> setter -> notify() -> Watcher.update()
```

---

## Dep.target 的作用和底层逻辑

**Dep.target 是什么？**

Dep.target 是一个全局静态变量，用于在依赖收集过程中**标识当前正在执行的 Watcher**。它是 Vue2 响应式系统中连接数据属性和观察者（Watcher）的关键桥梁。

**为什么需要 Dep.target？**

在 Vue2 的响应式系统中，当访问一个响应式对象的属性时，需要知道**是谁在访问这个属性**（即哪个 Watcher），这样才能将这个 Watcher 添加到该属性的依赖列表中。Dep.target 就是为了解决"如何知道当前是哪个 Watcher 在访问数据"这个问题而设计的。

**底层逻辑详解：**

```javascript
// Dep 类 - 依赖收集器
class Dep {
  constructor() {
    this.subs = []; // 存储所有订阅者（Watcher）
  }
  
  addSub(sub) {
    this.subs.push(sub);
  }
  
  depend() {
    // 如果当前有正在执行的 Watcher（Dep.target 不为空）
    // 就说明这个 Watcher 依赖了当前属性
    // 将当前 Watcher 添加到依赖列表中
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  }
  
  notify() {
    // 数据变化时，通知所有订阅者更新
    this.subs.forEach(sub => sub.update());
  }
}

// Dep.target 是一个全局静态变量
Dep.target = null;

// Watcher 类 - 观察者
class Watcher {
  constructor(vm, getter, callback) {
    this.vm = vm;
    this.getter = getter;
    this.callback = callback;
    this.deps = []; // 当前 Watcher 依赖了哪些 Dep
    this.value = this.get(); // 立即执行一次，收集依赖
  }
  
  get() {
    // 关键步骤 1: 将当前 Watcher 赋值给 Dep.target
    // 这样在后续访问数据属性时，getter 就能知道是谁在访问
    pushTarget(this); // Dep.target = this
    
    let value;
    try {
      // 关键步骤 2: 执行 getter 函数
      // 在这个过程中，会访问响应式对象的属性
      // 访问属性时会触发 getter，getter 中会检查 Dep.target
      value = this.getter.call(this.vm, this.vm);
    } finally {
      // 关键步骤 3: getter 执行完成后，清空 Dep.target
      // 避免影响其他 Watcher 的依赖收集
      popTarget(); // Dep.target = null
    }
    return value;
  }
  
  addDep(dep) {
    // 建立 Watcher 和 Dep 的双向关系
    // Watcher 记录自己依赖了哪些 Dep
    if (!this.deps.includes(dep)) {
      this.deps.push(dep);
      // Dep 记录自己有哪些 Watcher 订阅者
      dep.addSub(this);
    }
  }
  
  update() {
    // 数据变化时重新执行
    const newValue = this.get();
    if (newValue !== this.value) {
      const oldValue = this.value;
      this.value = newValue;
      this.callback.call(this.vm, newValue, oldValue);
    }
  }
}

// 目标栈管理 - 支持嵌套 Watcher
const targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
```

**依赖收集的完整流程：**

```
1. 创建 Watcher 实例
   ↓
2. Watcher.get() 被调用
   ↓
3. pushTarget(this) - 将当前 Watcher 设置为 Dep.target
   ↓
4. 执行 getter 函数（如渲染函数）
   ↓
5. getter 中访问响应式数据（如 vm.message）
   ↓
6. 触发 message 的 getter
   ↓
7. getter 中检查 Dep.target
   - 如果 Dep.target 存在，说明有 Watcher 正在访问
   - 调用 dep.depend() 或 dep.addSub(Dep.target)
   ↓
8. 将当前 Watcher 添加到 message 的依赖列表
   ↓
9. getter 执行完成
   ↓
10. popTarget() - 清空 Dep.target
```

**为什么要使用栈结构？**

```javascript
// 场景：嵌套的 Watcher
// 例如：computed 中访问另一个 computed
const vm = new Vue({
  data: {
    count: 0
  },
  computed: {
    doubleCount() {
      // 当前 Dep.target = Watcher(doubleCount)
      return this.count * 2;
    },
    quadrupleCount() {
      // 当前 Dep.target = Watcher(quadrupleCount)
      // 但在计算过程中访问了 doubleCount
      // doubleCount 的 Watcher 会被临时设置为 Dep.target
      return this.doubleCount * 2;
    }
  }
});

// 执行流程：
// 1. 渲染 Watcher 执行，Dep.target = 渲染 Watcher
// 2. 访问 quadrupleCount，Dep.target = Watcher(quadrupleCount)，栈 = [渲染 Watcher, Watcher(quadrupleCount)]
// 3. 访问 doubleCount，Dep.target = Watcher(doubleCount)，栈 = [渲染 Watcher, Watcher(quadrupleCount), Watcher(doubleCount)]
// 4. doubleCount 执行完成，popTarget，Dep.target = Watcher(quadrupleCount)
// 5. quadrupleCount 执行完成，popTarget，Dep.target = 渲染 Watcher
```

**实际应用示例：**

```javascript
// 组件渲染 Watcher
new Vue({
  el: '#app',
  data: {
    message: 'Hello',
    count: 0
  },
  computed: {
    reversedMessage() {
      // 当这个 computed 被访问时：
      // 1. Dep.target 设置为 Watcher(reversedMessage)
      // 2. 访问 this.message，触发 message 的 getter
      // 3. message 的 getter 发现 Dep.target 存在
      // 4. 将 Watcher(reversedMessage) 添加到 message 的依赖列表
      return this.message.split('').reverse().join('');
    }
  },
  template: `
    <div>
      <p>{{ message }}</p>  <!-- 渲染 Watcher 依赖 message -->
      <p>{{ reversedMessage }}</p>  <!-- 渲染 Watcher 依赖 reversedMessage -->
      <p>{{ count }}</p>  <!-- 渲染 Watcher 依赖 count -->
    </div>
  `
});

// 依赖关系图：
// message -> Dep.subs = [渲染 Watcher, Watcher(reversedMessage)]
// count -> Dep.subs = [渲染 Watcher]

// 当 message 变化时：
// 1. 触发 message 的 setter
// 2. dep.notify() 通知所有订阅者
// 3. 渲染 Watcher.update() - 重新渲染视图
// 4. Watcher(reversedMessage).update() - 重新计算 reversedMessage
```

**总结：**

Dep.target 的核心作用是：
1. **身份标识**：在依赖收集过程中标识当前正在执行的 Watcher
2. **桥梁作用**：连接数据属性的 getter 和 Watcher 的依赖收集
3. **生命周期管理**：通过 pushTarget/popTarget 管理 Watcher 的执行上下文
4. **支持嵌套**：使用栈结构支持嵌套的 Watcher 场景

没有 Dep.target，Vue2 就无法知道是哪个 Watcher 在访问数据，就无法建立数据与视图之间的依赖关系，响应式系统也就无法工作。
