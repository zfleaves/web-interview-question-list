# 10. 自定义指令如何实现？

**答案：**

**注册自定义指令：**

```javascript
// 全局注册
Vue.directive('focus', {
  inserted: function (el) {
    el.focus();
  }
});

// 局部注册
export default {
  directives: {
    focus: {
      inserted: function (el) {
        el.focus();
      }
    }
  }
};
```

**指令钩子函数：**

```javascript
Vue.directive('my-directive', {
  bind: function (el, binding, vnode) {
    // 只调用一次，指令第一次绑定到元素时调用
    // 在这里可以进行一次性的初始化设置
  },
  
  inserted: function (el, binding, vnode) {
    // 被绑定元素插入父节点时调用
    // 可以访问父节点
  },
  
  update: function (el, binding, vnode, oldVnode) {
    // 所在组件的 VNode 更新时调用
    // 可能发生在其子 VNode 更新之前
  },
  
  componentUpdated: function (el, binding, vnode, oldVnode) {
    // 指令所在组件的 VNode 及其子 VNode 全部更新后调用
  },
  
  unbind: function (el, binding, vnode) {
    // 只调用一次，指令与元素解绑时调用
  }
});
```

**钩子函数参数：**

```javascript
Vue.directive('example', {
  bind(el, binding, vnode, oldVnode) {
    // el: 指令所绑定的元素
    // binding: 一个对象
    // vnode: Vue 编译生成的虚拟节点
    // oldVnode: 上一个虚拟节点（仅在 update 和 componentUpdated 钩子中可用）
    
    console.log(binding.name);      // 指令名
    console.log(binding.value);    // 指令的绑定值
    console.log(binding.expression); // 指令的表达式
    console.log(binding.arg);      // 指令的参数
    console.log(binding.modifiers); // 指令的修饰符
  }
});
```

**实战示例：**

```javascript
// 1. 自动聚焦指令
Vue.directive('focus', {
  inserted(el) {
    el.focus();
  }
});

// 使用
<input v-focus>

// 2. 防抖指令
Vue.directive('debounce', {
  inserted(el, binding) {
    let timer;
    el.addEventListener('click', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        binding.value();
      }, binding.arg || 300);
    });
  }
});

// 使用
<button v-debounce:500="handleClick">Click</button>

// 3. 节流指令
Vue.directive('throttle', {
  inserted(el, binding) {
    let throttled = false;
    el.addEventListener('click', () => {
      if (!throttled) {
        binding.value();
        throttled = true;
        setTimeout(() => {
          throttled = false;
        }, binding.arg || 300);
      }
    });
  }
});

// 使用
<button v-throttle:1000="handleClick">Click</button>

// 4. 无限滚动指令
Vue.directive('infinite-scroll', {
  inserted(el, binding) {
    const callback = binding.value;
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.1
    };
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          callback();
        }
      });
    }, options);
    
    observer.observe(el);
    
    el._observer = observer;
  },
  
  unbind(el) {
    if (el._observer) {
      el._observer.disconnect();
    }
  }
});

// 使用
<div v-infinite-scroll="loadMore"></div>

// 5. 权限指令
Vue.directive('permission', {
  inserted(el, binding) {
    const { value } = binding;
    const permissions = store.getters.permissions;
    
    if (value && value instanceof Array && value.length > 0) {
      const hasPermission = value.some(permission => {
        return permissions.includes(permission);
      });
      
      if (!hasPermission) {
        el.parentNode && el.parentNode.removeChild(el);
      }
    } else {
      throw new Error('需要权限！');
    }
  }
});

// 使用
<button v-permission="['admin', 'editor']">Delete</button>

// 6. 复制到剪贴板指令
Vue.directive('copy', {
  bind(el, binding) {
    el.copyData = binding.value;
    el.addEventListener('click', handleClick);
  },
  
  update(el, binding) {
    el.copyData = binding.value;
  },
  
  unbind(el) {
    el.removeEventListener('click', handleClick);
  }
});

function handleClick() {
  const input = document.createElement('input');
  input.value = this.copyData;
  document.body.appendChild(input);
  input.select();
  document.execCommand('copy');
  document.body.removeChild(input);
  this.$message.success('复制成功');
}

// 使用
<button v-copy="text">Copy</button>
```
