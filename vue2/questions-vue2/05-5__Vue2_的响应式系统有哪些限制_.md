# 5. Vue2 的响应式系统有哪些限制？

**答案：**

**1. 无法检测对象属性的添加或删除：**

```javascript
const vm = new Vue({
  data: {
    user: {
      name: 'John'
    }
  }
});

// ❌ 无法检测
vm.user.age = 20; // 不是响应式的
delete vm.user.name; // 不是响应式的

// ✅ 解决方案
// Vue.set
Vue.set(vm.user, 'age', 20);

// this.$set
this.$set(this.user, 'age', 20);

// 重新赋值
vm.user = { ...vm.user, age: 20 };
```

**2. 无法检测数组索引和长度的变化：**

```javascript
const vm = new Vue({
  data: {
    items: [1, 2, 3]
  }
});

// ❌ 无法检测
vm.items[0] = 10; // 不是响应式的
vm.items.length = 0; // 不是响应式的

// ✅ 解决方案
// Vue.set
Vue.set(vm.items, 0, 10);

// this.$set
this.$set(this.items, 0, 10);

// 数组方法（Vue 重写了这些方法）
vm.items.push(4);
vm.items.pop();
vm.items.shift();
vm.items.unshift(0);
vm.items.splice(0, 1, 10);
vm.items.sort();
vm.items.reverse();
```

**3. 原因分析：**

```javascript
// Object.defineProperty 的限制
Object.defineProperty(obj, 'key', {
  get() {},
  set() {}
});

// 只能劫持已存在的属性
// 无法劫持数组索引
// 无法劫持对象属性的动态添加

// Vue2 的解决方案
// 1. 对象：递归劫持所有属性
// 2. 数组：重写数组方法
```

**数组方法重写：**

```javascript
const arrayProto = Array.prototype;
const arrayMethods = Object.create(arrayProto);

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

methodsToPatch.forEach(method => {
  const original = arrayProto[method];
  def(arrayMethods, method, function mutator(...args) {
    const result = original.apply(this, args);
    const ob = this.__ob__;
    let inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) ob.observeArray(inserted);
    ob.dep.notify();
    return result;
  });
});
```
