# 4. Vue2 的依赖收集机制是什么？

**答案：**

依赖收集是 Vue2 响应式的核心，通过 **Dep** 和 **Watcher** 实现。

**依赖收集流程：**

```javascript
// 1. 初始化时，触发 getter
const vm = new Vue({
  data: {
    message: 'Hello'
  },
  template: '<div>{{ message }}</div>'
});

// 2. 渲染时，访问 message
// message 的 getter 被触发
// Dep.target 指向当前 Watcher
// 将 Watcher 添加到 message 的 dep.subs 中

// 3. 数据变化时
vm.message = 'World';
// message 的 setter 被触发
// 遍历 dep.subs，调用每个 Watcher 的 update 方法
// Watcher 重新执行渲染函数
```

**Dep 类：**

```javascript
class Dep {
  constructor() {
    this.id = uid++;
    this.subs = [];
  }
  
  addSub(sub) {
    this.subs.push(sub);
  }
  
  removeSub(sub) {
    const index = this.subs.indexOf(sub);
    if (index > -1) {
      this.subs.splice(index, 1);
    }
  }
  
  depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  }
  
  notify() {
    const subs = this.subs.slice();
    subs.forEach(sub => sub.update());
  }
}

Dep.target = null;
```

**Watcher 类：**

```javascript
class Watcher {
  constructor(vm, expOrFn, cb, options) {
    this.vm = vm;
    this.cb = cb;
    this.deps = [];
    this.newDeps = [];
    this.depIds = new Set();
    this.newDepIds = new Set();
    
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
    }
    
    this.value = this.get();
  }
  
  get() {
    pushTarget(this);
    let value;
    try {
      value = this.getter.call(this.vm, this.vm);
    } catch (e) {
      if (this.user) {
        handleError(e, this.vm, `getter for watcher "${this.expression}"`);
      } else {
        throw e;
      }
    } finally {
      popTarget();
      this.cleanupDeps();
    }
    return value;
  }
  
  addDep(dep) {
    const id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  }
  
  cleanupDeps() {
    let i = this.deps.length;
    while (i--) {
      const dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    let tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  }
  
  update() {
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  }
  
  run() {
    if (this.active) {
      const value = this.get();
      if (value !== this.value || isObject(value) || this.deep) {
        const oldValue = this.value;
        this.value = value;
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`);
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  }
}
```

**依赖收集图示：**

```
data: {
  message: 'Hello',
  count: 0
}

message -> Dep {
  subs: [Watcher(render), Watcher(computed)]
}

count -> Dep {
  subs: [Watcher(render)]
}
```
