# 设计模式面试题集锦

## 1. 什么是设计模式？

**答案：**

设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

### 设计模式的分类

1. **创建型模式（Creational Patterns）**
   - 单例模式（Singleton）
   - 工厂方法模式（Factory Method）
   - 抽象工厂模式（Abstract Factory）
   - 建造者模式（Builder）
   - 原型模式（Prototype）

2. **结构型模式（Structural Patterns）**
   - 适配器模式（Adapter）
   - 装饰器模式（Decorator）
   - 代理模式（Proxy）
   - 外观模式（Facade）
   - 桥接模式（Bridge）
   - 组合模式（Composite）
   - 享元模式（Flyweight）

3. **行为型模式（Behavioral Patterns）**
   - 策略模式（Strategy）
   - 观察者模式（Observer）
   - 命令模式（Command）
   - 迭代器模式（Iterator）
   - 模板方法模式（Template Method）
   - 责任链模式（Chain of Responsibility）
   - 状态模式（State）
   - 备忘录模式（Memento）
   - 中介者模式（Mediator）
   - 解释器模式（Interpreter）
   - 访问者模式（Visitor）

---

## 2. 单例模式是什么？

**答案：**

单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。

### JavaScript 实现

```javascript
// 方式 1：使用闭包
const Singleton = (function() {
  let instance;

  function createInstance() {
    return {
      name: 'Singleton',
      method() {
        console.log('Singleton method');
      }
    };
  }

  return {
    getInstance() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

const s1 = Singleton.getInstance();
const s2 = Singleton.getInstance();
console.log(s1 === s2); // true

// 方式 2：使用类
class Singleton {
  static instance = null;

  constructor() {
    if (Singleton.instance) {
      return Singleton.instance;
    }
    this.name = 'Singleton';
    Singleton.instance = this;
  }

  method() {
    console.log('Singleton method');
  }
}

const s3 = new Singleton();
const s4 = new Singleton();
console.log(s3 === s4); // true

// 方式 3：使用 ES6 模块
// singleton.js
class Singleton {
  constructor() {
    this.name = 'Singleton';
  }

  method() {
    console.log('Singleton method');
  }
}

export default new Singleton();

// main.js
import singleton from './singleton.js';
```

### 应用场景

1. **全局配置对象**
2. **数据库连接池**
3. **日志记录器**
4. **浏览器窗口对象**

### 优缺点

**优点：**
- 提供了对唯一实例的受控访问
- 节约系统资源

**缺点：**
- 难以进行单元测试
- 不符合单一职责原则

---

## 3. 工厂模式是什么？

**答案：**

工厂模式提供了一种创建对象的最佳方式，在创建对象时不会对客户端暴露创建逻辑。

### 简单工厂模式

```javascript
class Product {
  constructor(name) {
    this.name = name;
  }

  operation() {
    console.log(`Product: ${this.name}`);
  }
}

class Factory {
  static createProduct(type) {
    switch (type) {
      case 'A':
        return new Product('Product A');
      case 'B':
        return new Product('Product B');
      default:
        throw new Error('Unknown product type');
    }
  }
}

const productA = Factory.createProduct('A');
productA.operation(); // Product: Product A
```

### 工厂方法模式

```javascript
class Product {
  constructor(name) {
    this.name = name;
  }

  operation() {
    console.log(`Product: ${this.name}`);
  }
}

class ProductA extends Product {
  constructor() {
    super('Product A');
  }
}

class ProductB extends Product {
  constructor() {
    super('Product B');
  }
}

class Factory {
  createProduct() {
    throw new Error('This method should be overridden');
  }
}

class FactoryA extends Factory {
  createProduct() {
    return new ProductA();
  }
}

class FactoryB extends Factory {
  createProduct() {
    return new ProductB();
  }
}

const factoryA = new FactoryA();
const product1 = factoryA.createProduct();
product1.operation(); // Product: Product A
```

### 抽象工厂模式

```javascript
class AbstractFactory {
  createProductA() {
    throw new Error('This method should be overridden');
  }

  createProductB() {
    throw new Error('This method should be overridden');
  }
}

class ConcreteFactory1 extends AbstractFactory {
  createProductA() {
    return new ProductA1();
  }

  createProductB() {
    return new ProductB1();
  }
}

class ConcreteFactory2 extends AbstractFactory {
  createProductA() {
    return new ProductA2();
  }

  createProductB() {
    return new ProductB2();
  }
}

const factory1 = new ConcreteFactory1();
const productA1 = factory1.createProductA();
const productB1 = factory1.createProductB();
```

### 应用场景

1. **日志记录器**（文件日志、数据库日志）
2. **数据库连接**（MySQL、PostgreSQL、MongoDB）
3. **UI 组件创建**（不同平台的组件）

---

## 4. 观察者模式是什么？

**答案：**

观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

### JavaScript 实现

```javascript
class Subject {
  constructor() {
    this.observers = [];
  }

  addObserver(observer) {
    this.observers.push(observer);
  }

  removeObserver(observer) {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  notify(data) {
    this.observers.forEach(observer => {
      observer.update(data);
    });
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`${this.name} received: ${data}`);
  }
}

// 使用
const subject = new Subject();
const observer1 = new Observer('Observer 1');
const observer2 = new Observer('Observer 2');

subject.addObserver(observer1);
subject.addObserver(observer2);

subject.notify('Hello World');
// Observer 1 received: Hello World
// Observer 2 received: Hello World
```

### Vue 中的观察者模式

```javascript
// Vue 的响应式原理
class Dep {
  constructor() {
    this.subs = [];
  }

  addSub(sub) {
    this.subs.push(sub);
  }

  notify() {
    this.subs.forEach(sub => sub.update());
  }
}

class Watcher {
  constructor(vm, expOrFn, cb) {
    this.vm = vm;
    this.expOrFn = expOrFn;
    this.cb = cb;
    this.value = this.get();
  }

  get() {
    Dep.target = this;
    const value = this.vm[this.expOrFn];
    Dep.target = null;
    return value;
  }

  update() {
    const newValue = this.get();
    const oldValue = this.value;
    if (newValue !== oldValue) {
      this.value = newValue;
      this.cb.call(this.vm, newValue, oldValue);
    }
  }
}
```

### 应用场景

1. **事件监听**（DOM 事件、自定义事件）
2. **Vue/React 的响应式系统**
3. **消息队列**
4. **发布-订阅系统**

---

## 5. 策略模式是什么？

**答案：**

策略模式定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。

### JavaScript 实现

```javascript
// 策略接口
const strategies = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  },
  multiply(a, b) {
    return a * b;
  },
  divide(a, b) {
    return b !== 0 ? a / b : 'Cannot divide by zero';
  }
};

// 上下文
class Calculator {
  constructor(strategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy) {
    this.strategy = strategy;
  }

  execute(a, b) {
    return this.strategy(a, b);
  }
}

// 使用
const calculator = new Calculator(strategies.add);
console.log(calculator.execute(5, 3)); // 8

calculator.setStrategy(strategies.multiply);
console.log(calculator.execute(5, 3)); // 15
```

### 实际应用：表单验证

```javascript
const validators = {
  required(value) {
    return value.trim() !== '';
  },
  minLength(value, length) {
    return value.length >= length;
  },
  isEmail(value) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
  }
};

class FormValidator {
  constructor() {
    this.validators = [];
  }

  addValidator(validator, message) {
    this.validators.push({ validator, message });
  }

  validate(value) {
    for (const { validator, message } of this.validators) {
      if (!validator(value)) {
        return message;
      }
    }
    return null;
  }
}

// 使用
const emailValidator = new FormValidator();
emailValidator.addValidator(validators.required, 'Email is required');
emailValidator.addValidator(validators.isEmail, 'Invalid email format');

console.log(emailValidator.validate('')); // Email is required
console.log(emailValidator.validate('invalid')); // Invalid email format
console.log(emailValidator.validate('test@example.com')); // null
```

### 应用场景

1. **表单验证**
2. **支付方式**（支付宝、微信、银行卡）
3. **排序算法**（冒泡排序、快速排序、归并排序）
4. **压缩算法**（ZIP、RAR、7Z）

---

## 6. 适配器模式是什么？

**答案：**

适配器模式将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

### JavaScript 实现

```javascript
// 目标接口
class Target {
  request() {
    return 'Target: The default target\'s behavior.';
  }
}

// 需要适配的类
class Adaptee {
  specificRequest() {
    return '.eetpadA eht fo roivaheb laicepS';
  }
}

// 适配器
class Adapter extends Target {
  constructor(adaptee) {
    super();
    this.adaptee = adaptee;
  }

  request() {
    const result = this.adaptee.specificRequest();
    return `Adapter: (TRANSLATED) ${result.split('').reverse().join('')}`;
  }
}

// 使用
const adaptee = new Adaptee();
const adapter = new Adapter(adaptee);
console.log(adapter.request());
// Adapter: (TRANSLATED) Special behavior of the Adaptee.
```

### 实际应用：API 适配

```javascript
// 旧 API
class OldAPI {
  getUserName() {
    return 'John Doe';
  }

  getUserAge() {
    return 30;
  }
}

// 新 API 接口
class NewAPI {
  getUserInfo() {
    return {
      name: '',
      age: 0
    };
  }
}

// 适配器
class APIAdapter extends NewAPI {
  constructor(oldAPI) {
    super();
    this.oldAPI = oldAPI;
  }

  getUserInfo() {
    return {
      name: this.oldAPI.getUserName(),
      age: this.oldAPI.getUserAge()
    };
  }
}

// 使用
const oldAPI = new OldAPI();
const adapter = new APIAdapter(oldAPI);
console.log(adapter.getUserInfo()); // { name: 'John Doe', age: 30 }
```

### 应用场景

1. **旧系统与新系统的集成**
2. **第三方库的接口适配**
3. **不同数据格式的转换**

---

## 7. 装饰器模式是什么？

**答案：**

装饰器模式动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式相比生成子类更为灵活。

### JavaScript 实现

```javascript
class Coffee {
  cost() {
    return 10;
  }

  description() {
    return 'Coffee';
  }
}

// 装饰器基类
class CoffeeDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }

  cost() {
    return this.coffee.cost();
  }

  description() {
    return this.coffee.description();
  }
}

// 具体装饰器
class MilkDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 2;
  }

  description() {
    return `${this.coffee.description()}, Milk`;
  }
}

class SugarDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 1;
  }

  description() {
    return `${this.coffee.description()}, Sugar`;
  }
}

// 使用
let coffee = new Coffee();
console.log(coffee.description(), coffee.cost()); // Coffee 10

coffee = new MilkDecorator(coffee);
console.log(coffee.description(), coffee.cost()); // Coffee, Milk 12

coffee = new SugarDecorator(coffee);
console.log(coffee.description(), coffee.cost()); // Coffee, Milk, Sugar 13
```

### React 高阶组件（HOC）

```javascript
// 装饰器模式在 React 中的应用
function withLoading(WrappedComponent) {
  return function WithLoadingComponent(props) {
    if (props.isLoading) {
      return <div>Loading...</div>;
    }
    return <WrappedComponent {...props} />;
  };
}

// 使用
const UserProfile = ({ user }) => {
  return <div>{user.name}</div>;
};

const UserProfileWithLoading = withLoading(UserProfile);

// 使用
<UserProfileWithLoading isLoading={true} user={null} />
<UserProfileWithLoading isLoading={false} user={{ name: 'John' }} />
```

### 应用场景

1. **React 高阶组件**
2. **日志记录**
3. **性能监控**
4. **权限控制**

---

## 8. 代理模式是什么？

**答案：**

代理模式为其他对象提供一种代理以控制对这个对象的访问。

### JavaScript 实现

```javascript
class RealSubject {
  request() {
    console.log('RealSubject: Handling request.');
  }
}

class Proxy {
  constructor(realSubject) {
    this.realSubject = realSubject;
  }

  request() {
    if (this.checkAccess()) {
      this.realSubject.request();
      this.logAccess();
    }
  }

  checkAccess() {
    console.log('Proxy: Checking access before firing a real request.');
    return true;
  }

  logAccess() {
    console.log('Proxy: Logging the time of request.');
  }
}

// 使用
const realSubject = new RealSubject();
const proxy = new Proxy(realSubject);
proxy.request();
```

### ES6 Proxy

```javascript
const target = {
  name: 'John',
  age: 30
};

const handler = {
  get(target, property) {
    console.log(`Getting ${property}`);
    return target[property];
  },
  set(target, property, value) {
    console.log(`Setting ${property} to ${value}`);
    target[property] = value;
    return true;
  }
};

const proxy = new Proxy(target, handler);

console.log(proxy.name); // Getting name, John
proxy.age = 31; // Setting age to 31
```

### 应用场景

1. **远程代理**（RPC）
2. **虚拟代理**（图片懒加载）
3. **保护代理**（权限控制）
4. **智能引用**（引用计数）

---

## 9. 模板方法模式是什么？

**答案：**

模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

### JavaScript 实现

```javascript
class AbstractClass {
  templateMethod() {
    this.step1();
    this.step2();
    this.step3();
  }

  step1() {
    throw new Error('This method should be overridden');
  }

  step2() {
    throw new Error('This method should be overridden');
  }

  step3() {
    throw new Error('This method should be overridden');
  }
}

class ConcreteClass extends AbstractClass {
  step1() {
    console.log('ConcreteClass: Step 1');
  }

  step2() {
    console.log('ConcreteClass: Step 2');
  }

  step3() {
    console.log('ConcreteClass: Step 3');
  }
}

// 使用
const concrete = new ConcreteClass();
concrete.templateMethod();
// ConcreteClass: Step 1
// ConcreteClass: Step 2
// ConcreteClass: Step 3
```

### 实际应用：数据导出

```javascript
class DataExporter {
  export(data) {
    this.validate(data);
    const formattedData = this.format(data);
    this.save(formattedData);
  }

  validate(data) {
    if (!data || data.length === 0) {
      throw new Error('Data is empty');
    }
  }

  format(data) {
    throw new Error('This method should be overridden');
  }

  save(data) {
    throw new Error('This method should be overridden');
  }
}

class CSVExporter extends DataExporter {
  format(data) {
    return data.map(row => row.join(',')).join('\n');
  }

  save(data) {
    console.log(`Saving CSV:\n${data}`);
  }
}

class JSONExporter extends DataExporter {
  format(data) {
    return JSON.stringify(data, null, 2);
  }

  save(data) {
    console.log(`Saving JSON:\n${data}`);
  }
}

// 使用
const csvExporter = new CSVExporter();
const jsonExporter = new JSONExporter();

const data = [
  ['name', 'age'],
  ['John', 30],
  ['Jane', 25]
];

csvExporter.export(data);
jsonExporter.export(data);
```

### 应用场景

1. **算法骨架**
2. **数据处理流程**
3. **业务流程模板**

---

## 10. 责任链模式是什么？

**答案：**

责任链模式使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

### JavaScript 实现

```javascript
class Handler {
  constructor() {
    this.nextHandler = null;
  }

  setNext(handler) {
    this.nextHandler = handler;
    return handler;
  }

  handle(request) {
    if (this.nextHandler) {
      return this.nextHandler.handle(request);
    }
    return null;
  }
}

class ConcreteHandler1 extends Handler {
  handle(request) {
    if (request === 'request1') {
      return `Handled by Handler1: ${request}`;
    }
    return super.handle(request);
  }
}

class ConcreteHandler2 extends Handler {
  handle(request) {
    if (request === 'request2') {
      return `Handled by Handler2: ${request}`;
    }
    return super.handle(request);
  }
}

class ConcreteHandler3 extends Handler {
  handle(request) {
    if (request === 'request3') {
      return `Handled by Handler3: ${request}`;
    }
    return super.handle(request);
  }
}

// 使用
const handler1 = new ConcreteHandler1();
const handler2 = new ConcreteHandler2();
const handler3 = new ConcreteHandler3();

handler1.setNext(handler2).setNext(handler3);

console.log(handler1.handle('request1')); // Handled by Handler1: request1
console.log(handler1.handle('request2')); // Handled by Handler2: request2
console.log(handler1.handle('request3')); // Handled by Handler3: request3
```

### 实际应用：审批流程

```javascript
class Approver {
  constructor(name) {
    this.name = name;
    this.nextApprover = null;
  }

  setNext(approver) {
    this.nextApprover = approver;
    return approver;
  }

  approve(amount) {
    if (this.nextApprover) {
      return this.nextApprover.approve(amount);
    }
    console.log(`${this.name}: Cannot approve ${amount}`);
    return false;
  }
}

class Manager extends Approver {
  approve(amount) {
    if (amount <= 1000) {
      console.log(`${this.name}: Approved ${amount}`);
      return true;
    }
    return super.approve(amount);
  }
}

class Director extends Approver {
  approve(amount) {
    if (amount <= 5000) {
      console.log(`${this.name}: Approved ${amount}`);
      return true;
    }
    return super.approve(amount);
  }
}

class CEO extends Approver {
  approve(amount) {
    console.log(`${this.name}: Approved ${amount}`);
    return true;
  }
}

// 使用
const manager = new Manager('Manager');
const director = new Director('Director');
const ceo = new CEO('CEO');

manager.setNext(director).setNext(ceo);

manager.approve(500);   // Manager: Approved 500
manager.approve(2000);  // Director: Approved 2000
manager.approve(10000); // CEO: Approved 10000
```

### 应用场景

1. **审批流程**
2. **异常处理**
3. **日志记录**
4. **事件处理**

---

## 总结

设计模式是软件开发中的重要概念，掌握设计模式可以：

1. **提高代码质量**：使代码更易读、易维护
2. **提高开发效率**：避免重复造轮子
3. **提高系统可扩展性**：使系统更容易扩展

**常用设计模式：**
- **单例模式**：全局唯一实例
- **工厂模式**：对象创建
- **观察者模式**：事件驱动
- **策略模式**：算法替换
- **适配器模式**：接口转换
- **装饰器模式**：功能增强
- **代理模式**：访问控制
- **模板方法模式**：算法骨架
- **责任链模式**：请求传递