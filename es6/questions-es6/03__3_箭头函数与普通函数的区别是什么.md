## 3. 箭头函数与普通函数的区别是什么？

**答案：**

### 1. 语法更简洁

```javascript
// 普通函数
function add(a, b) {
  return a + b;
}

// 箭头函数
const add = (a, b) => a + b;

// 无参数
const fn1 = () => console.log('hello');

// 一个参数
const fn2 = x => x * 2;

// 多个参数
const fn3 = (x, y) => x + y;

// 函数体有多行
const fn4 = (x, y) => {
  const sum = x + y;
  return sum * 2;
};
```

### 2. 没有自己的 this

**普通函数：** this 的指向在运行时确定

```javascript
const obj = {
  name: 'test',
  a: function() {
    console.log(this.name); // 'test'
  },
  b: () => {
    console.log(this.name); // undefined（严格模式）或 window.name
  }
};

obj.a(); // 'test'
obj.b(); // undefined
```

**箭头函数：** 继承定义时外层作用域的 this

```javascript
function Person() {
  this.age = 0;

  // 普通函数
  setInterval(function() {
    this.age++; // this 指向 window
  }, 1000);

  // 箭头函数
  setInterval(() => {
    this.age++; // this 继承自 Person
  }, 1000);
}

const p = new Person();
```

### 3. 不能作为构造函数

```javascript
// 普通函数
function Person(name) {
  this.name = name;
}

const p1 = new Person('test'); // 可以

// 箭头函数
const Person2 = (name) => {
  this.name = name;
};

const p2 = new Person2('test'); // TypeError: Person2 is not a constructor
```

### 4. 没有 arguments 对象

```javascript
// 普通函数
function fn1() {
  console.log(arguments); // Arguments 对象
}

fn1(1, 2, 3);

// 箭头函数
const fn2 = () => {
  console.log(arguments); // ReferenceError: arguments is not defined
};

fn2(1, 2, 3);

// 箭头函数使用剩余参数
const fn3 = (...args) => {
  console.log(args); // [1, 2, 3]
};

fn3(1, 2, 3);
```

### 5. 没有 prototype

```javascript
// 普通函数
function fn1() {}
console.log(fn1.prototype); // {}

// 箭头函数
const fn2 = () => {};
console.log(fn2.prototype); // undefined
```

### 6. 不能使用 yield 关键字

```javascript
// 普通函数可以作为 Generator
function* gen1() {
  yield 1;
}

// 箭头函数不能作为 Generator
const gen2 = () => {
  yield 1; // SyntaxError: Unexpected token yield
};
```

### 7. call、apply、bind 无法改变 this

```javascript
const obj = { name: 'test' };

// 普通函数
function fn1() {
  console.log(this.name);
}

fn1.call(obj); // 'test'
fn1.apply(obj); // 'test'
const bound1 = fn1.bind(obj);
bound1(); // 'test'

// 箭头函数
const fn2 = () => {
  console.log(this.name);
};

fn2.call(obj); // undefined
fn2.apply(obj); // undefined
const bound2 = fn2.bind(obj);
bound2(); // undefined
```

### 使用场景

**适合使用箭头函数的场景：**

```javascript
// 1. 回调函数
array.map(item => item * 2);

// 2. 定时器
setTimeout(() => {
  console.log('hello');
}, 1000);

// 3. Promise
fetch(url).then(response => response.json());

// 4. 保持 this 指向
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    setTimeout(() => {
      console.log(`Hello, ${this.name}`);
    }, 1000);
  }
}
```

**不适合使用箭头函数的场景：**

```javascript
// 1. 对象方法
const obj = {
  name: 'test',
  sayHello: () => {
    console.log(`Hello, ${this.name}`); // this 不是 obj
  }
};

// 2. 原型方法
function Person() {}
Person.prototype.sayHello = () => {
  console.log('hello'); // this 不是实例
};

// 3. 构造函数
const Person = () => {};
new Person(); // 报错

// 4. 需要使用 arguments 的函数
const fn = () => {
  console.log(arguments); // 报错
};
```

---
