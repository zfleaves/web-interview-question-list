## 7. 小程序的组件通信有哪些方式？

**答案：**

### 父子组件通信

```javascript
// 父组件
<child-component message="{{parentMessage}}" bind:customEvent="onCustomEvent" />

Page({
  data: {
    parentMessage: 'Hello from parent'
  },
  
  onCustomEvent(e) {
    console.log(e.detail); // 来自子组件的数据
  }
});

// 子组件
Component({
  properties: {
    message: {
      type: String,
      value: ''
    }
  },
  
  methods: {
    triggerEvent() {
      this.triggerEvent('customEvent', { data: 'Hello from child' });
    }
  }
});
```

### 兄弟组件通信

```javascript
// 使用全局变量或事件总线
// app.js
App({
  globalData: {},
  
  // 事件总线
  eventBus: {
    events: {},
    on(event, callback) {
      if (!this.events[event]) {
        this.events[event] = [];
      }
      this.events[event].push(callback);
    },
    emit(event, data) {
      if (this.events[event]) {
        this.events[event].forEach(callback => callback(data));
      }
    }
  }
});

// 组件 A
const app = getApp();
app.eventBus.emit('custom-event', { data: 'test' });

// 组件 B
const app = getApp();
app.eventBus.on('custom-event', (data) => {
  console.log(data);
});
```

### 跨页面通信

```javascript
// 使用全局变量
const app = getApp();
app.globalData.sharedData = 'shared data';

// 使用 Storage
wx.setStorageSync('sharedData', 'shared data');

// 使用 EventChannel（页面间通信）
// 页面 A
wx.navigateTo({
  url: '/pages/detail/detail',
  events: {
    someEvent(data) {
      console.log(data);
    }
  }
});

// 页面 B
const eventChannel = this.getOpenerEventChannel();
eventChannel.emit('someEvent', { data: 'test' });
```

---