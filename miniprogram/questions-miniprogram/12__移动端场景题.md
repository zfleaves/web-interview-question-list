## 移动端场景题

### 1. H5 如何解决移动端适配问题？

**答案：**

移动端适配是前端开发中的核心问题，需要根据不同设备和屏幕尺寸进行适配。

**方案 1：rem 适配**

```javascript
// 设置根元素字体大小
function setRem() {
  const designWidth = 750; // 设计稿宽度
  const clientWidth = document.documentElement.clientWidth || window.innerWidth;
  const fontSize = (clientWidth / designWidth) * 100;
  
  document.documentElement.style.fontSize = fontSize + 'px';
}

// 初始化
setRem();

// 监听窗口变化
window.addEventListener('resize', setRem);
window.addEventListener('orientationchange', setRem);

// 使用 rem
.container {
  width: 7.5rem; // 750px
  height: 3rem;  // 300px
}
```

**方案 2：vw/vh 适配**

```css
/* 使用 vw/vh */
.container {
  width: 100vw;
  height: 50vh;
  font-size: 4vw;
}

/* 使用 calc 混合单位 */
.element {
  width: calc(100vw - 2rem);
  height: calc(100vh - 3rem);
}
```

**方案 3：媒体查询适配**

```css
/* 基础样式 */
.container {
  width: 100%;
  padding: 10px;
}

/* 小屏手机 */
@media screen and (max-width: 375px) {
  .container {
    padding: 8px;
    font-size: 14px;
  }
}

/* 中屏手机 */
@media screen and (min-width: 376px) and (max-width: 414px) {
  .container {
    padding: 10px;
    font-size: 16px;
  }
}

/* 大屏手机 */
@media screen and (min-width: 415px) {
  .container {
    padding: 12px;
    font-size: 18px;
  }
}
```

**方案 4：postcss-pxtorem 自动转换**

```javascript
// postcss.config.js
module.exports = {
  plugins: {
    'postcss-pxtorem': {
      rootValue: 37.5, // 设计稿宽度的 1/10
      propList: ['*'],
      selectorBlackList: ['.no-rem'], // 不转换的类名
      replace: true,
      mediaQuery: false,
      minPixelValue: 2 // 小于 2px 不转换
    }
  }
};
```

**方案 5：flex 布局适配**

```css
/* 使用 flex 实现自适应布局 */
.container {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
}

.item {
  flex: 0 0 calc(33.333% - 10px); /* 三列布局 */
  margin: 5px;
}

@media screen and (max-width: 768px) {
  .item {
    flex: 0 0 calc(50% - 10px); /* 两列布局 */
  }
}

@media screen and (max-width: 480px) {
  .item {
    flex: 0 0 100%; /* 单列布局 */
  }
}
```

**方案 6：viewport 适配**

```html
<!-- 动态设置 viewport -->
<meta name="viewport" id="viewport" content="width=device-width, initial-scale=1.0">

<script>
  const viewport = document.getElementById('viewport');
  const dpr = window.devicePixelRatio || 1;
  
  // 设置 viewport
  viewport.setAttribute('content', 
    `width=device-width, initial-scale=${1/dpr}, maximum-scale=${1/dpr}, user-scalable=no`);
  
  // 解决 1px 边框问题
  document.documentElement.setAttribute('data-dpr', dpr);
</script>

<style>
  /* 解决 1px 边框问题 */
  [data-dpr="1"] .border-1px {
    border: 1px solid #ddd;
  }
  
  [data-dpr="2"] .border-1px {
    border: 0.5px solid #ddd;
  }
  
  [data-dpr="3"] .border-1px {
    border: 0.333px solid #ddd;
  }
</style>
```

**最佳实践：**

```javascript
// 综合适配方案
class MobileAdapter {
  constructor() {
    this.designWidth = 750;
    this.maxWidth = 540; // 最大宽度（PC端）
    this.init();
  }
  
  init() {
    this.setRem();
    this.setViewport();
    this.bindEvents();
  }
  
  setRem() {
    const clientWidth = document.documentElement.clientWidth || window.innerWidth;
    const actualWidth = Math.min(clientWidth, this.maxWidth);
    const fontSize = (actualWidth / this.designWidth) * 100;
    
    document.documentElement.style.fontSize = fontSize + 'px';
  }
  
  setViewport() {
    const dpr = window.devicePixelRatio || 1;
    const meta = document.querySelector('meta[name="viewport"]');
    
    if (meta) {
      meta.setAttribute('content', 
        `width=device-width, initial-scale=${1/dpr}, maximum-scale=${1/dpr}, user-scalable=no`);
    }
  }
  
  bindEvents() {
    window.addEventListener('resize', this.setRem.bind(this));
    window.addEventListener('orientationchange', this.setRem.bind(this));
  }
}

// 使用
new MobileAdapter();
```

---

### 2. 移动端如何实现上拉加载，下拉刷新？

**答案：**

上拉加载和下拉刷新是移动端常见的交互模式。

**方案 1：使用 Touch 事件实现**

```javascript
class PullToRefresh {
  constructor(element, options = {}) {
    this.element = element;
    this.options = {
      threshold: 60, // 触发阈值
      ...options
    };
    
    this.startY = 0;
    this.currentY = 0;
    this.isDragging = false;
    this.isLoading = false;
    
    this.init();
  }
  
  init() {
    this.element.addEventListener('touchstart', this.handleTouchStart.bind(this));
    this.element.addEventListener('touchmove', this.handleTouchMove.bind(this));
    this.element.addEventListener('touchend', this.handleTouchEnd.bind(this));
  }
  
  handleTouchStart(e) {
    if (this.isLoading) return;
    
    this.startY = e.touches[0].clientY;
    this.isDragging = true;
  }
  
  handleTouchMove(e) {
    if (!this.isDragging || this.isLoading) return;
    
    this.currentY = e.touches[0].clientY;
    const diff = this.currentY - this.startY;
    
    // 只在顶部时才触发下拉
    if (this.element.scrollTop === 0 && diff > 0) {
      e.preventDefault();
      
      // 计算下拉距离
      const distance = Math.min(diff * 0.5, this.options.threshold * 1.5);
      
      // 更新 UI
      this.updateRefreshUI(distance);
    }
  }
  
  handleTouchEnd() {
    if (!this.isDragging) return;
    
    this.isDragging = false;
    
    // 判断是否达到触发阈值
    if (this.currentY - this.startY >= this.options.threshold) {
      this.triggerRefresh();
    } else {
      this.resetRefreshUI();
    }
  }
  
  updateRefreshUI(distance) {
    const refreshElement = this.element.querySelector('.refresh-indicator');
    if (refreshElement) {
      refreshElement.style.height = `${distance}px`;
      refreshElement.style.opacity = distance / this.options.threshold;
    }
  }
  
  resetRefreshUI() {
    const refreshElement = this.element.querySelector('.refresh-indicator');
    if (refreshElement) {
      refreshElement.style.height = '0px';
      refreshElement.style.opacity = '0';
    }
  }
  
  async triggerRefresh() {
    this.isLoading = true;
    
    // 显示加载状态
    const refreshElement = this.element.querySelector('.refresh-indicator');
    if (refreshElement) {
      refreshElement.innerHTML = '加载中...';
      refreshElement.style.height = `${this.options.threshold}px`;
    }
    
    // 执行刷新回调
    if (this.options.onRefresh) {
      await this.options.onRefresh();
    }
    
    // 重置状态
    this.isLoading = false;
    this.resetRefreshUI();
  }
}

// 使用
const container = document.querySelector('.content-container');
const pullToRefresh = new PullToRefresh(container, {
  threshold: 60,
  onRefresh: async () => {
    // 刷新数据
    await fetchData();
    console.log('刷新完成');
  }
});
```

**方案 2：使用 Intersection Observer 实现上拉加载**

```javascript
class InfiniteScroll {
  constructor(options = {}) {
    this.options = {
      threshold: 100, // 距离底部多少像素时触发
      ...options
    };
    
    this.isLoading = false;
    this.hasMore = true;
    this.init();
  }
  
  init() {
    // 创建触发元素
    this.triggerElement = document.createElement('div');
    this.triggerElement.style.height = '1px';
    this.triggerElement.style.visibility = 'hidden';
    document.body.appendChild(this.triggerElement);
    
    // 使用 Intersection Observer
    this.observer = new IntersectionObserver(
      this.handleIntersect.bind(this),
      {
        rootMargin: `${this.options.threshold}px`
      }
    );
    
    this.observer.observe(this.triggerElement);
  }
  
  handleIntersect(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadMore();
      }
    });
  }
  
  async loadMore() {
    if (this.isLoading || !this.hasMore) return;
    
    this.isLoading = true;
    
    // 显示加载状态
    this.showLoadingIndicator();
    
    // 执行加载回调
    if (this.options.onLoadMore) {
      const result = await this.options.onLoadMore();
      
      // 更新状态
      this.hasMore = result.hasMore || false;
    }
    
    // 隐藏加载状态
    this.hideLoadingIndicator();
    this.isLoading = false;
  }
  
  showLoadingIndicator() {
    const indicator = document.querySelector('.loading-indicator');
    if (indicator) {
      indicator.style.display = 'block';
    }
  }
  
  hideLoadingIndicator() {
    const indicator = document.querySelector('.loading-indicator');
    if (indicator) {
      indicator.style.display = 'none';
    }
  }
  
  destroy() {
    if (this.observer) {
      this.observer.disconnect();
    }
    if (this.triggerElement) {
      document.body.removeChild(this.triggerElement);
    }
  }
}

// 使用
const infiniteScroll = new InfiniteScroll({
  threshold: 100,
  onLoadMore: async () => {
    // 加载更多数据
    const newData = await fetchMoreData();
    renderItems(newData);
    
    return {
      hasMore: newData.length > 0
    };
  }
});
```

**方案 3：使用 React Hook 实现**

```javascript
import { useState, useEffect, useCallback } from 'react';

function useInfiniteScroll(options = {}) {
  const [isLoading, setIsLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(1);
  
  const { threshold = 100, onLoadMore } = options;
  
  useEffect(() => {
    const handleScroll = () => {
      const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
      
      if (scrollTop + clientHeight >= scrollHeight - threshold && !isLoading && hasMore) {
        loadMore();
      }
    };
    
    window.addEventListener('scroll', handleScroll);
    
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
  }, [isLoading, hasMore, threshold]);
  
  const loadMore = useCallback(async () => {
    setIsLoading(true);
    
    try {
      const result = await onLoadMore(page);
      
      if (result.hasMore !== undefined) {
        setHasMore(result.hasMore);
      }
      
      setPage(page + 1);
    } catch (error) {
      console.error('加载失败:', error);
    } finally {
      setIsLoading(false);
    }
  }, [page, onLoadMore]);
  
  return {
    isLoading,
    hasMore,
    loadMore
  };
}

// 使用
function ProductList() {
  const [items, setItems] = useState([]);
  
  const { isLoading, hasMore, loadMore } = useInfiniteScroll({
    threshold: 100,
    onLoadMore: async (page) => {
      const response = await fetch(`/api/products?page=${page}`);
      const data = await response.json();
      
      setItems(prev => [...prev, ...data.items]);
      
      return {
        hasMore: data.hasMore
      };
    }
  });
  
  return (
    <div>
      <div className="product-list">
        {items.map(item => (
          <div key={item.id} className="product-item">
            {item.name}
          </div>
        ))}
      </div>
      
      {isLoading && <div className="loading">加载中...</div>}
      {!hasMore && <div className="no-more">没有更多数据了</div>}
    </div>
  );
}
```

**HTML 和 CSS：**

```html
<div class="content-container">
  <div class="refresh-indicator"></div>
  
  <div class="content">
    <!-- 内容区域 -->
  </div>
  
  <div class="loading-indicator" style="display: none;">
    加载中...
  </div>
</div>

<style>
.content-container {
  position: relative;
  min-height: 100vh;
}

.refresh-indicator {
  height: 0;
  overflow: hidden;
  transition: height 0.3s, opacity 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #f5f5f5;
}

.loading-indicator {
  padding: 20px;
  text-align: center;
  background: #f5f5f5;
}
</style>
```

---

### 3. 如何判断 DOM 元素是否在可视区域？

**答案：**

判断元素是否在可视区域是懒加载、动画触发等功能的基础。

**方案 1：使用 getBoundingClientRect**

```javascript
function isInViewport(element) {
  const rect = element.getBoundingClientRect();
  const windowHeight = window.innerHeight || document.documentElement.clientHeight;
  const windowWidth = window.innerWidth || document.documentElement.clientWidth;
  
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= windowHeight &&
    rect.right <= windowWidth
  );
}

// 使用
const element = document.querySelector('.lazy-image');
if (isInViewport(element)) {
  console.log('元素在可视区域内');
}
```

**方案 2：使用 Intersection Observer API**

```javascript
class VisibilityObserver {
  constructor(options = {}) {
    this.options = {
      threshold: 0.1, // 10% 可见时触发
      rootMargin: '0px',
      ...options
    };
    
    this.observer = new IntersectionObserver(
      this.handleIntersect.bind(this),
      this.options
    );
    
    this.callbacks = new Map();
  }
  
  observe(element, callback) {
    this.callbacks.set(element, callback);
    this.observer.observe(element);
  }
  
  unobserve(element) {
    this.callbacks.delete(element);
    this.observer.unobserve(element);
  }
  
  handleIntersect(entries) {
    entries.forEach(entry => {
      const element = entry.target;
      const callback = this.callbacks.get(element);
      
      if (callback) {
        callback({
          element,
          isIntersecting: entry.isIntersecting,
          intersectionRatio: entry.intersectionRatio
        });
      }
    });
  }
  
  destroy() {
    this.observer.disconnect();
    this.callbacks.clear();
  }
}

// 使用
const visibilityObserver = new VisibilityObserver({
  threshold: 0.1
});

// 监听元素可见性
const element = document.querySelector('.lazy-image');
visibilityObserver.observe(element, ({ isIntersecting, intersectionRatio }) => {
  if (isIntersecting) {
    console.log('元素可见，可见比例:', intersectionRatio);
    
    // 加载图片
    element.src = element.dataset.src;
    
    // 停止观察
    visibilityObserver.unobserve(element);
  }
});
```

**方案 3：使用 scroll 事件监听**

```javascript
class ScrollVisibilityChecker {
  constructor(options = {}) {
    this.options = {
      threshold: 0.1,
      ...options
    };
    
    this.elements = new Map();
    this.bindScroll();
  }
  
  addElement(element, callback) {
    this.elements.set(element, {
      callback,
      isVisible: false
    });
    
    // 立即检查一次
    this.checkVisibility();
  }
  
  removeElement(element) {
    this.elements.delete(element);
  }
  
  bindScroll() {
    window.addEventListener('scroll', this.checkVisibility.bind(this), { passive: true });
    window.addEventListener('resize', this.checkVisibility.bind(this));
  }
  
  checkVisibility() {
    const windowHeight = window.innerHeight || document.documentElement.clientHeight;
    
    this.elements.forEach((data, element) => {
      const rect = element.getBoundingClientRect();
      const isVisible = (
        rect.top < windowHeight &&
        rect.bottom > 0 &&
        rect.left < window.innerWidth &&
        rect.right > 0
      );
      
      // 计算可见比例
      const visibleHeight = Math.min(rect.bottom, windowHeight) - Math.max(rect.top, 0);
      const visibleRatio = visibleHeight / rect.height;
      
      // 状态变化时触发回调
      if (isVisible !== data.isVisible || visibleRatio >= this.options.threshold) {
        data.isVisible = isVisible;
        data.callback({
          element,
          isVisible,
          visibleRatio
        });
      }
    });
  }
  
  destroy() {
    window.removeEventListener('scroll', this.checkVisibility.bind(this));
    window.removeEventListener('resize', this.checkVisibility.bind(this));
    this.elements.clear();
  }
}

// 使用
const visibilityChecker = new ScrollVisibilityChecker({
  threshold: 0.1
});

// 添加元素监听
const element = document.querySelector('.lazy-image');
visibilityChecker.addElement(element, ({ isVisible, visibleRatio }) => {
  if (isVisible && visibleRatio >= 0.1) {
    console.log('元素可见，可见比例:', visibleRatio);
    
    // 加载图片
    element.src = element.dataset.src;
    
    // 移除监听
    visibilityChecker.removeElement(element);
  }
});
```

**方案 4：判断元素部分在可视区域**

```javascript
function isPartiallyInViewport(element, threshold = 0.1) {
  const rect = element.getBoundingClientRect();
  const windowHeight = window.innerHeight || document.documentElement.clientHeight;
  const windowWidth = window.innerWidth || document.documentElement.clientWidth;
  
  // 计算可见区域
  const visibleTop = Math.max(rect.top, 0);
  const visibleBottom = Math.min(rect.bottom, windowHeight);
  const visibleLeft = Math.max(rect.left, 0);
  const visibleRight = Math.min(rect.right, windowWidth);
  
  const visibleWidth = Math.max(0, visibleRight - visibleLeft);
  const visibleHeight = Math.max(0, visibleBottom - visibleTop);
  
  const visibleArea = visibleWidth * visibleHeight;
  const totalArea = rect.width * rect.height;
  const visibleRatio = visibleArea / totalArea;
  
  return visibleRatio >= threshold;
}

// 使用
const element = document.querySelector('.lazy-image');
if (isPartiallyInViewport(element, 0.1)) {
  console.log('元素至少 10% 在可视区域内');
}
```

**实际应用：图片懒加载**

```javascript
class LazyImageLoader {
  constructor(options = {}) {
    this.options = {
      threshold: 0.1,
      rootMargin: '100px',
      ...options
    };
    
    this.observer = new IntersectionObserver(
      this.handleIntersect.bind(this),
      {
        threshold: this.options.threshold,
        rootMargin: this.options.rootMargin
      }
    );
  }
  
  observe(element) {
    this.observer.observe(element);
  }
  
  handleIntersect(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        const src = img.dataset.src;
        
        if (src) {
          img.src = src;
          img.onload = () => {
            img.classList.add('loaded');
          };
          img.onerror = () => {
            img.classList.add('error');
          };
        }
        
        this.observer.unobserve(img);
      }
    });
  }
  
  destroy() {
    this.observer.disconnect();
  }
}

// 使用
const lazyLoader = new LazyImageLoader({
  threshold: 0.1,
  rootMargin: '100px'
});

document.querySelectorAll('img[data-src]').forEach(img => {
  lazyLoader.observe(img);
});
```

---

### 4. 移动端触摸事件处理和手势识别

**答案：**

移动端触摸事件是实现流畅交互的关键。

**基础触摸事件：**

```javascript
class TouchHandler {
  constructor(element) {
    this.element = element;
    this.startX = 0;
    this.startY = 0;
    this.startTime = 0;
    
    this.init();
  }
  
  init() {
    this.element.addEventListener('touchstart', this.handleTouchStart.bind(this));
    this.element.addEventListener('touchmove', this.handleTouchMove.bind(this));
    this.element.addEventListener('touchend', this.handleTouchEnd.bind(this));
    this.element.addEventListener('touchcancel', this.handleTouchCancel.bind(this));
  }
  
  handleTouchStart(e) {
    const touch = e.touches[0];
    this.startX = touch.clientX;
    this.startY = touch.clientY;
    this.startTime = Date.now();
    
    console.log('触摸开始:', this.startX, this.startY);
  }
  
  handleTouchMove(e) {
    const touch = e.touches[0];
    const deltaX = touch.clientX - this.startX;
    const deltaY = touch.clientY - this.startY;
    
    console.log('触摸移动:', deltaX, deltaY);
  }
  
  handleTouchEnd(e) {
    const touch = e.changedTouches[0];
    const endX = touch.clientX;
    const endY = touch.clientY;
    const endTime = Date.now();
    
    const deltaX = endX - this.startX;
    const deltaY = endY - this.startY;
    const deltaTime = endTime - this.startTime;
    
    console.log('触摸结束:', deltaX, deltaY, deltaTime);
  }
  
  handleTouchCancel(e) {
    console.log('触摸取消');
  }
}
```

**手势识别：**

```javascript
class GestureRecognizer {
  constructor(element) {
    this.element = element;
    this.startX = 0;
    this.startY = 0;
    this.startTime = 0;
    this.lastX = 0;
    this.lastY = 0;
    this.lastTime = 0;
    
    this.callbacks = {
      tap: [],
      doubleTap: [],
      longPress: [],
      swipe: [],
      pinch: []
    };
    
    this.init();
  }
  
  init() {
    this.element.addEventListener('touchstart', this.handleTouchStart.bind(this));
    this.element.addEventListener('touchmove', this.handleTouchMove.bind(this));
    this.element.addEventListener('touchend', this.handleTouchEnd.bind(this));
  }
  
  handleTouchStart(e) {
    const touch = e.touches[0];
    this.startX = touch.clientX;
    this.startY = touch.clientY;
    this.startTime = Date.now();
    this.lastX = this.startX;
    this.lastY = this.startY;
    this.lastTime = this.startTime;
  }
  
  handleTouchMove(e) {
    const touch = e.touches[0];
    const currentX = touch.clientX;
    const currentY = touch.clientY;
    const currentTime = Date.now();
    
    // 检测滑动手势
    const deltaX = currentX - this.lastX;
    const deltaY = currentY - this.lastY;
    const deltaTime = currentTime - this.lastTime;
    
    if (deltaTime > 0) {
      const velocityX = deltaX / deltaTime;
      const velocityY = deltaY / deltaTime;
      
      if (Math.abs(velocityX) > 0.5 || Math.abs(velocityY) > 0.5) {
        this.triggerSwipe(deltaX, deltaY);
      }
    }
    
    this.lastX = currentX;
    this.lastY = currentY;
    this.lastTime = currentTime;
  }
  
  handleTouchEnd(e) {
    const touch = e.changedTouches[0];
    const endX = touch.clientX;
    const endY = touch.clientY;
    const endTime = Date.now();
    
    const deltaX = endX - this.startX;
    const deltaY = endY - this.startY;
    const deltaTime = endTime - this.startTime;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    
    // 点击手势（小于 10px 且小于 300ms）
    if (distance < 10 && deltaTime < 300) {
      this.triggerTap();
    }
    // 长按手势（大于 500ms）
    else if (deltaTime >= 500) {
      this.triggerLongPress();
    }
  }
  
  triggerTap() {
    this.callbacks.tap.forEach(callback => callback());
  }
  
  triggerDoubleTap() {
    this.callbacks.doubleTap.forEach(callback => callback());
  }
  
  triggerLongPress() {
    this.callbacks.longPress.forEach(callback => callback());
  }
  
  triggerSwipe(deltaX, deltaY) {
    const direction = this.getSwipeDirection(deltaX, deltaY);
    this.callbacks.swipe.forEach(callback => callback(direction));
  }
  
  getSwipeDirection(deltaX, deltaY) {
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      return deltaX > 0 ? 'right' : 'left';
    } else {
      return deltaY > 0 ? 'down' : 'up';
    }
  }
  
  on(event, callback) {
    if (this.callbacks[event]) {
      this.callbacks[event].push(callback);
    }
  }
}

// 使用
const gesture = new GestureRecognizer(document.querySelector('.container'));

gesture.on('tap', () => {
  console.log('点击');
});

gesture.on('swipe', (direction) => {
  console.log('滑动方向:', direction);
});

gesture.on('longPress', () => {
  console.log('长按');
});
```

**双指缩放手势：**

```javascript
class PinchZoom {
  constructor(element) {
    this.element = element;
    this.initialDistance = 0;
    this.initialScale = 1;
    this.currentScale = 1;
    
    this.init();
  }
  
  init() {
    this.element.addEventListener('touchstart', this.handleTouchStart.bind(this));
    this.element.addEventListener('touchmove', this.handleTouchMove.bind(this));
    this.element.addEventListener('touchend', this.handleTouchEnd.bind(this));
  }
  
  handleTouchStart(e) {
    if (e.touches.length === 2) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      
      this.initialDistance = this.getDistance(touch1, touch2);
      this.initialScale = this.currentScale;
    }
  }
  
  handleTouchMove(e) {
    if (e.touches.length === 2) {
      e.preventDefault();
      
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      
      const currentDistance = this.getDistance(touch1, touch2);
      const scale = currentDistance / this.initialDistance;
      
      this.currentScale = this.initialScale * scale;
      
      // 应用缩放
      this.applyScale(this.currentScale);
    }
  }
  
  handleTouchEnd(e) {
    if (e.touches.length < 2) {
      // 双指操作结束
      console.log('缩放结束，当前缩放比例:', this.currentScale);
    }
  }
  
  getDistance(touch1, touch2) {
    const deltaX = touch1.clientX - touch2.clientX;
    const deltaY = touch1.clientY - touch2.clientY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  }
  
  applyScale(scale) {
    this.element.style.transform = `scale(${scale})`;
  }
}

// 使用
const pinchZoom = new PinchZoom(document.querySelector('.zoomable-container'));
```

**实际应用：图片查看器**

```javascript
class ImageViewer {
  constructor(container) {
    this.container = container;
    this.image = container.querySelector('img');
    this.scale = 1;
    this.minScale = 0.5;
    this.maxScale = 3;
    
    this.init();
  }
  
  init() {
    this.gestureRecognizer = new GestureRecognizer(this.container);
    this.pinchZoom = new PinchZoom(this.container);
    
    // 绑定事件
    this.gestureRecognizer.on('tap', this.handleTap.bind(this));
    this.gestureRecognizer.on('doubleTap', this.handleDoubleTap.bind(this));
  }
  
  handleTap() {
    console.log('点击图片');
  }
  
  handleDoubleTap() {
    // 双击放大或还原
    if (this.scale === 1) {
      this.scale = 2;
    } else {
      this.scale = 1;
    }
    
    this.applyScale();
  }
  
  applyScale() {
    this.image.style.transform = `scale(${this.scale})`;
  }
}

// 使用
const imageViewer = new ImageViewer(document.querySelector('.image-viewer'));
```

---

### 5. 移动端性能优化

**答案：**

移动端性能优化是提升用户体验的关键。

**优化方案 1：图片优化**

```javascript
class ImageOptimizer {
  constructor() {
    this.lazyLoader = null;
    this.init();
  }
  
  init() {
    // 懒加载
    this.initLazyLoad();
    
    // WebP 格式支持检测
    this.detectWebPSupport();
  }
  
  initLazyLoad() {
    this.lazyLoader = new LazyImageLoader({
      threshold: 0.1,
      rootMargin: '100px'
    });
    
    document.querySelectorAll('img[data-src]').forEach(img => {
      this.lazyLoader.observe(img);
    });
  }
  
  detectWebPSupport() {
    const webP = new Image();
    webP.onload = webP.onerror = () => {
      const isSupported = webP.width === 1 && webP.height === 1;
      
      if (isSupported) {
        document.documentElement.classList.add('webp');
      }
    };
    
    webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
  }
  
  // 响应式图片
  getResponsiveImage(baseUrl, width, height) {
    const isWebP = document.documentElement.classList.contains('webp');
    const format = isWebP ? 'webp' : 'jpg';
    
    return `${baseUrl}_${width}x${height}.${format}`;
  }
}

// 使用
const imageOptimizer = new ImageOptimizer();

// 获取响应式图片
const imageUrl = imageOptimizer.getResponsiveImage('/images/photo', 800, 600);
```

**优化方案 2：虚拟滚动**

```javascript
class VirtualScroll {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      itemHeight: 50,
      visibleCount: 20,
      ...options
    };
    
    this.items = [];
    this.startIndex = 0;
    this.init();
  }
  
  init() {
    this.container.addEventListener('scroll', this.handleScroll.bind(this));
  }
  
  setItems(items) {
    this.items = items;
    this.render();
  }
  
  handleScroll() {
    const scrollTop = this.container.scrollTop;
    const startIndex = Math.floor(scrollTop / this.options.itemHeight);
    
    if (startIndex !== this.startIndex) {
      this.startIndex = startIndex;
      this.render();
    }
  }
  
  render() {
    const endIndex = Math.min(
      this.startIndex + this.options.visibleCount,
      this.items.length
    );
    
    const visibleItems = this.items.slice(this.startIndex, endIndex);
    
    // 只渲染可见项
    const fragment = document.createDocumentFragment();
    
    visibleItems.forEach((item, index) => {
      const node = this.renderItem(item);
      node.style.position = 'absolute';
      node.style.top = `${(this.startIndex + index) * this.options.itemHeight}px`;
      fragment.appendChild(node);
    });
    
    this.container.innerHTML = '';
    this.container.appendChild(fragment);
  }
  
  renderItem(item) {
    const div = document.createElement('div');
    div.textContent = item.text;
    div.style.height = `${this.options.itemHeight}px`;
    return div;
  }
}

// 使用
const virtualScroll = new VirtualScroll(document.querySelector('.list-container'), {
  itemHeight: 50,
  visibleCount: 20
});

const items = Array.from({ length: 10000 }, (_, i) => ({
  id: i,
  text: `Item ${i}`
}));

virtualScroll.setItems(items);
```

**优化方案 3：请求优化**

```javascript
class RequestOptimizer {
  constructor() {
    this.cache = new Map();
    this.pendingRequests = new Map();
  }
  
  async request(key, fetcher) {
    // 检查缓存
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    // 检查是否有相同的请求正在进行
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key);
    }
    
    // 发起新请求
    const promise = fetcher().then(data => {
      this.cache.set(key, data);
      this.pendingRequests.delete(key);
      return data;
    }).catch(error => {
      this.pendingRequests.delete(key);
      throw error;
    });
    
    this.pendingRequests.set(key, promise);
    return promise;
  }
  
  clearCache() {
    this.cache.clear();
  }
}

// 使用
const requestOptimizer = new RequestOptimizer();

async function getUser(id) {
  return requestOptimizer.request(`user_${id}`, () => {
    return fetch(`/api/user/${id}`).then(res => res.json());
  });
}
```

**优化方案 4：CSS 优化**

```css
/* 使用 transform 代替 top/left */
.element {
  transform: translate3d(0, 0, 0);
  will-change: transform;
}

/* 使用 opacity 代替 display: none */
.element {
  opacity: 0;
  transition: opacity 0.3s;
}

.element.visible {
  opacity: 1;
}

/* 使用硬件加速 */
.gpu-accelerated {
  transform: translateZ(0);
  backface-visibility: hidden;
}

/* 避免重排 */
.batch-update {
  position: relative;
  left: 0;
  top: 0;
}
```

**优化方案 5：代码分割**

```javascript
// 动态导入
const Home = lazy(() => import('./Home'));
const About = lazy(() => import('./About'));

// 路由级别代码分割
const routes = [
  {
    path: '/',
    component: lazy(() => import('./pages/Home'))
  },
  {
    path: '/about',
    component: lazy(() => import('./pages/About'))
  }
];

// 组件级别代码分割
const HeavyComponent = lazy(() => import('./HeavyComponent'));
```

---

### 6. 移动端兼容性处理

**答案：**

移动端需要处理 iOS 和 Android 的兼容性问题。

**iOS 兼容性问题：**

```javascript
// 1. 解决 1px 边框问题
function set1pxBorder() {
  const dpr = window.devicePixelRatio || 1;
  document.documentElement.setAttribute('data-dpr', dpr);
}

set1pxBorder();

/* CSS */
[data-dpr="1"] .border-1px {
  border: 1px solid #ddd;
}

[data-dpr="2"] .border-1px {
  border: 0.5px solid #ddd;
}

[data-dpr="3"] .border-1px {
  border: 0.333px solid #ddd;
}

/* 或使用伪元素 */
.border-1px {
  position: relative;
}

.border-1px::after {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 1px;
  background: #ddd;
  transform: scaleY(0.5);
}

/* 2. 解决 iOS 滚动卡顿 */
.smooth-scroll {
  -webkit-overflow-scrolling: touch;
  overflow-y: auto;
}

/* 3. 解决 iOS 输入框聚焦问题 */
input:focus,
textarea:focus {
  outline: none;
  -webkit-appearance: none;
}

/* 4. 解决 iOS 安全区域问题 */
.safe-area {
  padding-top: env(safe-area-inset-top);
  padding-bottom: env(safe-area-inset-bottom);
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
}
```

**Android 兼容性问题：**

```javascript
// 1. 检测 Android 版本
function getAndroidVersion() {
  const userAgent = navigator.userAgent;
  const match = userAgent.match(/Android\s(\d+\.\d+)/);
  
  if (match) {
    return parseFloat(match[1]);
  }
  
  return null;
}

// 2. 解决 Android 输入框被键盘遮挡问题
function fixInputFocus() {
  const inputs = document.querySelectorAll('input, textarea');
  
  inputs.forEach(input => {
    input.addEventListener('focus', () => {
      setTimeout(() => {
        input.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }, 300);
    });
  });
}

fixInputFocus();

/* 3. 解决 Android 默认样式重置 */
button,
input,
select,
textarea {
  -webkit-appearance: none;
  appearance: none;
  border: none;
  outline: none;
  background: none;
}

/* 4. 解决 Android 点击高亮问题 */
.no-highlight {
  -webkit-tap-highlight-color: transparent;
}
```

**通用兼容性处理：**

```javascript
// 1. 检测移动设备类型
function getDeviceType() {
  const userAgent = navigator.userAgent;
  
  if (/iPad/i.test(userAgent)) {
    return 'tablet';
  }
  
  if (/iPhone|iPod/i.test(userAgent)) {
    return 'iphone';
  }
  
  if (/Android/i.test(userAgent)) {
    return 'android';
  }
  
  if (/Mobile/i.test(userAgent)) {
    return 'mobile';
  }
  
  return 'desktop';
}

// 2. 检测是否支持触摸
function isTouchDevice() {
  return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
}

// 3. 检测网络状态
function getNetworkType() {
  const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
  
  if (connection) {
    return connection.effectiveType;
  }
  
  return 'unknown';
}

// 4. 监听网络状态变化
function watchNetworkStatus(callback) {
  const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
  
  if (connection) {
    connection.addEventListener('change', () => {
      callback({
        type: connection.effectiveType,
        downlink: connection.downlink,
        rtt: connection.rtt
      });
    });
  }
}

// 使用
console.log('设备类型:', getDeviceType());
console.log('是否支持触摸:', isTouchDevice());
console.log('网络类型:', getNetworkType());

watchNetworkStatus((status) => {
  console.log('网络状态变化:', status);
});
```

**Polyfill 处理：**

```javascript
// 1. Intersection Observer Polyfill
if (!('IntersectionObserver' in window)) {
  // 加载 polyfill
  const script = document.createElement('script');
  script.src = 'https://polyfill.io/v3/polyfill.intersection-observer.min.js';
  document.head.appendChild(script);
}

// 2. Promise Polyfill
if (!('Promise' in window)) {
  // 加载 polyfill
  const script = document.createElement('script');
  script.src = 'https://polyfill.io/v3/polyfill.promise.min.js';
  document.head.appendChild(script);
}

// 3. fetch Polyfill
if (!('fetch' in window)) {
  // 加载 polyfill
  const script = document.createElement('script');
  script.src = 'https://polyfill.io/v3/polyfill.fetch.min.js';
  document.head.appendChild(script);
}
```

---